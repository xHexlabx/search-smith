[
    {
        "page_content": "**รหัสวิฬาร์ (CAT Codes)**\n\nรหัสทำลายข้อมูล CAT Codes เป็นรหัสเลขฐานสองที่สร้างความเสียหายแก่ไฟล์ข้อมูล โดยไฟล์ที่ถูกปนเปื้อนจะมีรหัส CAT Codes ชุดใดชุดหนึ่งปรากฏอยู่ภายใน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อตรวจสอบว่าไฟล์ต้องสงสัยจำนวน n ไฟล์มีการปนเปื้อนรหัสทำลาย CAT Codes หรือไม่\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** ประกอบด้วยจำนวนเต็ม k (จำนวนชุดของ CAT Codes, $5 \\le k \\le 100,000$) และ m (ความยาวของ CAT Codes, $5 \\le m \\le 30$)\n2.  **บรรทัดที่ 2 ถึง k+1** แต่ละบรรทัดแสดงรหัสเลขฐานสองของ CAT Codes แต่ละชุด\n3.  **บรรทัดที่ k+2** เป็นจำนวนเต็ม n (จำนวนไฟล์ที่ต้องการตรวจสอบ, $1 \\le n \\le 100$)\n4.  **2n บรรทัดถัดมา** เป็นข้อมูลของไฟล์แต่ละไฟล์ โดยไฟล์ละ 2 บรรทัด:\n    * บรรทัดแรกคือ d (ความยาวของข้อมูลไฟล์, $1 \\le d \\le 1,000,000$)\n    * บรรทัดที่สองคือข้อมูลรหัสเลขฐานสองของไฟล์นั้น\n\n**ข้อมูลส่งออก**\n\nสำหรับแต่ละไฟล์ ให้แสดงผลการตรวจสอบในหนึ่งบรรทัด:\n* หากตรวจไม่พบ ให้แสดงว่า \"OK\"\n* หากตรวจพบ ให้ระบุหมายเลขชุดของรหัส CAT Codes ที่ตรวจพบ โดยเรียงจากน้อยไปมากและคั่นด้วยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 5 | OK |\n| 01001 | 2 3 5 |\n| 10110 | |\n| 11100 | |\n| 10100 | |\n| 11111 | |\n| 2 | |\n| 15 | |\n| 101010101010101 | |\n| 20 | |\n| 11110110011111000010 | |",
        "metadata": {
            "problem_id": "toi10_catcode",
            "problem_name": "toi10_catcode",
            "source": "TOI",
            "tags": [
                "string",
                "string-matching",
                "search"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\n\nconst int size = 2 << 15;\n\nconst int hash = size - 1;\n\nstd::vector<std::set<std::pair<int, int>>> testNum(size + 5);\n\n\nsigned main() {\n\n    std::ios::sync_with_stdio(false);\n\n    std::cin.tie(nullptr);\n\n\n    int testn, testl;\n\n    std::cin >> testn >> testl;\n\n\n    for (int i = 1; i <= testn; i++) {\n\n        std::string cs;\n\n        std::cin >> cs;\n\n        int sum = 0;\n\n        int mul = 1;\n\n\n        for (int ic = 0; ic < testl; ic++) {\n\n            sum += (cs[ic] - '0') * mul;\n\n            mul = mul << 1;\n\n        }\n\n\n        testNum[sum & (hash)].insert({sum, i});\n\n    }\n\n\n    int q;\n\n    std::cin >> q;\n\n\n    while (q--) {\n\n        int strlen;\n\n        std::string searchS;\n\n        std::cin >> strlen;\n\n        std::cin >> searchS;\n\n\n        std::set<int> res;\n\n\n        if (strlen >= testl) {\n\n            int curr = 0;\n\n\n            for (int i = 0; i < testl - 1; i++) {\n\n                curr = curr >> 1;\n\n                if (searchS[i] == '1') curr += 1 << (testl - 1);\n\n            }\n\n\n            for (int i = testl - 1; i < strlen; i++) {\n\n                curr = curr >> 1;\n\n                if (searchS[i] == '1') curr += 1 << (testl - 1);\n\n\n                auto first = testNum[curr & (hash)].lower_bound({curr, -1e9});\n\n                auto second = testNum[curr & (hash)].upper_bound({curr + 1, -1e9});\n\n\n                for (auto ci = first; ci != second && ci->first == curr; ci++) {\n\n                    res.insert(ci->second);\n\n                }\n\n            }\n\n        }\n\n\n        if (res.empty()) {\n\n            std::cout << \"OK\\n\";\n\n        } else {\n\n            for (auto num : res) std::cout << num << ' ';\n\n            std::cout << '\\n';\n\n        }\n\n    }\n\n}"
        }
    },
    {
        "page_content": "**แอดมินเจ้าระเบียบ (Crazy Admin)**\n\nนายโปโป้ ผู้ดูแลเครือข่ายอินเทอร์เน็ตของหอพัก มีหน้าที่จัดสรรการใช้งานอินเทอร์เน็ตของนักศึกษา O ห้อง เข้ากับสาย ADSL จำนวน M สาย โดยมีเงื่อนไขว่าต้องจัดเรียงตามลำดับหมายเลขห้องพัก และต้องการให้ปริมาณการสื่อสารข้อมูลรวมในแต่ละสายใกล้เคียงกันที่สุด\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาปริมาณการสื่อสารข้อมูลรวมที่ \"มากที่สุด\" ในสาย ADSL ใด ๆ หลังจากที่นายโปโป้ได้จัดสรรให้ปริมาณงานในแต่ละสายสมดุลที่สุดแล้ว\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** ประกอบด้วยจำนวนเต็ม M (จำนวนสาย ADSL, $2 \\le M \\le 20$) และ O (จำนวนห้องพัก, $2 \\le O \\le 100$)\n2.  **O บรรทัดถัดมา** แต่ละบรรทัดแสดงปริมาณการสื่อสารข้อมูล (U) ของแต่ละห้องพัก ($100 \\le U \\le 100,000$)\n\n**ข้อมูลส่งออก**\n\nมีเพียงบรรทัดเดียว แสดงปริมาณการสื่อสารข้อมูลรวมที่มากที่สุดในสายอินเทอร์เน็ต ADSL\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 4 | 800 |\n| 800 | |\n| 400 | |\n| 400 | |\n| 700 | |",
        "metadata": {
            "problem_id": "toi10_crazyadmin",
            "problem_name": "toi10_crazyadmin",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "sorting",
                "array"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint k , n , mid ;\nint arr[101] ;\nint MIN = INT_MIN , MAX = 150000 ;\nint main(){\n    ios_base::sync_with_stdio(0) , cin.tie(0);\n    cin >> k >> n ; \n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> arr[i] ;\n        MIN = max(MIN , arr[i]) ;\n    }\n    //MIN -> lowest memory \n    //arr -> mem\n    while(MIN < MAX){\n        mid = (MIN + MAX) / 2 ;\n         //mid -> cable mem\n        int cnt = 0 ;\n        int mem = 0 ;\n        for(int j = 1 ; j <= n ; j ++ ){\n            if(mem + arr[j] > mid){\n                cnt ++ ;\n                mem = arr[j] ;\n            }\n            else {\n                mem += arr[j] ;\n            }\n        }\n        if(mem != 0){\n            cnt ++ ;\n        }\n        if(cnt <= k){\n            MAX = mid ;\n        }\n        else {\n            MIN = mid + 1 ;\n        }\n    }\n    cout << MIN ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ป้อม 8 ทิศ (Fortress)**\n\nเมืองต๋อยมีป้อม 8 ป้อมล้อมรอบเมืองไว้ (N, NE, E, SE, S, SW, W, NW) เพื่อป้องกันฝูงยักษ์ที่จะบุกมาจาก 4 ทิศหลัก (เหนือ, ใต้, ออก, ตก)\n* **กำลังป้องกัน:** เมื่อยักษ์บุกมาทางทิศใด กำลังป้องกันจะมาจากทหารในป้อมที่ตั้งอยู่ทางทิศนั้นและป้อมข้างเคียงซ้ายขวา (รวม 3 ป้อม)\n* **เงื่อนไขการจัดทหาร:**\n    1.  กำลังป้องกันในแต่ละทิศทั้ง 4 ต้องมีจำนวนเท่ากันกับค่า n ที่กำหนด\n    2.  ทหารในป้อมที่อยู่ทิศตรงข้ามกัน ต้องมีจำนวนเท่ากัน\n\n**งานของคุณ**\n\nผู้กองรีไวล์ต้องการทราบจำนวนวิธีในการจัดสรรทหารทั้งหมด m นาย ให้มีกำลังป้องกันในแต่ละทิศเท่ากับ n นาย\n\n**ข้อมูลนำเข้า**\n\nมีจำนวน 20 บรรทัด แต่ละบรรทัดประกอบด้วยจำนวนเต็มสองจำนวน m (จำนวนทหารทั้งหมด) และ n (กำลังป้องกันที่ต้องการในแต่ละทิศ)\n\n**ข้อมูลส่งออก**\n\nมีจำนวน 20 บรรทัด แต่ละบรรทัดแสดงจำนวนวิธีการจัดสรรทหารตามเงื่อนไขของข้อมูลนำเข้าบรรทัดที่ตรงกัน\n\n**ตัวอย่างข้อมูล**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 40 15 | 11 |\n| 30 12 | 10 |\n| 60 40 | 0 |\n| ... (และข้อมูลอื่นๆ) | ... |",
        "metadata": {
            "problem_id": "toi10_fortress",
            "problem_name": "toi10_fortress",
            "source": "TOI",
            "tags": [
                "math",
                "combinatorics",
                "brute-force"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n\n{\n\n    long long m,n;\n\n    for (int i = 0; i < 20; i++)\n\n    {\n\n        cin >> m >> n;\n\n        if (n > m || 4*n-m < 0 || 4*n-m > m)\n\n        {\n\n            cout << \"0\\n\";\n\n            continue;\n\n        }\n\n        cout << (4*n-m)/2+1;\n\n        cout << \"\\n\";\n\n    }\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**ไปโรงเรียน (Go to School)**\n\nจังหวัดยูบียูมีผังเมืองเป็นตาราง โดยมีถนนแนวเหนือ-ใต้ m สาย และแนวตะวันออก-ตะวันตก n สาย นายต๋อยมีหอพักอยู่ที่สี่แยก (น1, อ1) และต้องเดินทางไปมหาวิทยาลัยที่สี่แยก (นm, อn) โดยจะเดินทางไปทางทิศเหนือและทิศตะวันออกเท่านั้น แต่ในเมืองมีสุนัขเจ้าพ่ออยู่ตามสี่แยกต่างๆ ซึ่งนายต๋อยต้องหลีกเลี่ยง\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมนับจำนวนวิธีที่นายต๋อยสามารถเดินทางไปมหาวิทยาลัยโดยไม่เจอสุนัขเจ้าพ่อ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** ประกอบด้วยจำนวนเต็ม m และ n (จำนวนถนน, $3 \\le m, n \\le 50$)\n2.  **บรรทัดที่สอง** ประกอบด้วยจำนวนเต็ม O แทนจำนวนสุนัขเจ้าพ่อ ($5 \\le O \\le 1,500$)\n3.  **O บรรทัดถัดมา** แสดงตำแหน่งของสุนัขเจ้าพ่อ\n\n**ข้อมูลส่งออก**\n\nมีเพียงบรรทัดเดียว แสดงจำนวนวิธีเดินทางไปมหาวิทยาลัยโดยไม่เจอสุนัขเจ้าพ่อ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 4 | 5 |\n| 3 | |\n| 2 2 | |\n| 2 3 | |\n| 4 2 | |",
        "metadata": {
            "problem_id": "toi10_goschool",
            "problem_name": "toi10_goschool",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "recursion",
                "backtracking"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\n#define en '\\n'\n\n#define sp ' '\n\n#define ll long long\n\n#define pii pair<int, int>\n\n#define piii pair<int, pair<int, int>>\n\n#define st first\n\n#define nd second\n\n#define maxx(a,b) a=max(a,b)\n\n#define minn(a,b) a=min(a,b)\n\nusing namespace std;\n\n\nconst int N=55;\n\nbool a[N][N];\n\nll dp[N][N];\n\n\nint main(){ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n    int m,n,t; cin>>m>>n>>t;\n\n    while(t--){\n\n        int x,y; cin>>x>>y;\n\n        a[y][x]=1;\n\n    }\n\n    if(a[1][1]||(a[1][2]&&a[2][1])){cout<<0; return 0;}\n\n    dp[1][1]=1;\n\n    for(int i=1;i<=n;i++)for(int j=1;j<=m;j++) \n\n        if(i!=1||j!=1) dp[i][j]=(a[i][j]? 0 : dp[i-1][j]+dp[i][j-1]);\n\n    cout<<dp[n][m];\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**แผนที่ลายแทง (Map)**\n\nหัวหน้าชนเผ่าต๋อยได้สร้างแผนที่ลายแทงบนหนังสัตว์รูปสี่เหลี่ยมขนาด $m \\times n$ แล้วตัดแบ่งออกเป็นชิ้นส่วนเล็กๆ ขนาด $1 \\times 1$ จำนวน $m \\times n$ ชิ้น โดยแต่ละชิ้นมีหมายเลขกำกับตั้งแต่ 0 ถึง $(m \\times n) - 1$\n\nความสัมพันธ์ระหว่างชิ้นส่วนที่อยู่ติดกันถูกจารึกไว้ โดยใช้ 'U' แทนการอยู่ติดกันทางด้านบน และ 'L' แทนการอยู่ติดกันทางด้านซ้าย (เช่น `4 L 2` หมายความว่า ชิ้นส่วนหมายเลข 4 อยู่ติดทางด้านซ้ายของชิ้นส่วนหมายเลข 2)\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อประกอบแผนที่ลายแทงจากความสัมพันธ์ที่กำหนดให้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** ประกอบด้วยจำนวนเต็ม m และ n (ขนาดของแผนที่, $1 \\le m, n \\le 200$)\n2.  **$(m \\times n) - 1$ บรรทัดถัดมา** แสดงความสัมพันธ์ระหว่างชิ้นส่วนต่างๆ ในรูปแบบ `i U j` หรือ `i L j`\n\n**ข้อมูลส่งออก**\n\nแสดงการเรียงลำดับชิ้นส่วนของแผนที่ที่ประกอบสมบูรณ์แล้ว โดยแสดงผล m บรรทัด แต่ละบรรทัดมี n จำนวนเต็ม\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 2 | 0 1 |\n| 1 U 5 | 3 5 |\n| 0 U 3 | 4 2 |\n| 4 L 2 | |\n| 0 L 1 | |\n| 5 U 2 | |",
        "metadata": {
            "problem_id": "toi10_map",
            "problem_name": "toi10_map",
            "source": "TOI",
            "tags": [
                "graph",
                "parsing",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int nx=4*1e4+7;\n\nint n,m;\n\nint up[nx];\n\nint down[nx];\n\nint leftt[nx];\n\nint rightt[nx];\n\nint stx=nx,sty=nx;\n\nint arr[607][607];\n\nbool vis[607][607];\n\n\nint main(){\n\n    cin>>n>>m;\n\n    int k=n*m-1;\n\n    for(int i=0;i<=n*m;i++){\n\n        up[i]=down[i]=leftt[i]=rightt[i]=-1;\n\n    }\n\n    for(int i=1;i<=k;i++){\n\n        int a,b;\n\n        char c;\n\n        cin>>a>>c>>b;\n\n        if(c=='U'){\n\n            up[b]=a;\n\n            down[a]=b;\n\n        }\n\n        if(c=='L'){\n\n            leftt[b]=a;\n\n            rightt[a]=b;\n\n        }\n\n    }\n\n    queue<pair<int,pair<int,int>>> q;\n\n    q.push({0,{200,200}});\n\n    while(!q.empty()){\n\n        int cur=q.front().first;\n\n        int curi=q.front().second.first;\n\n        int curj=q.front().second.second;\n\n        q.pop();\n\n        if(vis[curi][curj]){\n\n            continue;\n\n        }\n\n        vis[curi][curj]=1;\n\n        stx=min(stx,curj);\n\n        sty=min(sty,curi);\n\n        arr[curi][curj]=cur;\n\n        if(up[cur]!=-1){\n\n            q.push({up[cur],{curi-1,curj}});\n\n        }\n\n        if(down[cur]!=-1){\n\n            q.push({down[cur],{curi+1,curj}});\n\n        }\n\n        if(rightt[cur]!=-1){\n\n            q.push({rightt[cur],{curi,curj+1}});\n\n        }\n\n        if(leftt[cur]!=-1){\n\n            q.push({leftt[cur],{curi,curj-1}});\n\n        }\n\n    }\n\n    for(int i=0;i<n;i++){\n\n        for(int j=0;j<m;j++){\n\n            cout<<arr[sty+i][stx+j]<<' ';\n\n        }\n\n        cout<<'\\n';\n\n    }\n\n}"
        }
    },
    {
        "page_content": "**ลิงไต่ราว (Climbing Monkey)**\n\nลิงต๋อยต้องปีนเสา n ต้นที่สูง m เมตร เพื่อเก็บกล้วยทิพย์บนยอดเสา ระหว่างเสาที่อยู่ติดกันอาจมีกิ่งไม้เชื่อมในแนวนอน เมื่อลิงปีนไปพบกิ่งไม้ จะถูกบังคับให้ไต่ข้ามไปยังเสาอีกต้นเสมอ\n\nท่านเทพารักษ์ได้มอบกิ่งไม้วิเศษให้ลิงต๋อย 1 อัน ซึ่งสามารถใช้เชื่อมระหว่างเสาสองต้นที่อยู่ติดกัน ณ ระดับความสูงใดก็ได้ เพื่อให้สามารถเก็บกล้วยทิพย์ได้จำนวนมากที่สุด (อาจไม่จำเป็นต้องใช้ก็ได้)\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวนกล้วยทิพย์ที่มากที่สุดที่ลิงต๋อยจะเก็บได้ เมื่อกำหนดเสาเริ่มต้นมาให้ และระบุว่ามีการใช้กิ่งไม้วิเศษหรือไม่\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** จำนวนเต็ม m, n, k (ความสูง, จำนวนเสา, จำนวนกิ่งไม้)\n2.  **บรรทัดที่ 2** จำนวนกล้วยทิพย์บนยอดเสาแต่ละต้น\n3.  **k บรรทัดถัดมา** ข้อมูลของกิ่งไม้แต่ละกิ่ง (หมายเลขเสาซ้าย, ระดับความสูง)\n4.  **บรรทัดสุดท้าย** หมายเลขเสาที่ลิงต๋อยเริ่มปีน\n\n**ข้อมูลส่งออก**\n\n* **บรรทัดแรก** จำนวนกล้วยทิพย์ที่มากที่สุดที่เก็บได้\n* **บรรทัดที่สอง** ระบุ \"USE\" หากใช้กิ่งไม้วิเศษ และ \"NO\" หากไม่ได้ใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 20 5 6 | 9 |\n| 7 5 3 9 4 | USE |\n| 1 5 | |\n| 1 6 | |\n| 2 10 | |\n| 1 12 | |\n| 3 6 | |\n| 3 13 | |\n| 1 | |",
        "metadata": {
            "problem_id": "toi10_monkey",
            "problem_name": "toi10_monkey",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs",
                "dynamic-programming"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pii pair<int, int>\n\n#define inf 0x3f3f3f3f\n\n\nint n, m, k, s, cur;\n\nbool flag[200001];\n\nvector<pii> edges;\n\npii val[200001];\n\n\nint main() {\n\n  ios_base::sync_with_stdio(0);\n\n  cin.tie(0);\n\n  cin >> k >> n >> m;\n\n  for (int i = 1; i <= n; i++) cin >> val[i].first, val[i].second = i;\n\n  edges.resize(m);\n\n  for (int i = 0; i < m; i++) {\n\n    int u, h; cin >> u >> h;\n\n    edges[i] = {h, u};\n\n  }\n\n  sort(edges.begin(), edges.end());\n\n  cin >> s;\n\n  cur = s;\n\n  if (cur+1 <= n) flag[cur+1] = 1;\n\n  if (cur-1 >= 1) flag[cur-1] = 1;\n\n\n  for (auto [h, u]: edges) {\n\n    if (flag[u] && !flag[u+1]) flag[u+1] = 1, flag[u] = 0;\n\n    else if (flag[u+1] && !flag[u]) flag[u] = 1, flag[u+1] = 0;\n\n    if (cur == u) cur = u+1;\n\n    else if (cur == u+1) cur = u;\n\n    if (cur+1 <= n) flag[cur+1] = 1;\n\n    if (cur-1 >= 1) flag[cur-1] = 1;\n\n  }\n\n\n\n  sort(val+1, val+n+1, greater<pii>());\n\n  for (auto [v, i]: val) {\n\n    if (cur == i) {\n\n      cout << v << \"\\nNO\";\n\n      return 0;\n\n    }\n\n    if (flag[i]) {\n\n      cout << v << \"\\nUSE\";\n\n      return 0;\n\n    }\n\n  }\n\n}"
        }
    },
    {
        "page_content": "**นักล่าสมบัติ (TOI Raider)**\n\nดร.เค ต้องเดินทางในถ้ำสมบัติเพื่อไปยังหีบสมบัติ พื้นถ้ำประกอบด้วยแผ่นหินกลรูปหกเหลี่ยมจำนวน m แถว n คอลัมน์ แผ่นหินแต่ละแผ่นมี \"หมายเลขปลอดภัย\" (0-9) กำกับอยู่\n* **การเดินทาง:** เริ่มก้าวจากบริเวณปากถ้ำ (คอลัมน์ที่ 0) ไปยังหีบสมบัติ (คอลัมน์ที่ n-1) โดยต้องก้าวไปยังแผ่นหินที่อยู่ติดกันทีละแผ่น\n* **เงื่อนไขการก้าว:** ในการก้าวครั้งที่ y จะสามารถเหยียบลงบนแผ่นหินที่มีหมายเลขปลอดภัย x ได้ ก็ต่อเมื่อ x ไม่เป็น 0 และ y หารด้วย x ลงตัว\n* **เป้าหมาย:** ไปให้ถึงแผ่นหินที่ n-1 ของแถวที่ $(m-1)/2$\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนก้าวที่น้อยที่สุดในการเดินทางจากปากถ้ำไปยังหีบสมบัติ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** จำนวนเต็ม m (จำนวนแถว, $5 \\le m \\le 97$ และ m หารด้วย 4 เหลือเศษ 1)\n2.  **บรรทัดที่สอง** จำนวนเต็ม n (จำนวนแผ่นหินในแต่ละแถว, $4 \\le n \\le 100$)\n3.  **m บรรทัดถัดมา** แสดงหมายเลขปลอดภัยของแต่ละแผ่นหิน\n\n**ข้อมูลส่งออก**\n\nจำนวนเต็มบวกหนึ่งจำนวน แทนจำนวนก้าวที่น้อยที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 7 |\n| 4 | |\n| 1 1 3 8 | |\n| 0 1 1 0 | |\n| 1 6 5 7 | |\n| 1 3 2 3 | |\n| 2 5 2 0 | |",
        "metadata": {
            "problem_id": "toi10_raider",
            "problem_name": "toi10_raider",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint m, n;\nvector<pair<int,int>> even_d = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, 1}, {-1, 1}};\nvector<pair<int,int>> odd_d = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}, {1, -1}, {-1, -1}};\n\nint grid[105][105];\nbool visited[123][123][5000];\n\nbool check(int i, int j) {\n    return (i >= 0 && i < m && j>=0 && j<n);\n}\nvoid solve() {\n    cin>> m>> n;\n\n    for (int i = 0; i<m; i++) for (int j=0; j<n; j++) cin>> grid[i][j];\n    \n    int mid = (m-1)/2;\n    for (int di = -1; di<=1; di++) {\n        int newi = mid+di;\n        if (check(newi, 0) && grid[newi][0] && grid[newi][0]==1) {\n            visited[newi][0][1] = true;\n        }\n    }\n\n    for (int step = 2; step<=5000; step++) {\n        for (int i=0; i<m; i++) {\n            for (int j=0; j<n; j++) {\n                if (grid[i][j]==0 || step%grid[i][j]) continue; \n                for (auto x : (i%2==0 ? even_d : odd_d)) {\n                    int newi = i+x.first;\n                    int newj = j+x.second;\n                    if (check(newi, newj) && visited[newi][newj][step-1]) {\n                        visited[i][j][step] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        if (visited[mid][n-1][step]) {\n            cout<< step;\n            return;\n        }\n    }\n}\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n}"
        }
    },
    {
        "page_content": "**จุดเทียนภาวนา (Candle Lighting Prayer)**\n\nณ ลานพิธีกรรมที่ปูด้วยกระเบื้อง M แถว N หลัก ผู้คนจะเลือกนั่งบนกระเบื้องหนึ่งคนต่อหนึ่งแผ่น ('1') หรือเว้นว่างไว้ ('0') ก่อนเริ่มพิธี ทุกคนจะต้องจุดเทียน โดยสามารถใช้ไม้ขีดไฟ หรือต่อไฟจากผู้ที่นั่งติดกันใน 8 ทิศทางได้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนไม้ขีดไฟที่ \"น้อยที่สุด\" ซึ่งเพียงพอที่จะทำให้ทุกคนสามารถจุดเทียนได้ครบ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** มีจำนวนเต็มสองจำนวน คือ M (จำนวนแถว) และ N (จำนวนหลัก) ($2 \\le M, N \\le 2,000$)\n2.  **บรรทัดที่ 2 ถึง M+1** แต่ละบรรทัดประกอบด้วยสตริงขนาด N ตัวอักขระ ('0' หรือ '1') แสดงแผนผังการนั่ง\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด ระบุจำนวนไม้ขีดไฟที่น้อยที่สุดที่ต้องใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 5 | 3 |\n| 10011 | |\n| 00001 | |\n| 01100 | |\n| 10011 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 4 | 1 |\n| 0010 | |\n| 1010 | |\n| 0100 | |\n| 1111 | |",
        "metadata": {
            "problem_id": "toi11_candle",
            "problem_name": "toi11_candle",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nbitset<2001>visited[2001] ;\nstruct coor {\n    int x , y ;\n};\nint m , n , cnt = 0 ;\nbool is_valid(int x , int y) { \n    if(x < 0 || x >= m || y < 0 || y >= n)return false;\n    return true ;\n}\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n    cin >> m >> n ;\n    for(int i = 0 ; i < m ; i ++ )cin >> visited[i] ;\n    \n    for(int i = 0 ; i < m ; i ++ ){\n        for(int j = 0 ; j < n ; j ++ ){\n            if(visited[i][j]){\n                \n                cnt ++ ;\n                visited[i][j] = 0 ;\n                queue<coor>q ;\n                q.push({i , j});\n                while(!q.empty()){\n                    \n                    auto temp = q.front();\n                    q.pop() ;\n                    for(int x = -1 ; x <= 1 ; x ++  ){\n                        for(int y = -1 ; y <= 1 ; y ++ ){\n                            int nowx = temp.x + x , nowy = temp.y + y ;\n                            if(is_valid(nowx , nowy)){\n                                if(visited[nowx][nowy]){\n                                    visited[nowx][nowy] = 0 ;\n                                    q.push({nowx , nowy}) ;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    cout << cnt ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ปืนใหญ่แห่งป้อมปราการ (Cannons at the Fort)**\n\nบนกำแพงป้อมปราการ มีการติดตั้งปืนใหญ่ N กระบอก ณ ตำแหน่งต่างๆ ท่านแม่ทัพมีแผนการจัดวางจุดลำเลียงกระสุนปืนใหญ่ K รูปแบบ โดยแต่ละรูปแบบมีจุดลำเลียง M จุด\n\nจุดลำเลียงกระสุนแต่ละจุดที่ตำแหน่ง m จะมีรางลำเลียงกระสุนที่สามารถส่งกระสุนไปยังปืนใหญ่ทุกกระบอกที่อยู่ในช่วงตำแหน่ง $[m-L, m+L]$ ได้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนปืนใหญ่ทั้งหมดที่มีรางลำเลียงกระสุนปืนใหญ่ผ่าน สำหรับแผนการจัดวางแต่ละรูปแบบ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** มีจำนวนเต็มสี่จำนวน N, M, K, L (จำนวนปืนใหญ่, จุดลำเลียงต่อรูปแบบ, จำนวนรูปแบบ, ครึ่งหนึ่งของความยาวรางลำเลียง)\n2.  **บรรทัดที่ 2** มีจำนวนเต็ม N จำนวน คือตำแหน่งของปืนใหญ่แต่ละกระบอก (เรียงจากน้อยไปมาก)\n3.  **บรรทัดที่ 3 ถึง K+2** แต่ละบรรทัดมีจำนวนเต็ม M จำนวน คือตำแหน่งของจุดลำเลียงในแต่ละรูปแบบ (เรียงจากน้อยไปมาก)\n\n**ข้อมูลส่งออก**\n\nมี K บรรทัด แต่ละบรรทัดแสดงจำนวนปืนใหญ่ทั้งหมดที่ได้รับกระสุนสำหรับแผนการจัดวางแต่ละรูปแบบ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 1 1 2 | 2 |\n| 1 2 6 | |\n| 2 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 2 4 100 | 2 |\n| 100 300 500 | 1 |\n| 200 1000 | 3 |\n| 199 1000 | 0 |\n| 200 600 | |\n| 1000 1001 | |",
        "metadata": {
            "problem_id": "toi11_cannon",
            "problem_name": "toi11_cannon",
            "source": "TOI",
            "tags": [
                "array",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint arr[1000001] , n , m , k , l ;\nint main(){\n    ios_base :: sync_with_stdio(0),cin.tie(0);\n    \n    cin >> n >> m >> k >> l ;\n    for(int i = 0 ; i < n ; i ++ ){\n        cin >> arr[i] ;\n    }\n    while(k -- ){\n        int res = 0  , lastr = 0 , idx , idxl ,idxr;\n        for(int i = 0 ; i < m ; i ++ ){\n            cin >> idx ;\n            idxr = upper_bound(arr ,arr + n , idx + l) - arr ;\n            idxl = lower_bound(arr ,arr + n , max(lastr , idx - l )) - arr ;\n \n            res += idxr - idxl ;\n            lastr = idx + l + 1 ;\n        }\n        cout << res << '\\n' ;\n    }\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**กุลีแห่งท่าเรือ (Labor at the Dock)**\n\nนายท่าแห่งบุหงาตันหยงนครได้ว่าจ้างกุลีทั้งหมด M คน เพื่อขนถ่ายสินค้า N ชิ้นจากเรือสำเภา กุลีแต่ละคนมีความสามารถแตกต่างกัน โดยกุลีคนที่ i ใช้เวลา $t_i$ นาทีในการขนสินค้า 1 ชิ้น\n\nเมื่อเรือเทียบท่า กุลีที่ได้รับมอบหมายจะเริ่มทำงานพร้อมกัน และเมื่อขนของเสร็จชิ้นหนึ่งก็จะไปขนชิ้นต่อไปทันที\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาเวลารวม \"น้อยที่สุด\" ที่กุลีจะสามารถขนถ่ายสินค้าทั้งหมดของเรือสำเภาจนเสร็จ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** มีจำนวนเต็มสองจำนวน M (จำนวนกุลี, $2 \\le M \\le 1,000,000$) และ N (จำนวนสินค้า, $1 \\le N \\le 10^{12}$)\n2.  **บรรทัดที่ 2 ถึง M+1** แต่ละบรรทัดคือเวลา $t_i$ ที่กุลีคนที่ i ใช้ในการขนสินค้าหนึ่งชิ้น ($1 \\le t_i \\le 1,000,000$)\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด ระบุเวลารวมน้อยที่สุดที่ใช้ในการขนถ่ายสินค้าทั้งหมด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 5 | 24 |\n| 7 | |\n| 12 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 3 | 6 |\n| 6 | |\n| 13 | |\n| 2 | |",
        "metadata": {
            "problem_id": "toi11_labor",
            "problem_name": "toi11_labor",
            "source": "TOI",
            "tags": [
                "math",
                "array",
                "sorting"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nlong long arr[1000001] ;\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n    long long m , n , l = 1 , r = 1e12 ; cin >> m >> n ;\n    \n    for(int i = 0 ; i < m ; i ++ )cin >> arr[i] ;\n    while(l < r){\n        \n        long long sum = 0 ;\n        long long mid = (l + r) >> 1 ;\n        for(int i = 0 ; i < m ; i ++ ){\n            sum += mid / arr[i] ;\n            if(sum >= n)break ;\n        }\n        if(sum >= n)r = mid ;\n        else l = mid + 1 ;\n    }\n    cout << l ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**หอดูดาว (Observatory)**\n\nรายาบุหรงต้องการสร้างหอดูดาวบนเนินเขาที่มีพื้นที่ขนาด $M \\times N$ ตารางหน่วย โดยฐานของหอดูดาวต้องเป็นรูปสามเหลี่ยมมุมฉากที่มีด้านประกอบมุมฉากยาว K หน่วย และด้านทั้งสองต้องขนานกับขอบของพื้นที่\n\nหอดูดาวนี้ต้องตั้งอยู่บนพื้นที่ที่มีความสูงรวม \"มากที่สุด\" (ผลรวมของความสูงจากระดับน้ำทะเลของทุกตารางหน่วยที่ใช้มีค่ามากที่สุด)\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อคำนวณหาค่าความสูงรวมมากที่สุดของพื้นที่สำหรับสร้างหอดูดาว\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** มีจำนวนเต็มสามจำนวน M, N, และ K (ความกว้าง, ความยาวของพื้นที่ และความยาวด้านประกอบมุมฉากของฐานหอดูดาว)\n2.  **บรรทัดที่ 2 ถึง M+1** แต่ละบรรทัดประกอบด้วยจำนวนเต็ม N จำนวน แทนระดับความสูงของพื้นที่แต่ละตารางหน่วย\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด ระบุค่าความสูงรวมมากที่สุดของพื้นที่ของหอดูดาว\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 5 3 | 22 |\n| 1 2 -1 -4 -20 | |\n| -8 -3 4 2 1 | |\n| 3 8 10 1 3 | |\n| -4 -1 1 7 -6 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 7 4 | -47 |\n| -99 -99 -99 -99 -99 -99 -99 | |\n| -99 -5 -99 -99 -99 -99 -99 | |\n| -99 -5 -5 -99 -99 -99 -4 | |\n| -99 -5 -5 -5 -99 -5 -6 | |\n| -2 -99 -5 -5 -5 -5 -6 | |\n| -5 -5 -5 -99 -99 -99 -4 | |",
        "metadata": {
            "problem_id": "toi11_observatory",
            "problem_name": "toi11_observatory",
            "source": "TOI",
            "tags": [
                "array",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint arr[2002][2002] , qs[2002][2002] , rqs[2002][2002] , tri[2002][2002] , rtri[2002][2002] ;\nint MAX = INT_MIN , m , n , k;\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n    cin >> m >> n >> k ;\n    for(int i = 1 ; i <= m ; i ++ ){\n        for(int j = 1 ; j <= n ; j ++ ){\n            cin >> arr[i][j] ;\n        }\n    }\n    for(int i = 1 ; i <= m ; i ++ ){\n        for(int j = 1 ; j <= n ; j ++ ){\n            qs[i][j] = arr[i][j] + qs[i][j - 1] + qs[i - 1][j] - qs[i - 1][j - 1];\n            tri[i][j] = qs[i][j] - qs[i - 1][j] + tri[i - 1][j - 1] ;\n        }\n        for(int j = n ; j >= 1 ; j -- ){\n            rqs[i][j] = arr[i][j] + rqs[i][j + 1] + rqs[i - 1][j] - rqs[i - 1][j + 1];\n            rtri[i][j] = rqs[i][j] - rqs[i - 1][j] + rtri[i - 1][j + 1] ;\n        }\n    }\n    for(int i = k ; i <= m ; i ++ ){\n        for(int j = k ; j <= n ; j ++ ){\n            MAX = max(MAX , tri[i][j] - qs[i][j - k] + qs[i - k][j - k] - tri[i - k][j - k]);\n        }\n        for(int j = n - k + 1 ; j >= 1 ; j -- ){\n            MAX = max(MAX , rtri[i][j] - rqs[i][j + k] + rqs[i - k][j + k] - rtri[i - k][j + k]);\n        }\n    }\n    cout << MAX ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**สถานที่ศักดิ์สิทธิ์ (Sacred Places)**\n\nตามราชประเพณี องค์รายาต้องไปสักการะสถานที่ศักดิ์สิทธิ์ N แห่ง ซึ่งมีเส้นทางเชื่อมต่อกัน M สาย โดยแต่ละสายมีความยาวต่างกัน\n**เงื่อนไขการเดินทาง:**\n1.  ต้องเลือกเส้นทางจำนวน K เส้น ($K=N-1$) เพื่อให้สามารถเดินทางไปยังทุกสถานที่ได้\n2.  เพื่อให้ประชาชนได้ถวายพระพรอย่างทั่วถึง \"ความยาวรวมของเส้นทางทั้ง K สายที่ถูกเลือกต้องยาวที่สุด\"\n3.  ในแต่ละเส้นทางที่ยาว $l_i$ เมตร จะต้องปักธงจำนวน $l_i - 1$ ผืน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมคำนวณจำนวนธงทั้งหมดที่ต้องใช้ในราชพิธีนี้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** มีจำนวนเต็มสองจำนวน N (จำนวนสถานที่, $2 \\le N \\le 200,000$) และ M (จำนวนเส้นทาง, $1 \\le M \\le 1,000,000$)\n2.  **บรรทัดที่ 2 ถึง M+1** แต่ละบรรทัดมีจำนวนเต็มสามจำนวน $s_i, d_i, l_i$ ระบุสถานที่สองแห่งที่เชื่อมกันและความยาวของเส้นทาง\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด แสดงจำนวนธงทั้งหมดที่ต้องใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 9 | 33 |\n| 1 2 8 | |\n| 2 3 6 | |\n| 1 4 6 | |\n| 4 2 6 | |\n| 4 5 8 | |\n| 2 5 7 | |\n| 5 6 5 | |\n| 2 6 9 | |\n| 3 6 5 | |",
        "metadata": {
            "problem_id": "toi11_place",
            "problem_name": "toi11_place",
            "source": "TOI",
            "tags": [
                "graph",
                "sorting",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nint pa[200001] ;\nint rnk[200001] ;\nint fp(int x){\n    if(pa[x] == x)return x ;\n    return pa[x] = fp(pa[x]);\n}\nstruct path {\n    int u , v , w ;\n    bool operator < (const path & p2)const {\n        return w > p2.w ;\n    }\n};\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n    for(int i = 1 ; i <= 200000 ; i ++ ){\n        pa[i] = i ;\n        rnk[i] = 1;\n    }\n    int n , m , cnt = 0 ; cin >> n >> m ;\n    long long res = 0 ;\n    vector<path>graph ;\n    for(int i = 0 ; i < m ; i ++ ){\n        int U , V , W ;\n        cin >> U >> V >> W ;\n        graph.push_back({U , V , W - 1});\n    }\n    sort(graph.begin(), graph.end());\n    for(int i = 0 ; i < m ; i ++ ){\n        auto temp = graph[i] ;\n        int rootx = fp(temp.u);\n        int rooty = fp(temp.v);\n        if(rootx == rooty)continue ;\n        if(rnk[rootx] > rnk[rooty]){\n            rnk[rootx] += rnk[rooty];\n            rnk[rooty] = 0 ;\n            pa[rooty] = rootx ;\n        }\n        else {\n            rnk[rooty] += rnk[rootx];\n            pa[rootx] = rooty ;\n        }\n        res += temp.w ;\n        cnt ++ ;\n        if(cnt == n - 1)break ;\n    }\n    cout << res ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**การดำเนินการซีกีตีกา (Segi Tiga Operation)**\n\nโหราศาสตร์ลึกลับแห่งบุหงาตันหยงนครมีวิธีการทำนายภัยพิบัติโดยใช้ \"สตริงซีกีตีกา\" ซึ่งเป็นการดำเนินการทางคณิตศาสตร์บนตัวเลข 0, 1, และ 2 ผลลัพธ์ของการดำเนินการขึ้นอยู่กับลำดับการทำงาน (การใส่วงเล็บ)\n\nหากผลลัพธ์ของสตริงซีกีตีกาด้วยลำดับการทำงานใดลำดับหนึ่งเป็น 0 จะทำนายได้ว่ามีภัยพิบัติเกิดขึ้น\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อช่วยตรวจสอบว่าผลลัพธ์ของสตริงซีกีตีกาที่กำหนดให้มีโอกาสเป็น 0 หรือไม่\n\n**ข้อมูลนำเข้า**\n\nมี 20 บรรทัด แต่ละบรรทัดประกอบด้วยจำนวนเต็ม $n_i$ ($2 \\le n_i \\le 255$) และสตริง $s_i$ ซึ่งเป็นชุดของตัวถูกดำเนินการ (ตัวเลข 0, 1, หรือ 2)\n\n**ข้อมูลส่งออก**\n\nมี 20 บรรทัด โดยบรรทัดที่ i แสดงข้อความ \"yes\" ถ้ามีลำดับการทำงานที่ทำให้ผลลัพธ์เป็น 0 และแสดง \"no\" หากไม่มี\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 0201 | yes |\n| 5 10212 | no |\n| 6 002000 | yes |\n| ... (และข้อมูลอื่นๆ อีก 17 บรรทัด) | ... |",
        "metadata": {
            "problem_id": "toi11_segitiga",
            "problem_name": "toi11_segitiga",
            "source": "TOI",
            "tags": [
                "string",
                "recursion",
                "brute-force",
                "backtracking"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nbool dp[256][256][3] ;\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    int n,t = 20 ;\n    string s ;\n    while(t -- ){\n        \n        memset(dp , false , sizeof(dp));\n        cin >> n >> s ;\n        for(int i = 0 ; i < n ; i ++ )dp[i][i][s[i] - '0'] = true ;\n        for(int i = n - 1 ; i >= 0 ; i -- ){\n            for(int j = i + 1 ; j < n ; j ++ ){\n                for(int k = i ; k < j ; k ++ ){\n                    if(dp[i][k][0] && dp[k + 1][j][0])dp[i][j][2] = true ;\n\t\t\t\t\tif(dp[i][k][0] && dp[k + 1][j][1])dp[i][j][1] = true ;\n\t\t\t\t\tif(dp[i][k][0] && dp[k + 1][j][2])dp[i][j][0] = true ;\n\t\t\t\t\t\n\t\t\t\t\tif(dp[i][k][1] && dp[k + 1][j][0])dp[i][j][2] = true ;\n\t\t\t\t\tif(dp[i][k][1] && dp[k + 1][j][1])dp[i][j][1] = true ;\n\t\t\t\t\tif(dp[i][k][1] && dp[k + 1][j][2])dp[i][j][1] = true ;\n\t\t\t\t\t\n\t\t\t\t\tif(dp[i][k][2] && dp[k + 1][j][0])dp[i][j][1] = true ;\n\t\t\t\t\tif(dp[i][k][2] && dp[k + 1][j][1])dp[i][j][2] = true ;\n\t\t\t\t\tif(dp[i][k][2] && dp[k + 1][j][2])dp[i][j][1] = true ;\n\t\t\t\t\t\n\t\t\t\t\tif(dp[i][j][0] && dp[i][j][1] && dp[i][j][2])break;\n                    \n                }\n            }\n        }\n        (dp[0][n - 1][0]) ? cout << \"yes\\n\" : cout << \"no\\n\" ;\n    }\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**เขื่อนกันคลื่น (Barrier)**\n\nเนื่องจากปัญหาการกัดเซาะชายฝั่งทะเล ทางการจึงต้องการสร้างเขื่อนกันคลื่นตามแนวชายหาดที่มีบ้านเรือน n หลังตั้งอยู่ แต่ด้วยงบประมาณที่จำกัด จึงสร้างเขื่อนต่อเนื่องได้เพียงเขื่อนเดียวซึ่งมีความยาวครอบคลุมบ้านได้ไม่เกิน w หลัง\n\nบ้านแต่ละหลังมี \"ค่าความคุ้มค่า\" ในการสร้างเขื่อน ซึ่งอาจเป็นบวกหรือลบก็ได้\n**เงื่อนไขการสร้างเขื่อน:**\n1.  ต้องครอบคลุมบ้านไม่เกิน w หลัง\n2.  ผลรวมของค่าความคุ้มค่าของบ้านที่ถูกครอบคลุมต้องมีค่าเป็นบวก\n3.  ต้องเลือกรูปแบบที่ให้ผลรวมค่าความคุ้มค่า \"สูงสุด\"\n4.  หากมีหลายรูปแบบที่ให้ผลรวมสูงสุดเท่ากัน ให้เลือกรูปแบบที่มี \"ความยาวสั้นที่สุด\"\n\nหากไม่มีรูปแบบใดตรงตามเงื่อนไขเลย ทางการจะไม่สร้างเขื่อน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาผลรวมของค่าความคุ้มค่าของรูปแบบการสร้างเขื่อนที่ดีที่สุด และความยาวของเขื่อนในรูปแบบนั้น\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** จำนวนเต็ม n (จำนวนบ้าน, $1\\le n\\le6,000,000$) และ w (ความยาวเขื่อนสูงสุด, $1\\le w\\le100,000$)\n2.  **n บรรทัดถัดมา** แต่ละบรรทัดคือค่าความคุ้มค่า $v_i$ ของบ้านหลังที่ i ($-500,000\\le v_i\\le500,000$)\n\n**ข้อมูลส่งออก**\n\nมี 2 บรรทัด:\n1.  ผลรวมค่าความคุ้มค่าที่มากที่สุด (หรือ 0 ถ้าไม่สร้างเขื่อน)\n2.  ความยาวที่น้อยที่สุดของเขื่อนในรูปแบบนั้น (หรือ 0 ถ้าไม่สร้างเขื่อน)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 4 | 12 |\n| 3 | 4 |\n| 2 | |\n| 5 | |\n| 1 | |\n| 4 | |\n| -7 | |\n| 10 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 3 | 10 |\n| 3 | 1 |\n| 2 | |\n| 5 | |\n| 1 | |\n| 4 | |\n| -7 | |\n| 10 | |",
        "metadata": {
            "problem_id": "toi12_barrier",
            "problem_name": "toi12_barrier",
            "source": "TOI",
            "tags": [
                "array",
                "prefix-sum",
                "sliding-window"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint arr[6000001] , MAX = 0 , range = 0 , n , k , sum ;\ndeque<int>dq ;\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> n >> k ;\n    for(int i = 1 ; i <= n ; i ++) {\n        cin >> arr[i] ;\n        arr[i] += arr[i - 1];\n    }\n    for(int i = 1 ; i <= n ; i ++ ){\n        if(i == 1){\n            if(arr[i] > MAX){\n                MAX = arr[i] ;\n                range = 1 ;\n                \n            }\n            dq.push_back(1) ;\n        }\n        else {\n            while(!dq.empty() && i - dq.front() > k)dq.pop_front() ;\n            sum = arr[i] - arr[dq.front()] ;\n            if(sum > MAX){\n                MAX = sum;\n                range = i - dq.front() ;\n            }\n            else if(sum == MAX){\n                range = min(range , i - dq.front());\n            }\n            while(!dq.empty() && arr[dq.back()] > arr[i])dq.pop_back() ; \n            dq.push_back(i);\n        }\n    }\n    cout << MAX << '\\n' << range ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**กระเช้าไฟฟ้า (Cable Car)**\n\nบริษัทพาเพลินนำเที่ยวให้บริการกระเช้าไฟฟ้าเชื่อมระหว่างยอดเขา n ยอด โดยมีสายเคเบิล m เส้น แต่ละเส้นมีข้อจำกัดจำนวนผู้โดยสารสูงสุดที่รับได้\n\nเมื่อคณะนักท่องเที่ยว p คนต้องการเดินทางจากยอดเขาต้นทาง s ไปยังยอดเขาปลายทาง d บริษัทจะต้องแบ่งนักท่องเที่ยวออกเป็นกลุ่มย่อยๆ โดยแต่ละกลุ่มจะมีมัคคุเทศก์ 1 คน ซึ่งจะนับเป็นผู้โดยสารด้วย ขนาดของแต่ละกลุ่มย่อย (รวมมัคคุเทศก์) จะต้องไม่เกินขีดจำกัดของกระเช้าในเส้นทางที่เลือกใช้\n\nบริษัทต้องการเลือกเส้นทางที่สามารถจัดกลุ่มย่อยให้มีขนาดใหญ่ที่สุดเท่าที่จะเป็นไปได้ เพื่อจะได้ใช้จำนวนมัคคุเทศก์น้อยที่สุด\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวนมัคคุเทศก์ที่น้อยที่สุดที่ต้องใช้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนยอดเขา, $2\\le N\\le2,500$) และ M (จำนวนสายเคเบิล, $1\\le M\\le1,000,000$)\n2.  **M บรรทัดถัดมา** แต่ละบรรทัดมี u, v, w ระบุสายเคเบิลระหว่างยอดเขา u และ v ที่มีความจุ w\n3.  **บรรทัดสุดท้าย** มี s, d, p ระบุยอดเขาต้นทาง, ปลายทาง, และจำนวนนักท่องเที่ยว\n\n**ข้อมูลส่งออก**\n\nจำนวนเต็มหนึ่งจำนวน แสดงจำนวนมัคคุเทศก์ที่น้อยที่สุดที่ต้องใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 10 | 5 |\n| 1 2 30 | |\n| 1 3 15 | |\n| 1 4 10 | |\n| 2 4 25 | |\n| 2 5 60 | |\n| 3 4 40 | |\n| 4 7 35 | |\n| 3 6 20 | |\n| 5 7 20 | |\n| 6 7 30 | |\n| 1 7 99 | |",
        "metadata": {
            "problem_id": "toi12_cable",
            "problem_name": "toi12_cable",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra",
                "priority-queue",
                "heap"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define endll '\\n'\n#define vec vector\n#define umap unordered_map\nusing namespace std;\nstruct path {\n\tint prev , v , w ;\n\tbool operator<(const path & p2)const{\n\t\treturn p2.w > w ;\n\t}\n};\nvec<vec<path>>graph(2501) ;\nint n , t , str , stp  , W , num;\nint MAX = INT_MIN ;\nint main(){\n\tios_base :: sync_with_stdio(0),cin.tie(0);\n\t\n\tcin >> n >> t ;\n\twhile(t--){\n\t\tcin >> str >> stp >> W ; \n\t\tgraph[str].push_back({0 ,stp , W});\n\t\tgraph[stp].push_back({0 ,str , W}); \n\t}\n\tcin >> str >> stp >> num ;\n\tvec<int>dis(n + 1, INT_MIN);\n\tpriority_queue<path>pq;\n\t\n\tpq.push({0 , str , INT_MAX});\n\t\n\twhile(!pq.empty()){\n\t\tauto temp = pq.top();\n\t\tpq.pop();\n\t\t\n\t\tif(temp.w <= dis[temp.v])continue ;\n\t\tdis[temp.v] = temp.w ;\n\t\t\n\t\tif(temp.v == stp){\n\t\t\tMAX = max(MAX , temp.w);\n\t\t\tbreak ;\n\t\t}\n\t\tfor(auto i : graph[temp.v]){\n\t\t\tif(i.v == temp.prev)continue ;\n\t\t\tpq.push({temp.v , i.v , min(temp.w , i.w)});\n\t\t}\n\t}\n\tcout << ceil ((num + float(num) / float(MAX) + 1) / MAX);\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**กุญแจลับสมบัติเก้าเส้ง (Key)**\n\nหีบสมบัติจะเปิดได้ด้วยกุญแจที่เกิดจากการนำรหัสลับส่วนตัวของน้องสิงหลาและน้องสิงขรมาผสมกัน รหัสลับของทั้งสองคนเป็นสายอักขระที่ประกอบด้วยตัว 'A' และ 'B' เท่านั้น\n\nกุญแจที่ถูกต้องจะเกิดจากการนำตัวอักษรจากรหัสลับทั้งสองมาเรียงต่อกันเป็นสายอักขระใหม่ โดยยังคง \"รักษาลำดับของตัวอักษร\" ในรหัสลับเดิมของแต่ละคนไว้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อตรวจสอบว่ากุญแจที่กำหนดให้แต่ละอัน เป็นกุญแจที่สามารถเปิดหีบสมบัติได้หรือไม่\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** สายอักขระความยาว m แสดงรหัสลับของน้องสิงหลา ($1\\le m\\le1000$)\n2.  **บรรทัดที่ 2** สายอักขระความยาว n แสดงรหัสลับของน้องสิงขร ($1\\le n\\le1000$)\n3.  **บรรทัดที่ 3** จำนวนเต็ม k ระบุจำนวนกุญแจที่ต้องการตรวจสอบ ($1\\le k\\le100$)\n4.  **k บรรทัดถัดมา** แต่ละบรรทัดคือสายอักขระที่ต้องการตรวจสอบ\n\n**ข้อมูลส่งออก**\n\nมี k บรรทัด แต่ละบรรทัดแสดงข้อความ \"Yes\" หากเป็นกุญแจที่ถูกต้อง และ \"No\" หากไม่ถูกต้อง\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| BAB | Yes |\n| AB | Yes |\n| 4 | Yes |\n| BAABB | No |\n| BABAB | |\n| ABBAB | |\n| BBABA | |",
        "metadata": {
            "problem_id": "toi12_key",
            "problem_name": "toi12_key",
            "source": "TOI",
            "tags": [
                "string",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define endll '\\n'\n#define vec vector\n#define umap unordered_map\n#define ll long long \nusing namespace std;\nbool dp[1001][1001] ;\nstring a , b , s;\nint main(){\n\t\n\tios_base :: sync_with_stdio(0),cin.tie(0);\n\t cin >> a >> b ;\n\tint m = b.size() , n = a.size();\n\t\n\tint q ; cin >> q ;\n\t\n\twhile(q--){\n\t\tcin >> s ;\n\t\tmemset(dp , false , sizeof(dp));\n\t\tdp[0][0] = true ;\n\t\t\n\t\tfor(int j = 1 ; j < n + 1 ; j ++ ){\n\t\t\tif( dp[0][j - 1] && s[j - 1] == a[j - 1])dp[0][j] = true ;\n\t\t}\n\t\tfor(int i = 1 ; i < m + 1 ; i ++ ){\n\t\t\tif(dp[i - 1][0] && s[i - 1] == b[i - 1])dp[i][0] = true ;\n\t\t}\n\t\tfor(int i = 1 ; i < m + 1 ; i ++ ){\n\t\t\tfor(int j = 1 ; j < n + 1 ; j ++ ){\n\t\t\t\tif((dp[i - 1][j] && s[j + i - 1] == b[i - 1] ) || ( dp[i][j - 1]&&s[i + j - 1] == a[j - 1] ))dp[i][j] = true ;\n\t\t\t}\n\t\t}\n\t\tif(dp[m][n]) cout << \"Yes\\n\";\n\t\telse cout << \"No\\n\";\n\t}\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**ป้อมภูผา (Peak)**\n\nในอาณาจักรสงขลา มีภูเขา n ลูกเรียงต่อกัน ภูเขาที่เหมาะสมสำหรับสร้างป้อมคือ \"ภูเขาเด่น\"\n* **ภูเขาเด่น:** คือภูเขาที่สูงกว่าภูเขาที่อยู่ติดกันทั้งทางซ้ายและทางขวา (สำหรับภูเขาริมสุด ให้พิจารณาแค่เพื่อนบ้านด้านเดียว)\n\nทางการต้องการสร้างป้อมไม่เกิน k ป้อม โดยมีเงื่อนไขดังนี้:\n1.  ต้องเลือกสร้างบนภูเขาเด่นที่มีความสูงมากที่สุดก่อน\n2.  ไม่อนุญาตให้สร้างป้อมบนภูเขาเด่นที่มีระดับความสูงเท่ากันเกินหนึ่งป้อม\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาความสูงของภูเขาเด่นที่เหมาะสมจะสร้างป้อม\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม n แทนจำนวนภูเขา ($5\\le n\\le5\\times10^6$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม k แทนจำนวนป้อมสูงสุดที่สร้างได้ ($1\\le k\\le5\\times10^5$)\n3.  **n บรรทัดถัดมา** แต่ละบรรทัดคือความสูงของภูเขาแต่ละลูก\n\n**ข้อมูลส่งออก**\n\n* กรณีที่ไม่มีภูเขาเด่นเลย ให้แสดง `-1`\n* มิฉะนั้น ให้แสดงความสูงของภูเขาเด่นที่ถูกเลือก โดยเรียงจากมากไปน้อย\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 | 90 |\n| 2 | 45 |\n| 40 | |\n| 10 | |\n| 90 | |\n| 5 | |\n| 45 | |\n| 50 | |\n| 65 | |\n| 90 | |\n| 35 | |\n| 45 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 | -1 |\n| 3 | |\n| 3 | |\n| 4 | |\n| 6 | |\n| 6 | |\n| 6 | |\n| 8 | |\n| 9 | |",
        "metadata": {
            "problem_id": "toi12_peak",
            "problem_name": "toi12_peak",
            "source": "TOI",
            "tags": [
                "array",
                "sorting"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint n,k,prev1,prev2,curr,pre=-69;\n\nvector<int> v,tmp;\n\nsigned main() {\n\n\tcin.tie(0)->sync_with_stdio(0);\n\n\tcin>>n>>k;\n\n\tcin>>prev2>>prev1;\n\n\tif (prev2>prev1) v.push_back(prev2);\n\n\tfor (int i=0;i<n-2;i++) {\n\n\t\tcin>>curr;\n\n\t\tif (prev1>prev2&&prev1>curr) v.push_back(prev1);\n\n\t\tprev2=prev1;\n\n\t\tprev1=curr;\n\n\t}\n\n\tif (prev1>prev2) v.push_back(prev1);\n\n\tsort(v.begin(),v.end());\n\n\tfor (auto&x:v) {\n\n\t\tif (x==pre) continue;\n\n\t\tpre=x;\n\n\t\ttmp.push_back(x);\n\n\t}\n\n\tif (tmp.size()==0) {\n\n\t\tcout<<-1;\n\n\t}\n\n\telse if (tmp.size()<k) {\n\n\t\tfor (auto&x:tmp) cout<<x<<'\\n';\n\n\t}\n\n\telse {\n\n\t\tint i=tmp.size()-1;\n\n\t\twhile(k--) {\n\n\t\t\tcout<<tmp[i--]<<'\\n';\n\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}"
        }
    },
    {
        "page_content": "**ท่อน้ำ (Pipe)**\n\nทางการต้องการวางท่อน้ำจากจุดจ่ายน้ำไปยังบ้านเรือนประชาชน n หลัง ซึ่งมีที่ตั้งระบุเป็นพิกัด (x, y)\n* สามารถสร้างจุดจ่ายน้ำได้เพียง k จุด และต้องสร้างที่ตำแหน่งของบ้านหลังใดหลังหนึ่ง\n* บ้านแต่ละหลังรับน้ำจากจุดจ่ายน้ำได้เพียงจุดเดียว\n* ท่อน้ำสามารถวางได้ในแนวขนานกับแกนนอนหรือแกนตั้งเท่านั้น\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาความยาวรวมที่ \"น้อยที่สุด\" ของท่อน้ำที่ทำให้สามารถจ่ายน้ำไปยังบ้านได้ครบทุกหลัง\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** จำนวนเต็ม n (จำนวนบ้าน, $3\\le n\\le15,000$) และ k (จำนวนจุดจ่ายน้ำ, $1\\le k<n$)\n2.  **n บรรทัดถัดมา** แต่ละบรรทัดมีพิกัด (x, y) ของบ้านแต่ละหลัง\n\n**ข้อมูลส่งออก**\n\nจำนวนเต็มหนึ่งจำนวน ระบุความยาวรวมน้อยที่สุดของท่อน้ำที่ต้องใช้\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 2 | 18 |\n| 2 9 | |\n| 9 7 | |\n| 14 2 | |\n| 12 9 | |\n| 16 4 | |",
        "metadata": {
            "problem_id": "toi12_pipe",
            "problem_name": "toi12_pipe",
            "source": "TOI",
            "tags": [
                "geometry",
                "sorting",
                "brute-force",
                "dynamic-programming"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define endll '\\n'\n#define vec vector\n#define umap unordered_map\n#define ll long long \nusing namespace std;\nbool dp[1001][1001] ;\nstring a , b , s;\nint main(){\n\t\n\tios_base :: sync_with_stdio(0),cin.tie(0);\n\t cin >> a >> b ;\n\tint m = b.size() , n = a.size();\n\t\n\tint q ; cin >> q ;\n\t\n\twhile(q--){\n\t\tcin >> s ;\n\t\tmemset(dp , false , sizeof(dp));\n\t\tdp[0][0] = true ;\n\t\t\n\t\tfor(int j = 1 ; j < n + 1 ; j ++ ){\n\t\t\tif( dp[0][j - 1] && s[j - 1] == a[j - 1])dp[0][j] = true ;\n\t\t}\n\t\tfor(int i = 1 ; i < m + 1 ; i ++ ){\n\t\t\tif(dp[i - 1][0] && s[i - 1] == b[i - 1])dp[i][0] = true ;\n\t\t}\n\t\tfor(int i = 1 ; i < m + 1 ; i ++ ){\n\t\t\tfor(int j = 1 ; j < n + 1 ; j ++ ){\n\t\t\t\tif((dp[i - 1][j] && s[j + i - 1] == b[i - 1] ) || ( dp[i][j - 1]&&s[i + j - 1] == a[j - 1] ))dp[i][j] = true ;\n\t\t\t}\n\t\t}\n\t\tif(dp[m][n]) cout << \"Yes\\n\";\n\t\telse cout << \"No\\n\";\n\t}\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**กำจัดจุดอ่อน (Weak Point)**\n\nในระบบเครือข่ายมีแหล่งสำรองข้อมูล N จุด และมีลิงค์เชื่อมต่อ N เส้น โดยแหล่งข้อมูลหลักอยู่ที่จุด M การอัพเดตข้อมูลสามารถส่งไปถึงทุกแหล่งได้\n* **แหล่งสำรองข้อมูลสุ่มเสี่ยง:** คือแหล่งข้อมูล (ที่ไม่ใช่ M) ซึ่งเมื่อชำรุดแล้ว จะทำให้แหล่งข้อมูลหลักกระจายการอัพเดตไปยังแหล่งอื่น ๆ ได้ \"น้อยจุดที่สุด\"\n* **จุดอ่อนของระบบ:** คือแหล่งข้อมูลสุ่มเสี่ยงซึ่งมีหมายเลขกำกับ \"น้อยที่สุด\"\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจุดอ่อนของระบบ และจำนวนแหล่งข้อมูลที่จะไม่ได้รับการอัพเดตหากจุดอ่อนนั้นชำรุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนแหล่งข้อมูล, $3\\le N\\le500,000$) และ M (แหล่งข้อมูลหลัก, $1\\le M\\le N$)\n2.  **N บรรทัดถัดมา** แต่ละบรรทัดมี a และ b ระบุลิงค์เครือข่ายระหว่างสองจุด\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดที่ 1** หมายเลขกำกับของแหล่งข้อมูลที่เป็นจุดอ่อน\n2.  **บรรทัดที่ 2** จำนวนแหล่งข้อมูลที่ไม่ได้รับการอัพเดต (ไม่รวมจุดอ่อนที่ชำรุด)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 12 1 | 2 |\n| 1 2 | 2 |\n| 1 6 | |\n| 1 7 | |\n| 1 12 | |\n| 6 8 | |\n| 6 9 | |\n| 2 3 | |\n| 2 10 | |\n| 10 11 | |\n| 3 4 | |\n| 4 5 | |\n| 5 12 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 12 12 | 1 |\n| 1 2 | 4 |\n| 1 6 | |\n| 1 7 | |\n| 1 12 | |\n| 6 8 | |\n| 6 9 | |\n| 2 3 | |\n| 2 10 | |\n| 10 11 | |\n| 3 4 | |\n| 4 5 | |\n| 12 5 | |",
        "metadata": {
            "problem_id": "toi12_weakpoint",
            "problem_name": "toi12_weakpoint",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint m , k , x , y , cnt_ans , node_ans , ti = 1 ;\nint visited[500001] , low[500001] , cnt[500001];\nvector<int>graph[500001] ;\nvoid dfs(int now , int pa){\n    \n    visited[now] = low[now] = ti ++ ;\n    for(auto i : graph[now]){\n        if(!visited[i]){\n            dfs(i , now) ;\n            low[now] = min(low[now] , low[i]) ;\n            if(low[i] != 1){\n                cnt[now] += cnt[i] + 1 ;\n            }\n        }\n        else if(i != pa){\n            low[now] = min(low[now] , low[i]) ;\n        }\n    }\n    if(now != k ){\n        if(cnt[now] > cnt_ans){\n            node_ans = now ;\n            cnt_ans = cnt[now] ;\n        }\n        if(cnt[now] == cnt_ans && now < node_ans){\n            node_ans = now ;\n        }\n    }\n}\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> m >> k ;\n    \n    for(int i = 0 ; i < m ; i ++ ){\n        cin >> x >> y ;\n        graph[x].push_back(y) ;\n        graph[y].push_back(x) ;\n    }\n    dfs(k , -1);\n    cout << node_ans << '\\n' << cnt_ans ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ศิลปะโครมาโทกราฟี (Chromatography Art)**\n\nเพื่อเป็นการสร้างสรรค์งานศิลปะ จึงมีการออกแบบแขนกลเพื่อทำการลงจุดสีในช่องแถวล่างสุดของตาราง แล้วปล่อยให้สีเคลื่อนที่ผ่านตัวดูดซับขึ้นไปยังส่วนบนของตาราง\n\nการลงจุดสีครั้งที่ i จะถูกแทนด้วย $(s_i, h_i, w_i, o_i)$ ซึ่งหมายถึงการลงจุดสีที่แถวล่างสุด เริ่มที่คอลัมน์ $s_i$ เป็นความกว้าง $w_i$ ช่อง ด้วยค่าสี $o_i$ และสีนี้สามารถเคลื่อนที่สูงขึ้นไปได้ $h_i$ ช่อง เกิดเป็นรูปสี่เหลี่ยมผืนผ้า ในกรณีที่มีสีซ้อนทับกันในช่องใด ๆ ค่าสีที่เกิดขึ้นจะมีค่าเท่ากับ \"ผลรวม\" ของค่าสีในช่องนั้น\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพเพื่อหาพื้นที่รวมของบริเวณที่มีค่าสีเท่ากับค่าที่สนใจ (T) จากภาพศิลปะโครมาโทกราฟีที่สร้างขึ้น\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** มีจำนวนเต็มสองจำนวน N (จำนวนครั้งของการลงจุดสี, $1 \\le N \\le 100,000$) และ T (ค่าสีที่สนใจ, $1 \\le T \\le 10,000,000$)\n2.  **N บรรทัดต่อมา** แต่ละบรรทัดมีจำนวนเต็มบวกสี่จำนวน $s_i, h_i, w_i, o_i$ แทนรายละเอียดการลงจุดสีแต่ละครั้ง\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็มหนึ่งจำนวน ระบุพื้นที่รวมของบริเวณที่มีค่าสีที่สนใจ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 3 | 2 |\n| 1 1 4 1 | |\n| 2 2 2 2 | |\n| 3 3 1 3 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 2 | 8 |\n| 3 2 2 2 | |\n| 1 2 2 2 | |",
        "metadata": {
            "problem_id": "toi13_art",
            "problem_name": "toi13_art",
            "source": "TOI",
            "tags": [
                "array",
                "simulation"
            ],
            "solution_code": "#include<bits/stdc++.h>  \n\nusing namespace std ; \n\nstruct point{\n    int s , h , o ;\n    bool operator < (const point & rhs)const{\n        if(s != rhs.s)return s < rhs.s ;\n        return o < rhs.o ;\n    }\n};\nconst int N = 1000001 ;\nint n , t , s , h , w , o , mul , ans = 0; \nvector<point>vec ;\nclass Fenwick {\n    public :\n        int fw[N] ;\n        \n        void update(int idx , int val){\n            for(; idx < N ; idx += (idx & -idx)){\n                fw[idx] += val ;\n            }\n            return ;\n        }\n        int query(int idx){\n            int res = 0 ;\n            for(; idx > 0 ;idx -= (idx & -idx)){\n                res += fw[idx] ;\n            }\n            return res ;\n        }\n        int upper(){\n            int l = 1 , r = N ;\n            while(l < r){\n                int mid = (l + r) >> 1 ;\n                if(query(mid) <= t)r = mid ;\n                else l = mid + 1 ;\n            }\n            return l ;\n        }\n        int lower(){\n            int l = 1 , r = N ;\n            while(l < r){\n                int mid = (l + r) >> 1 ;\n                if(query(mid) < t)r = mid ;\n                else l = mid + 1 ;\n            }\n            return l ;\n        }\n}fw;\nint main () {\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> n >> t ;\n    for(int i = 0 ; i < n ; i ++ ){\n        cin >> s >> h >> w >> o ;\n        vec.push_back({s , h , o});\n        vec.push_back({s + w , h , -o});\n    }\n    sort(vec.begin(), vec.end());\n    for(int i = 0 ; i < 2 * n - 1 ; i ++ ){\n        h = vec[i].h , o = vec[i].o ;\n        fw.update(1 , o) ;\n        fw.update(h + 1 , -o);\n        mul = vec[i + 1].s - vec[i].s ;\n        ans += mul * (fw.lower() - fw.upper()) ;\n    }\n    cout << ans ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**วิฬาร์ (Cats)**\n\nในการประกวดแมวสุขภาพดี มีแมวเข้าร่วม N ตัว (N เป็นจำนวนคู่) โดยแมวทุกตัวมีคู่ และแมวที่เป็นคู่กันจะมีขนาดเท่ากัน ทางผู้จัดงานต้องการให้แมวที่เป็นคู่กันมายืนอยู่ติดกันในแถว ซึ่งอาจต้องมีการเคลื่อนย้ายแมวบางตัว\n\nการเคลื่อนย้ายแมวต้องใช้กรง โดยกรงจะต้องมีขนาดใหญ่กว่าหรือเท่ากับขนาดของแมวที่จะย้าย และสามารถสร้างกรงได้เพียงขนาดเดียวเพื่อใช้ในการเคลื่อนย้ายทั้งหมด ดังนั้นขนาดกรงต้องเล็กที่สุดที่สามารถบรรจุแมวตัวใหญ่ที่สุดที่ \"จำเป็นต้องถูกย้าย\" ได้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาขนาดของกรงที่เหมาะสม (ขนาดเล็กที่สุด) ที่ทำให้สามารถจัดแถวให้แมวทุกคู่ยืนติดกันได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** มีจำนวนเต็มคู่ N (จำนวนแมว, $2 \\le N \\le 2,000,000$)\n2.  **N บรรทัดต่อมา** แต่ละบรรทัดระบุขนาดของแมวแต่ละตัว\n\n**ข้อมูลส่งออก**\n\nแสดงขนาดของกรงที่เหมาะสม ถ้าหากไม่ต้องเคลื่อนย้ายแมวเลยให้แสดงผลเป็น 0\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 | 2 |\n| 3 | |\n| 3 | |\n| 2 | |\n| 5 | |\n| 5 | |\n| 2 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 | 3 |\n| 3 | |\n| 5 | |\n| 2 | |\n| 2 | |\n| 5 | |\n| 3 | |",
        "metadata": {
            "problem_id": "toi13_cats",
            "problem_name": "toi13_cats",
            "source": "TOI",
            "tags": [
                "array",
                "sorting"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define endll '\\n'\n#define vec vector\n#define umap unordered_map\n#define ll unsigned long long \nusing namespace std;\nll arr[20000001];\nint main(){\n\t\n\tll n ; scanf(\"%lld\" , &n);\n\tfor(ll i = 0 ; i < n ; i ++)scanf(\"%lld\" , &arr[i]) ;\n\tll l = 0 , r = 1e10 , mid; \n\tbool can ; deque<ll>dq ;\n\t\n\twhile(l < r){\n\t\tdq.clear();\n\t\tmid = (l + r) >> 1 ;\n\t\tfor(int i = 0 ; i < n ; i ++ ){\n\t\t\tif(arr[i] > mid){\n\t\t\t\tif(dq.empty())dq.push_back(arr[i]);\n\t\t\t\telse {\n\t\t\t\t\tif(dq.back() == arr[i])dq.pop_back();\n\t\t\t\t\telse  break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dq.empty())r = mid ;\n\t\telse l = mid  + 1; \n\t}\n\tprintf(\"%lld\" , l) ;\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**กล้วยไม้ (Orchid)**\n\nในการจัดงานแสดงกล้วยไม้ มีการจัดแสดงต้นกล้วยไม้ N ต้นเรียงกันเป็นแถวยาว แต่การจัดเรียงในตอนแรกยังไม่สวยงาม ผู้จัดงานต้องการให้ต้นกล้วยไม้เรียงตามลำดับความสูงจากน้อยไปสูง (ต้นทางซ้ายต้องสูงน้อยกว่าหรือเท่ากับต้นทางขวา)\n\nในการจัดเรียงใหม่จะใช้วิธีการนำต้นกล้วยไม้ต้นใหม่ไป \"เปลี่ยนแทนที่\" ต้นเดิม โดยต้องการให้จำนวนต้นที่ถูกเปลี่ยน \"น้อยที่สุด\"\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนของต้นกล้วยไม้ที่น้อยที่สุดที่ต้องเปลี่ยน เพื่อให้กล้วยไม้ทั้งหมดเรียงตามลำดับความสูงจากน้อยไปสูง\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนต้นกล้วยไม้, $3 \\le N \\le 1,000,000$)\n2.  **N บรรทัดต่อมา** แต่ละบรรทัดระบุความสูงของต้นกล้วยไม้\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็มหนึ่งจำนวน ระบุจำนวนต้นกล้วยไม้ที่น้อยที่สุดที่ต้องเปลี่ยน\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 2 |\n| 5 | |\n| 4 | |\n| 3 | |\n| 6 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 | 3 |\n| 1 | |\n| 2 | |\n| 3 | |\n| 4 | |\n| 5 | |\n| 6 | |\n| 7 | |\n| 1 | |\n| 2 | |\n| 3 | |",
        "metadata": {
            "problem_id": "toi13_orchid",
            "problem_name": "toi13_orchid",
            "source": "TOI",
            "tags": [
                "array",
                "sorting",
                "greedy"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint lis(int *arr,int n){\n\n    if(!n) return 0;\n\n    vector<int> val;\n\n    for(int i=0; i<n; i++){\n\n        auto idx=upper_bound(val.begin(),val.end(),arr[i])-val.begin();\n\n        if(idx>=(int)val.size()) val.push_back(arr[i]);\n\n        else val[idx]=arr[i];\n\n    }\n\n    return val.size();\n\n}\n\nint main(){\n\n    int n;\n\n    cin >> n;\n\n    int arr[n];\n\n    for(int i=0; i<n; i++) cin >> arr[i];\n\n    cout << n-lis(arr,n);\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**หุ่นยนต์ (Robot)**\n\nมีหุ่นยนต์ K ตัว ('X') ในแผนที่ตารางขนาด $N \\times M$ ซึ่งในแผนที่มีพื้นที่ว่าง ('E'), สิ่งกีดขวาง ('W'), และสิ่งของเป้าหมาย ('A') หลายชิ้น หุ่นยนต์สามารถเคลื่อนที่ได้ 4 ทิศทาง (ซ้าย, ขวา, หน้า, หลัง) ผ่านพื้นที่ E, A, X แต่ไม่สามารถผ่าน W ได้\n\n**ภารกิจ:**\nหุ่นยนต์ต้องเก็บสิ่งของเป้าหมายให้ได้มากที่สุด โดยใช้จำนวนก้าวเดินรวมของหุ่นยนต์ทุกตัวน้อยที่สุด\n* การเก็บของ 1 ชิ้น: หุ่นยนต์ต้องเดินจากจุดเริ่มต้นไปยังตำแหน่งของ 'A' แล้วเดินทางกลับมายังจุดเริ่มต้นเดิม\n* หุ่นยนต์ 1 ตัวสามารถบรรทุกของได้ครั้งละ 1 ชิ้นเท่านั้น\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนชิ้นของสิ่งของเป้าหมายที่เก็บได้มากที่สุด และจำนวนก้าวรวมที่น้อยที่สุดที่ใช้ในการเก็บของจำนวนนั้น\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N และ M (ขนาดตาราง, $1 \\le N, M \\le 2,000$)\n2.  **N บรรทัดต่อมา** เป็นแผนที่ข้อมูล\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็มสองจำนวนคั่นด้วยช่องว่าง:\n1.  จำนวนชิ้นของสิ่งของเป้าหมายที่เก็บได้มากที่สุด\n2.  จำนวนก้าวรวมที่น้อยที่สุดที่ใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 5 | 3 18 |\n| EEEEE | |\n| AEAEW | |\n| WEEWW | |\n| WEEXE | |\n| WWEXA | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 5 | 1 6 |\n| WEEEE | |\n| AWAEW | |\n| WEEWW | |\n| WEEXE | |\n| WWEEE | |",
        "metadata": {
            "problem_id": "toi13_robot",
            "problem_name": "toi13_robot",
            "source": "TOI",
            "tags": [
                "graph",
                "bfs",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\n#define pii pair<int,int>\n\nusing namespace std;\n\nint dx[] = {-1,0,1,0};\n\nint dy[] = {0,-1,0,1};\n\n\nint main() {\n\n    int n;\n\n    int m;\n\n\n    cin >> n >> m;\n\n    vector<vector<char>>grid(n,vector<char>(m));\n\n    vector<vector<int>>d(n,vector<int>(m,1e9));\n\n    vector<pii>obj;\n\n    queue<pii>q;\n\n    \n\n    for (int i=0; i<n; i++) {\n\n        for (int j=0; j<m; j++) {\n\n            cin >> grid[i][j];\n\n            \n\n            if (grid[i][j] == 'X') {\n\n                q.push({j,i});\n\n                d[i][j] = 0;\n\n            }\n\n            else if (grid[i][j] == 'A') {\n\n                obj.push_back({j,i});\n\n            }\n\n        }\n\n    }\n\n\n    while (!q.empty()) {\n\n        int x,y;\n\n        tie(x,y) = q.front();\n\n        q.pop();\n\n\n        for (int i=0; i<4; i++) {\n\n            int nx = x + dx[i];\n\n            int ny = y + dy[i];\n\n            \n\n            if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;\n\n            if (grid[ny][nx] == 'X' || grid[ny][nx] == 'W') continue;\n\n            if (d[ny][nx] > d[y][x]+1) {\n\n                q.push({nx,ny});\n\n                d[ny][nx] = d[y][x]+1;\n\n            }\n\n        }\n\n    }\n\n\n    int ans = 0;\n\n    int cnt = 0;\n\n\n    for (auto &o : obj) {\n\n        if (d[o.second][o.first] != 1e9) {\n\n            ++cnt;\n\n            ans+=2*(d[o.second][o.first]);\n\n        }\n\n    }\n\n    cout << cnt << \" \" << ans;\n\n}"
        }
    },
    {
        "page_content": "**สวิตช์เวลา (timer switch)**\n\nสวิตช์เวลามีลักษณะเป็นวงกลมและมีสวิตช์ย่อย N ตัวเรียงอยู่โดยรอบ สวิตช์ย่อยแต่ละตัวมีสถานะเปิด (1) หรือปิด (0) เมื่อสวิตช์เวลาทำงาน มันจะหมุนทวนเข็มนาฬิกาไปเรื่อยๆ โดยเมื่อเวลาผ่านไป 1 หน่วยเวลา ตำแหน่งบนสุดของสวิตช์จะชี้ไปยังสวิตช์ย่อยถัดไป\n\nรูปแบบของสวิตช์เวลาสามารถแทนได้ด้วยสายอักขระบิตความยาว N โดยบิตแรกคือสวิตช์ย่อยตำแหน่งบนสุด และบิตถัดๆ ไปคือสวิตช์ย่อยตามเข็มนาฬิกา\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนหน่วยเวลาที่ \"น้อยที่สุด\" ที่เมื่อปล่อยให้สวิตช์เวลาทำงานแล้ว สวิตช์เวลาจะกลับมามีรูปแบบเหมือนสวิตช์เวลาตั้งต้น\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็มบวก N (ขนาดของสายอักขระบิต, $2 \\le N \\le 5,000,000$)\n2.  **บรรทัดที่ 2** สายอักขระบิตขนาด N\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็มบวกหนึ่งจำนวน ระบุหน่วยเวลาที่น้อยที่สุดที่สวิตช์จะกลับมามีรูปแบบเดิม\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 | 2 |\n| 1010101010 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 | 10 |\n| 1000000010 | |",
        "metadata": {
            "problem_id": "toi13_timerswitch",
            "problem_name": "toi13_timerswitch",
            "source": "TOI",
            "tags": [
                "string",
                "math"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long hashcode = 3 ;\nlong long hashFuction(string s){\n    int n = s.length();\n    long long hashed = 0;\n    for(int i=0;i<n;i++){\n        hashed *= hashcode;\n        hashed += s[i] - '0';\n    }\n    return hashed;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    \n    int n;\n    cin >> n;\n    \n    string s;\n    cin >> s;\n    \n    long long maxMultiple = 1, currentHashed = hashFuction(s), target = currentHashed;\n    for(int i=0;i<n-1;i++)\n        maxMultiple *= hashcode;\n    for(int i=0;i<n;i++){\n        currentHashed -= (s[i]-'0') * maxMultiple;\n        currentHashed *= hashcode;\n        currentHashed += s[i] - '0';\n        \n        if(currentHashed == target){\n            int same = true;\n            string ss = s + s;\n            for(int j=0;j<n;j++){\n                if(ss[i+j+1] != s[j]){\n                    same = false;\n                    break;\n                }\n            }\n            if(same){\n                cout << i+1;\n                break;\n            }\n        }\n    }\n}"
        }
    },
    {
        "page_content": "**การเดินทางโดยประหยัด (Budget Travelling)**\n\nนักวิจัยต้องการเดินทางจากเขตปกครองต้นทาง X ไปยังเขตปกครองปลายทาง Y ในอาณาจักรที่มี N เขต และ M เส้นทางรถไฟฟ้า โดยมีงบประมาณจำกัดไม่เกิน Z กิโลเมตร\n\n**แผนการเดินทาง:**\n1.  **ถ้างบประมาณเพียงพอ:** นักวิจัยจะเดินทางตามเส้นทางที่สั้นที่สุดจาก X ไป Y\n2.  **ถ้างบประมาณไม่เพียงพอ:** นักวิจัยจะเดินทางจาก X ไปยังเขตปกครอง P ที่อยู่ใกล้กับ Y มากที่สุด (โดยที่การเดินทางจาก X ไป P ยังอยู่ในงบ Z) แล้วให้รถจาก Y มารับ\n    * ถ้ามีเขต P ที่ใกล้ Y ที่สุดเท่ากันหลายแห่ง ให้เลือกเขต P ที่มีหมายเลขกำกับน้อยที่สุด\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อวางแผนการเดินทางและหาระยะทางต่างๆ ตามเงื่อนไข\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N และ M (จำนวนเขต, จำนวนเส้นทาง)\n2.  **บรรทัดที่ 2** จำนวนเต็ม X, Y, Z (เขตต้นทาง, เขตปลายทาง, งบประมาณ)\n3.  **M บรรทัดต่อมา** แต่ละบรรทัดมี u, v, d ระบุเส้นทางระหว่าง u และ v ที่มีระยะทาง d\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็มสามจำนวน คั่นด้วยช่องว่าง:\n1.  หมายเลขเขตปกครองที่เป็นจุดหมายการเดินทางของนักวิจัย\n2.  ระยะทางที่นักวิจัยเดินทาง\n3.  ระยะทางที่รถต้องมารับ (เป็น 0 หากถึงที่หมาย)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 11 | 5 50 0 |\n| 0 5 200 | |\n| 0 1 10 | |\n| 0 2 10 | |\n| 1 3 10 | |\n| 1 5 70 | |\n| 2 3 10 | |\n| 2 4 30 | |\n| 2 6 10 | |\n| 3 5 30 | |\n| 4 5 20 | |\n| 6 7 15 | |\n| 7 5 20 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 11 | 4 40 20 |\n| 0 5 45 | |\n| 0 1 10 | |\n| 0 2 10 | |\n| ... (เหมือนตัวอย่างที่ 1) | |",
        "metadata": {
            "problem_id": "toi13_traveler",
            "problem_name": "toi13_traveler",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra",
                "bfs"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nconst long long hashcode = 3 ;\nlong long hashFuction(string s){\n\tint n = s.length();\n\tlong long hashed = 0;\n\tfor(int i=0;i<n;i++){\n\t\thashed *= hashcode;\n\t\thashed += s[i] - '0';\n\t}\n\treturn hashed;\n}\nmain(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\t\n\tint n;\n\tcin >> n;\n\t\n\tstring s;\n\tcin >> s;\n\t\n\tlong long maxMultiple = 1, currentHashed = hashFuction(s), target = currentHashed;\n\tfor(int i=0;i<n-1;i++)\n\t\tmaxMultiple *= hashcode;\n\tfor(int i=0;i<n;i++){\n\t\tcurrentHashed -= (s[i]-'0') * maxMultiple;\n\t\tcurrentHashed *= hashcode;\n\t\tcurrentHashed += s[i] - '0';\n\t\t\n\t\tif(currentHashed == target){\n\t\t\tint same = true;\n\t\t\tstring ss = s + s;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(ss[i+j+1] != s[j]){\n\t\t\t\t\tsame = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(same){\n\t\t\t\tcout << i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
        }
    },
    {
        "page_content": "**บล็อกเชน (BLOCKCHAIN)**\n\nบล็อกเชน (Blockchain) ในที่นี้คือต้นไม้ที่มีฉลาก (labeled tree) ซึ่งเป็นกราฟเชื่อมต่อที่ไม่มีวัฏจักรและแต่ละปม (node) มีหมายเลขกำกับที่ไม่ซ้ำกัน ต้นไม้ที่มีฉลากสองต้นจะถือว่าเป็นต้นไม้เดียวกันก็ต่อเมื่อมีเซตของปมและเซตของเส้นเชื่อมเหมือนกันทุกประการ\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อตรวจสอบว่า เมื่อให้ฐานข้อมูลบล็อกเชนมาทั้งหมด t บล็อกเชนและให้บล็อกเชนมาเพื่อตรวจสอบอีก q บล็อกเชน ให้ระบุว่าแต่ละบล็อกเชนที่ต้องการตรวจสอบนั้นปรากฏอยู่ในฐานข้อมูลเป็นจำนวนเท่าใด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม t (จำนวนบล็อกเชนในฐานข้อมูล, $1 \\le t \\le 1,000$) และ q (จำนวนบล็อกเชนที่ต้องการตรวจสอบ, $1 \\le q \\le 1,000$)\n2.  ข้อมูลของ t บล็อกเชนในฐานข้อมูล ตามด้วยข้อมูลของ q บล็อกเชนที่ต้องการตรวจสอบ โดยแต่ละบล็อกเชนมีข้อมูลดังนี้:\n    * บรรทัดแรกคือจำนวนเต็ม n แทนจำนวนปม ($1 \\le n \\le 2^{10}$)\n    * n-1 บรรทัดถัดมา แต่ละบรรทัดคือจำนวนเต็ม 2 จำนวนแทนเส้นเชื่อมแต่ละเส้น\n\n**ข้อมูลส่งออก**\n\nมี q บรรทัด แต่ละบรรทัดแสดงจำนวนที่บล็อกเชนที่ต้องการตรวจสอบปรากฏในฐานข้อมูล\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 2 | 0 |\n| 10 | 2 |\n| 1 2 | |\n| 6 4 | |\n| 2 5 | |\n| 3 5 | |\n| 8 6 | |\n| 2 7 | |\n| 5 8 | |\n| 8 9 | |\n| 4 10 | |\n| 6 | |\n| 1 4 | |\n| 2 4 | |\n| 4 3 | |\n| 5 4 | |\n| 5 6 | |\n| 10 | |\n| 1 2 | |\n| 2 7 | |\n| 2 5 | |\n| 3 5 | |\n| 8 6 | |\n| 4 6 | |\n| 5 8 | |\n| 8 9 | |\n| 4 10 | |\n| 6 | |\n| 1 4 | |\n| 2 4 | |\n| 4 3 | |\n| 5 4 | |\n| 1 6 | |\n| 10 | |\n| 1 2 | |\n| 2 7 | |\n| 2 5 | |\n| 3 5 | |\n| 8 6 | |\n| 4 6 | |\n| 5 8 | |\n| 8 9 | |\n| 4 10 | |",
        "metadata": {
            "problem_id": "toi14_blockchain",
            "problem_name": "toi14_blockchain",
            "source": "TOI",
            "tags": [
                "graph",
                "hashing"
            ],
            "solution_code": "#include<bits/stdc++.h> \nusing namespace std ;\nmap<vector<pair<int,int>> , int>mpp ;\nvector<pair<int,int>> blockchain(){\n    \n    int x , y , sz ; cin >> sz ;\n    vector<pair<int,int>>vec ;\n    for(int i = 0 ; i < sz - 1; i ++ ){\n        cin >> x >> y ;\n        vec.push_back({min(x , y) , max(x , y)});\n    }\n    sort(vec.begin(),vec.end());\n    return vec ;\n}\nint main (){\n    ios_base :: sync_with_stdio(0),cin.tie(0);\n    \n    int n , q ; cin >> n >> q ;\n    while(n -- )mpp[blockchain()]++ ;\n    while(q -- )cout << mpp[blockchain()] << '\\n';\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**โลจิสติกส์ (LOGISTICS)**\n\nบริษัทขนส่ง NBK ต้องการหาเส้นทางเดินทางจากเมืองต้นทางไปยังเมืองปลายทางโดยมีค่าใช้จ่ายด้านเชื้อเพลิงน้อยที่สุด\n**เงื่อนไข:**\n* รถขนส่งมีความจุเชื้อเพลิง F หน่วย และถังจะว่างเปล่าเมื่อเริ่มจากเมืองต้นทาง\n* การเติมเชื้อเพลิงทำได้เฉพาะที่เมืองต่างๆ เท่านั้น โดยแต่ละเมืองมีราคาเชื้อเพลิงต่างกัน\n* มีบัตรกำนัลเติมน้ำมันฟรี 1 ใบ ซึ่งใช้เติมเชื้อเพลิงเท่าไรก็ได้ ณ เมืองใดก็ได้ เพียงครั้งเดียว (อาจไม่ใช้ก็ได้)\n* เมื่อสิ้นสุดภารกิจที่เมืองปลายทาง รถขนส่งจะต้องเติมเชื้อเพลิงให้เต็มถัง\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาค่าใช้จ่ายที่น้อยที่สุดในการเติมเชื้อเพลิงสำหรับการเดินทางตามเงื่อนไข\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N แทนจำนวนเมือง ($4 \\le N \\le 100$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม N จำนวน ระบุราคาเชื้อเพลิงต่อหน่วยของแต่ละเมือง\n3.  **บรรทัดที่ 3** จำนวนเต็ม 3 จำนวน S, D, และ F (เมืองต้นทาง, เมืองปลายทาง, ความจุถังเชื้อเพลิง)\n4.  **บรรทัดที่ 4** จำนวนเต็ม M แทนจำนวนเส้นทางระหว่างเมือง\n5.  **M บรรทัดต่อมา** แต่ละบรรทัดระบุเมือง A, B และปริมาณเชื้อเพลิง W ที่ใช้ในการเดินทางระหว่างกัน\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็มเพื่อบอกค่าใช้จ่ายที่น้อยที่สุดในการเดินทาง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 360 |\n| 7 1 8 10 | |\n| 1 4 100 | |\n| 5 | |\n| 1 2 60 | |\n| 1 3 50 | |\n| 1 4 90 | |\n| 2 4 30 | |\n| 3 4 20 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 116 |\n| 10 1 3 10 30 | |\n| 1 4 20 | |\n| 4 | |\n| 1 2 1 | |\n| 1 5 5 | |\n| 4 5 20 | |\n| 3 4 2 | |",
        "metadata": {
            "problem_id": "toi14_logistics",
            "problem_name": "toi14_logistics",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra",
                "dynamic-programming"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct transport_vehicle {\n    int node , cost , fuel ;\n    bool ticket ; //ticket = 1 -> used\n\n    bool operator < (const transport_vehicle & rhs) const {\n        return rhs.cost < cost ;\n    }\n};\n\nstruct path {\n    int dest , w ;\n};\n\nint n , m , s , d , f , a , b , w ;\n\nint visited[101][101][2] ;\nint fuel_cost[101] ;\nvector<path>adj[101] ;\npriority_queue<transport_vehicle>pq ;\n\nint main(){\n\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n\n    for(int i = 0 ; i <= 100 ; i ++ ){\n        for(int j = 0 ; j <= 100 ; j ++ ){\n            for(int k = 0 ; k <= 1 ; k ++ ){\n                visited[i][j][k] = INT_MAX ;\n            }\n        }\n    }\n    cin >> n ;\n\n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> fuel_cost[i] ;\n    }\n\n    cin >> s >> d >> f ;\n\n    cin >> m ;\n\n    for(int i = 1 ; i <= m ; i ++ ){\n        cin >> a >> b >> w ;\n\n        adj[a].push_back({b , w});\n        adj[b].push_back({a , w});\n\n    }\n\n    visited[s][0][0] = 0 ;\n    pq.push({s , 0 , 0 , 0}) ;\n\n    while(!pq.empty()){\n\n        auto temp = pq.top() ;\n        pq.pop() ;\n\n        if(temp.node == d && temp.fuel == f){\n            cout << temp.cost ;\n            return 0 ;\n        }\n\n        if(temp.ticket == false && temp.cost < visited[temp.node][f][1]){\n            visited[temp.node][f][1] = temp.cost ;\n            pq.push({temp.node , temp.cost , f  , 1}) ;\n        }\n\n        for(int i = 1 ; temp.fuel + i <= f ; i ++ ){\n            if(temp.cost + i * fuel_cost[temp.node] < visited[temp.node][temp.fuel + i][temp.ticket]){\n                visited[temp.node][temp.fuel + i][temp.ticket] = temp.cost + i * fuel_cost[temp.node] ;\n                pq.push({temp.node , temp.cost + i * fuel_cost[temp.node], temp.fuel + i , temp.ticket}) ;\n            }\n        }\n\n        for(auto i : adj[temp.node]){\n            if(temp.fuel - i.w >= 0 && temp.cost < visited[i.dest][temp.fuel - i.w][temp.ticket]){\n                visited[i.dest][temp.fuel - i.w][temp.ticket] = temp.cost ;\n                pq.push({i.dest , temp.cost , temp.fuel - i.w , temp.ticket}) ;\n            }\n        }\n\n    }\n\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**สารคดีออนไลน์ (NBK48)**\n\nบริษัท NetNB ให้บริการรับชมสารคดีเรื่อง \"ตามติดชีวิต NBK48\" ซึ่งมี N ตอน โดยแต่ละตอนมีค่าบริการรับชม $p_i$ บาท (อาจเป็นค่าลบได้) ลูกค้าจะต้องรับชมเรียงตามลำดับตอนเสมอ โดยเริ่มจากตอนที่ 1, 2, 3, ...\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาจำนวนตอนของสารคดีที่มากที่สุดที่ลูกค้าแต่ละคนสามารถรับชมได้ภายใต้งบประมาณที่มีอยู่\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนตอน, $1 \\le N \\le 100,000$) และ Q (จำนวนลูกค้า, $1 \\le Q \\le 100,000$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม N จำนวน ระบุค่ารับชม $p_i$ ของแต่ละตอน ($-10,000 \\le p_i \\le 10,000$)\n3.  **Q บรรทัดต่อมา** แต่ละบรรทัดระบุจำนวนเงิน $q_j$ ของลูกค้าแต่ละคน\n\n**ข้อมูลส่งออก**\n\nมี Q บรรทัด แต่ละบรรทัดแสดงจำนวนตอนที่มากที่สุดที่ลูกค้าคนที่ j สามารถรับชมได้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 2 | 2 |\n| 10 20 15 30 60 | 4 |\n| 44 | |\n| 75 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 3 | 3 |\n| 10 20 -10 30 60 | 4 |\n| 31 | 0 |\n| 52 | |\n| 9 | |",
        "metadata": {
            "problem_id": "toi14_nbk48",
            "problem_name": "toi14_nbk48",
            "source": "TOI",
            "tags": [
                "array",
                "prefix-sum",
                "binary-search"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nint n , q ;\nlong long arr[100001];\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> n >> q ;\n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> arr[i] ;\n        arr[i] += arr[i - 1] ;\n    }\n    for(int i = n - 1 ; i >= 1 ; i -- ){\n        arr[i] = min(arr[i] , arr[i + 1]);\n    }\n    while(q -- ){\n        int l = 0 , r = n , k ; cin >> k ;\n        while(l < r){\n            int mid = (l + r + 1) >> 1 ;\n            if(arr[mid] <= k)l = mid ;\n            else r = mid - 1 ;\n        }\n        cout << l << '\\n' ;\n    }\n    \n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**สวนต้นไม้ (PLANTATION)**\n\nบริษัทจัดสวนต้องการออกแบบสวนโดยต้นไม้ทุกต้นมีรัศมีของพุ่มเป็นวงกลม R หน่วย และมีมาตรฐานว่า \"ระยะห่างระหว่างปลายกิ่ง\" ของต้นไม้สองต้นใดๆ จะต้องห่างกันไม่น้อยกว่า D หน่วย ซึ่งหมายความว่าระยะห่างระหว่าง \"จุดศูนย์กลาง\" ของต้นไม้สองต้นใดๆ จะต้องไม่น้อยกว่า $2R + D$ หน่วย\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อตรวจสอบว่าการออกแบบสวนต้นไม้แต่ละแปลงนั้นได้มาตรฐานหรือไม่\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม W ระบุจำนวนแปลงต้นไม้ที่ต้องการตรวจสอบ ($1 \\le W \\le 10$)\n2.  **W บรรทัดต่อมา** แต่ละบรรทัดคือข้อมูลของแปลงที่ i ซึ่งประกอบด้วย:\n    * $N_i$ (จำนวนต้นไม้, $2 \\le N_i \\le 100,000$)\n    * $R_i$ (รัศมีของพุ่ม, $1 \\le R_i \\le 1,000$)\n    * $D_i$ (ระยะห่างมาตรฐาน, $1 \\le D_i \\le 200$)\n    * ตามด้วยพิกัด $(X, Y)$ ของต้นไม้ $N_i$ ต้น\n\n**ข้อมูลส่งออก**\n\nมี W บรรทัด แสดงผลลัพธ์ของแต่ละแปลง โดยแสดง \"Y\" เมื่อแปลงนั้นเป็นไปตามมาตรฐาน และ \"N\" เมื่อไม่เป็นไปตามมาตรฐาน\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | Y |\n| 2 1 1 0 0 4 0 | N |\n| 2 1 1 0 0 2 0 | N |\n| 3 1 2 0 0 -2 2 2 1 | Y |\n| 3 1 2 0 0 4 1 -4 0 | N |\n| 3 1 2 0 0 3 1 -4 0 | |",
        "metadata": {
            "problem_id": "toi14_plantation",
            "problem_name": "toi14_plantation",
            "source": "TOI",
            "tags": [
                "array",
                "math",
                "geometry",
                "distance",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point {\n    int x , y ;\n};\nbool cmp_x(point a , point b){\n    return a.x < b.x ;\n}\nbool cmp_y(point a , point b){\n    return a.y < b.y ;\n}\npoint arr[100001];\npoint temp[100001];\nfloat dis(point a , point b){\n    return sqrt(pow( (a.x - b.x), 2) + pow( (a.y - b.y) ,2)) ;\n}\nfloat closest(int l , int r){\n    if(l == r)return INT_MAX ;\n    if(r - l == 1)return dis(arr[l] , arr[r]) ;\n    int mid = (l + r) >> 1 ;\n    float d = min(closest(l , mid) , closest(mid + 1 , r));\n    int cnt = 0;\n    for(int i = l ; i <= r ; i ++ ){\n        if(arr[i].x >= arr[mid].x - d && arr[i].x <= arr[mid].x + d){\n            temp[cnt ++ ] = arr[i] ;\n        }\n    }\n    sort(temp , temp + cnt , cmp_y) ;\n    for(int i = 0 ; i < cnt ; i ++ ){\n        for(int j = i + 1 ; j < cnt && temp[j].y - temp[i].y < d ; j ++){\n            d = min(d , dis(temp[i] , temp[j]));\n        }\n    }\n    return d ;\n}\nvoid solve(){\n    int N , R , D ;\n    cin >> N >> R >> D ;\n    for(int i = 0 ; i < N ; i ++){\n        cin >> arr[i].x >> arr[i].y ;\n    }\n    sort(arr , arr + N , cmp_x);\n    (closest(0 , N - 1) - (R << 1) >= D) ? cout << \"Y\\n\" : cout << \"N\\n\";\n    return ;\n}\nint main(){\n    //Solved By HexTex \n    ios_base::sync_with_stdio(0) , cin.tie(0);\n    int q ; cin >> q;\n    while(q -- )solve();\n\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ภาพถ่ายอวกาศแบบห้วงลึก (SPACE DEEP FIELD IMAGE)**\n\nในการถ่ายภาพอวกาศแบบห้วงลึก ภาพที่ได้จะเป็นภาพขาวดำขนาด $N \\times M$ จุดภาพ (pixel) โดยพื้นหลังเป็นสีดำ ('0') และวัตถุเป็นสีขาว ('1') วัตถุที่ปรากฏในภาพจะถูกจัดประเภทตามรูปทรงดังนี้:\n* **ดาวเคราะห์ (planet):** รูปสี่เหลี่ยมจัตุรัส\n* **ดาวฤกษ์ (fixed star):** รูปสี่เหลี่ยมข้าวหลามตัด\n* **ดาวหาง (comet):** รูปสามเหลี่ยมหน้าจั่ว (มี 4 ทิศทาง)\n\nภาพของวัตถุแต่ละชิ้นจะอยู่แยกจากกันโดยอิสระ ไม่สัมผัสหรือซ้อนทับกัน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพเพื่อนับจำนวนดาวเคราะห์, ดาวฤกษ์, และดาวหางที่ปรากฏในภาพ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็มสองจำนวน N (ความกว้าง) และ M (ความสูง) ของภาพ\n2.  **M บรรทัดต่อมา** แต่ละบรรทัดเป็นสายบิต (bit string) ความยาว N แสดงค่าจุดภาพของแต่ละแถว\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็ม 3 จำนวน คือ จำนวนดาวเคราะห์, ดาวฤกษ์, และดาวหางตามลำดับ คั่นด้วยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 20 12 | 1 0 2 |\n| 00000000000000000000 | |\n| 00100000001111111110 | |\n| 01110000000111111100 | |\n| 11111000000011111000 | |\n| 00000000000001110000 | |\n| 00000000000000100000 | |\n| 00000000000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |",
        "metadata": {
            "problem_id": "toi14_space_1",
            "problem_name": "toi14_space_1",
            "source": "TOI",
            "tags": [
                "string",
                "array",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, nu;\n\nbitset<2001> g[10001], visitt[10001];\n\nint row[] = {0, -1, 1, 0};\n\nint col[] = {1, 0, 0, -1};\n\nint counter, l, w;\n\nint xmax, xmin, ymax, ymin;\n\nint tri, sq, rhom;\n\nchar sth;\n\nqueue<pair<int, int>> q;\n\nint isValid(int x, int y){\n\n    if(x<1 || y<1 || x>m || y>n || !g[x][y] || visitt[x][y]) return 0;\n\n    return 1;\n\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    cin >> n >> m;\n\n    for(int i=1; i<=m; i++){\n\n        for(int j=1; j<=n; j++){\n\n            cin >> sth;\n\n            if(sth=='1') g[i][j]=true;\n\n            else g[i][j]=false;\n\n        }\n\n    }\n\n    for(int i=1; i<=m; i++){\n\n        for(int j=1; j<=n; j++){\n\n            if(!isValid(i, j)) continue;\n\n            q.push({i, j});\n\n            counter=0, xmax=i, xmin=i, ymax=j, ymin=j;\n\n            while(!q.empty()){\n\n                int x=q.front().first, y=q.front().second;\n\n                q.pop();\n\n                visitt[x][y]=true;\n\n                for(int d=0; d<4; d++){\n\n                    if(isValid(x+row[d], y+col[d])){\n\n                        visitt[x+row[d]][y+col[d]]=true;\n\n                        q.push({x+row[d], y+col[d]});\n\n                        counter++;\n\n                        xmin=min(xmin, x+row[d]);\n\n                        xmax=max(xmax, x+row[d]);\n\n                        ymin=min(ymin, y+col[d]);\n\n                        ymax=max(ymax, y+col[d]);\n\n                    }\n\n                }\n\n            }\n\n            if((xmax-xmin)==(ymax-ymin)){\n\n                if(g[xmin][ymax]) sq++;\n\n                else rhom++;\n\n            }\n\n            else tri++;\n\n        }\n\n    }\n\n    cout << sq << \" \" << rhom << \" \" << tri;\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**ภาพถ่ายอวกาศแบบห้วงลึก (SPACE DEEP FIELD IMAGE)**\n\nในการถ่ายภาพอวกาศแบบห้วงลึก ภาพที่ได้จะเป็นภาพขาวดำขนาด $N \\times M$ จุดภาพ (pixel) โดยพื้นหลังเป็นสีดำ ('0') และวัตถุเป็นสีขาว ('1') วัตถุที่ปรากฏในภาพจะถูกจัดประเภทตามรูปทรงดังนี้:\n* **ดาวเคราะห์ (planet):** รูปสี่เหลี่ยมจัตุรัส\n* **ดาวฤกษ์ (fixed star):** รูปสี่เหลี่ยมข้าวหลามตัด\n* **ดาวหาง (comet):** รูปสามเหลี่ยมหน้าจั่ว (มี 4 ทิศทาง)\n\nภาพของวัตถุแต่ละชิ้นจะอยู่แยกจากกันโดยอิสระ ไม่สัมผัสหรือซ้อนทับกัน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพเพื่อนับจำนวนดาวเคราะห์, ดาวฤกษ์, และดาวหางที่ปรากฏในภาพ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็มสองจำนวน N (ความกว้าง) และ M (ความสูง) ของภาพ\n2.  **M บรรทัดต่อมา** แต่ละบรรทัดเป็นสายบิต (bit string) ความยาว N แสดงค่าจุดภาพของแต่ละแถว\n\n**ข้อมูลส่งออก**\n\nแสดงจำนวนเต็ม 3 จำนวน คือ จำนวนดาวเคราะห์, ดาวฤกษ์, และดาวหางตามลำดับ คั่นด้วยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 20 12 | 1 0 2 |\n| 00000000000000000000 | |\n| 00100000001111111110 | |\n| 01110000000111111100 | |\n| 11111000000011111000 | |\n| 00000000000001110000 | |\n| 00000000000000100000 | |\n| 00000000000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |\n| 00011111000000000000 | |",
        "metadata": {
            "problem_id": "toi14_space_2",
            "problem_name": "toi14_space_2",
            "source": "TOI",
            "tags": [
                "string",
                "array",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m, nu;\n\nbitset<2001> g[10001], visitt[10001];\n\nint row[] = {0, -1, 1, 0};\n\nint col[] = {1, 0, 0, -1};\n\nint counter, l, w;\n\nint xmax, xmin, ymax, ymin;\n\nint tri, sq, rhom;\n\nchar sth;\n\nqueue<pair<int, int>> q;\n\nint isValid(int x, int y){\n\n    if(x<1 || y<1 || x>m || y>n || !g[x][y] || visitt[x][y]) return 0;\n\n    return 1;\n\n}\n\nint main(){\n\n    ios_base::sync_with_stdio(0), cin.tie(0);\n\n    cin >> n >> m;\n\n    for(int i=1; i<=m; i++){\n\n        for(int j=1; j<=n; j++){\n\n            cin >> sth;\n\n            if(sth=='1') g[i][j]=true;\n\n            else g[i][j]=false;\n\n        }\n\n    }\n\n    for(int i=1; i<=m; i++){\n\n        for(int j=1; j<=n; j++){\n\n            if(!isValid(i, j)) continue;\n\n            q.push({i, j});\n\n            counter=0, xmax=i, xmin=i, ymax=j, ymin=j;\n\n            while(!q.empty()){\n\n                int x=q.front().first, y=q.front().second;\n\n                q.pop();\n\n                visitt[x][y]=true;\n\n                for(int d=0; d<4; d++){\n\n                    if(isValid(x+row[d], y+col[d])){\n\n                        visitt[x+row[d]][y+col[d]]=true;\n\n                        q.push({x+row[d], y+col[d]});\n\n                        counter++;\n\n                        xmin=min(xmin, x+row[d]);\n\n                        xmax=max(xmax, x+row[d]);\n\n                        ymin=min(ymin, y+col[d]);\n\n                        ymax=max(ymax, y+col[d]);\n\n                    }\n\n                }\n\n            }\n\n            if((xmax-xmin)==(ymax-ymin)){\n\n                if(g[xmin][ymax]) sq++;\n\n                else rhom++;\n\n            }\n\n            else tri++;\n\n        }\n\n    }\n\n    cout << sq << \" \" << rhom << \" \" << tri;\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**พัฒนาเทคโนโลยี (TECHNOLOGY)**\n\nคุณต้องการสร้างเมืองในโลกเสมือน โดยต้องพัฒนาเทคโนโลยีทั้งหมด N ชนิด\n* เทคโนโลยีแต่ละชนิด `i` มี **ระดับเทคโนโลยี** `L_i` ($1 \\le L_i \\le K$)\n* การพัฒนาเทคโนโลยี `i` ต้องพัฒนา **เทคโนโลยีเงื่อนไขก่อนหน้า** $P_i$ ชนิดให้ครบก่อน\n* การพัฒนาแต่ละเทคโนโลยีใช้เวลา 1 หน่วย\n* เมืองจะถูกจัดว่าพัฒนาถึงระดับ M เมื่อสามารถพัฒนาเทคโนโลยีตั้งแต่ระดับ 1 ถึง M ได้ครบทั้งหมด\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อหาว่าเมืองจะสามารถถูกพัฒนาได้ถึงระดับใด ภายในเวลาที่กำหนด T หน่วย\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม 3 จำนวน N, K, T (จำนวนเทคโนโลยี, ระดับสูงสุดที่เป็นไปได้, เวลาที่กำหนด)\n2.  **N บรรทัดถัดมา** ข้อมูลของเทคโนโลยีหมายเลขที่ i:\n    * $L_i$ (ระดับของเทคโนโลยี)\n    * $P_i$ (จำนวนเทคโนโลยีที่ต้องพัฒนาก่อน)\n    * ตามด้วยหมายเลขของเทคโนโลยีเงื่อนไขก่อนหน้า $P_i$ ตัว\n\n**ข้อมูลส่งออก**\n\nระดับการพัฒนาสูงสุดของเมืองภายในเวลาที่กำหนด (หากไม่สามารถพัฒนาถึงระดับใดได้เลย ให้ตอบ -1)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 5 4 | 2 |\n| 1 0 | |\n| 5 1 1 | |\n| 2 1 2 | |\n| 4 2 3 5 | |\n| 3 1 6 | |\n| 2 1 1 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 2 3 | -1 |\n| 1 2 2 3 | |\n| 2 2 1 3 | |\n| 2 2 1 2 | |",
        "metadata": {
            "problem_id": "toi14_technology",
            "problem_name": "toi14_technology",
            "source": "TOI",
            "tags": [
                "graph",
                "bfs",
                "queue"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define umap unordered_map \n#define endll '\\n' \n#define ll long long \n#define vec vector\n#define emb emplace_back\n#define pii pair<int , int>\n#define mts multiset\n#define Debug 1\nusing namespace std;\nstruct point {\n\tint x , y ;\n};\nbool cmp_x(point a , point b){\n\treturn a.x < b.x ;\n}\nbool cmp_y(point a , point b){\n\treturn a.y < b.y ;\n}\npoint arr[100001];\npoint temp[100001];\nfloat dis(point a , point b){\n\treturn sqrt(pow( (a.x - b.x), 2) + pow( (a.y - b.y) ,2)) ;\n}\nfloat closest(int l , int r){\n\tif(l == r)return INT_MAX ;\n\tif(r - l == 1)return dis(arr[l] , arr[r]) ;\n\tint mid = (l + r) >> 1 ;\n\tfloat d = min(closest(l , mid) , closest(mid + 1 , r));\n\tint cnt = 0;\n\tfor(int i = l ; i <= r ; i ++ ){\n\t\tif(arr[i].x >= arr[mid].x - d && arr[i].x <= arr[mid].x + d){\n\t\t\ttemp[cnt ++ ] = arr[i] ;\n\t\t}\n\t}\n\tsort(temp , temp + cnt , cmp_y) ;\n\tfor(int i = 0 ; i < cnt ; i ++ ){\n\t\tfor(int j = i + 1 ; j < cnt && temp[j].y - temp[i].y < d ; j ++){\n\t\t\td = min(d , dis(temp[i] , temp[j]));\n\t\t}\n\t}\n\treturn d ;\n}\nvoid solve(){\n\tint N , R , D ;\n\tcin >> N >> R >> D ;\n\tfor(int i = 0 ; i < N ; i ++){\n\t\tcin >> arr[i].x >> arr[i].y ;\n\t}\n\tsort(arr , arr + N , cmp_x);\n\t(closest(0 , N - 1) - (R << 1) >= D) ? cout << \"Y\\n\" : cout << \"N\\n\";\n    return ;\n}\nint main(){\n    //Solved By HexTex \n    ios_base::sync_with_stdio(0) , cin.tie(0);\n\tint q ; cin >> q;\n    while(q -- )solve();\n    \n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**เกาทัณฑ์ประชันแม่น (Archery)**\n\nการแข่งขันยิงธนู ผู้เข้าแข่งขันต้องยิงลูกธนูให้ลอดผ่านรูบนกล่องกระดาษที่วางซ้อนกัน N แถว แต่ละแถวมีกล่องซ้อนกันอยู่ และมีเพียงกล่องเดียวในแต่ละแถวที่มีรู ผู้เข้าแข่งขันสามารถปรับระดับของกล่องที่มีรูได้โดยการหยิบกล่องด้านล่างสุดออกไปต่อข้างบนสุดในแถวเดียวกัน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อคำนวณหาจำนวนครั้งที่น้อยที่สุดในการย้ายกล่อง เพื่อทำให้รูของกล่องทุกแถวอยู่ในระดับความสูงเดียวกัน และทำให้ผู้เข้าแข่งขันสามารถยิงลูกธนูผ่านได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N คือจำนวนแถวของกล่อง ($1 \\le N \\le 500,000$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม N จำนวน ระบุจำนวนกล่อง $c_i$ ในแต่ละแถว\n3.  **บรรทัดที่ 3** จำนวนเต็ม N จำนวน ระบุตำแหน่ง $p_i$ ของกล่องที่มีรูในแต่ละแถว (นับจากล่าง)\n\n**ข้อมูลส่งออก**\n\nมี 1 บรรทัด เป็นจำนวนเต็ม 2 จำนวนคั่นด้วยช่องว่าง:\n1.  P: ตำแหน่งความสูงของกล่องที่มีรู (หากมีหลายคำตอบ ให้แสดงค่า P ที่น้อยที่สุด)\n2.  M: จำนวนครั้งที่น้อยที่สุดในการย้ายกล่องรวมทุกแถว\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 2 3 |\n| 4 6 5 | |\n| 3 2 4 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 1 4 |\n| 5 8 6 | |\n| 2 4 1 | |",
        "metadata": {
            "problem_id": "toi15_archery",
            "problem_name": "toi15_archery",
            "source": "TOI",
            "tags": [
                "math",
                "array",
                "sorting"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\nstruct path {\n    ll height , hole ;\n    bool operator <(const path & p2)const {\n        return hole < p2.hole ;\n    }\n};\nint main(){\n\n    ios_base :: sync_with_stdio(0),cin.tie(0);\n    int n ; cin >> n ;\n    path boxes[n + 1] ;\n    ll qs[n + 1];\n    memset(qs , 0 , sizeof(qs));\n    boxes[0] = {0,0};\n    ll MIN = LLONG_MAX ,  sum = 0 ;\n\n    for(int i = 1 ; i < n + 1; i ++ )\n    {\n        cin >> boxes[i].height ;\n        MIN = min(MIN , boxes[i].height);\n    }\n\n    for(int i = 1 ; i < n + 1; i ++ ){\n        cin >> boxes[i].hole ;\n        sum += boxes[i].hole ;\n    }\n\n    sort(boxes +1 , boxes + n + 1);\n    for(int i = 1 ;  i <= n ; i ++ ){\n        qs[i] += qs[i - 1] + boxes[i - 1].height ;\n    }\n\n    ll MINN = LLONG_MAX ;\n    ll ind  ;\n    for(int i = 0 ; i <= n ; i ++ ){\n        if(boxes[i].hole > MIN )break ;\n        if( sum - (boxes[i].hole * n) + qs[i] < MINN){\n            MINN = sum - (boxes[i].hole * n) + qs[i] ;\n            ind = boxes[i].hole ;\n        }\n    }\n    cout << ind << ' ' << MINN ;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**งบประมาณปรับปรุงเส้นทาง (Budget)**\n\nมหาวิทยาลัยบูรพามีอาคาร B อาคาร และเส้นทางเชื่อม E เส้นทาง บางเส้นทางมีหลังคาแล้ว มหาวิทยาลัยต้องการสร้างหลังคาเพิ่มเติมบนเส้นทางที่ยังไม่มี เพื่อให้นักศึกษาสามารถเดินทางระหว่างทุกอาคารได้โดยผ่านเฉพาะเส้นทางที่มีหลังคา\n\nมีบริษัทเอกชนเสนอแพ็คเกจสร้างหลังคา P แพ็คเกจ แต่ละแพ็คเกจมีระยะทางที่สร้างได้และราคาที่แตกต่างกัน ในการสร้างหลังคาสำหรับเส้นทางหนึ่ง จะต้องเลือกแพ็คเกจที่มีระยะทางไม่น้อยกว่าความยาวของเส้นทางนั้น และต้องจ่ายราคาเต็ม\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมคำนวณงบประมาณที่น้อยที่สุดที่สามารถสร้างหลังคาให้เชื่อมต่อกันได้ทุกอาคาร\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม B (จำนวนอาคาร, $2 \\le B \\le 3,000$) และ E (จำนวนเส้นทางเชื่อม, $B \\le E \\le 500,000$)\n2.  **E บรรทัดถัดไป** ข้อมูลเส้นทางเชื่อม: S, T (อาคารต้นทาง, ปลายทาง), L (ระยะทาง), และ R (สถานะหลังคา, 1=มี, 0=ไม่มี)\n3.  **บรรทัดที่ E+2** จำนวนเต็ม P แทนจำนวนแพ็คเกจ\n4.  **P บรรทัดถัดไป** ข้อมูลแพ็คเกจ: C (ระยะทาง) และ D (ราคา)\n\n**ข้อมูลส่งออก**\n\nงบประมาณที่น้อยที่สุดที่ต้องใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 8 | 295 |\n| 0 1 19 0 | |\n| 1 2 50 1 | |\n| 1 3 5 0 | |\n| 2 3 18 0 | |\n| 0 4 32 0 | |\n| 3 4 22 0 | |\n| 2 5 70 0 | |\n| 4 5 20 0 | |\n| 8 | |\n| 5 60 | |\n| 50 200 | |\n| 75 350 | |\n| 20 100 | |\n| 40 145 | |\n| 15 50 | |\n| 35 150 | |\n| 8 60 | |",
        "metadata": {
            "problem_id": "toi15_budget",
            "problem_name": "toi15_budget",
            "source": "TOI",
            "tags": [
                "graph",
                "union-find",
                "sorting"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define endll '\\n'\n#define vec vector\n#define umap unordered_map\n#define ll long long \nusing namespace std;\nstruct path {\n\tll height , hole ;\n\tbool operator <(const path & p2)const {\n\t\treturn hole < p2.hole ;\n\t}\n};\nint main(){\n\t\n\tios_base :: sync_with_stdio(0),cin.tie(0);\n\tint n ; cin >> n ;\n\tpath boxes[n + 1] ;\n\tll qs[n + 1];\n\tmemset(qs , 0 , sizeof(qs));\n\tboxes[0] = {0,0};\n\tll MIN = LLONG_MAX ,  sum = 0 ;\n\t\n\tfor(int i = 1 ; i < n + 1; i ++ )\n\t{\n\t\tcin >> boxes[i].height ;\n\t\tMIN = min(MIN , boxes[i].height);\n\t}\n\t\n\tfor(int i = 1 ; i < n + 1; i ++ ){\n\t\tcin >> boxes[i].hole ;\n\t\tsum += boxes[i].hole ;\n\t}\n\t\n\tsort(boxes +1 , boxes + n + 1);\n\tfor(int i = 1 ;  i <= n ; i ++ ){\n\t\tqs[i] += qs[i - 1] + boxes[i - 1].height ;\n\t}\n\t\n\tll MINN = LLONG_MAX ;\n\tll ind  ;\n\tfor(int i = 0 ; i <= n ; i ++ ){\n\t\tif(boxes[i].hole > MIN )break ;\n\t\tif( sum - (boxes[i].hole * n) + qs[i] < MINN){\n\t\t\tMINN = sum - (boxes[i].hole * n) + qs[i] ;\n\t\t\tind = boxes[i].hole ;\n\t\t}\n\t}\n\tcout << ind << ' ' << MINN ;\n\t\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**ถ้ำเสือศรีราชา (Cave)**\n\nทีม Avenger ต้องนำเสบียงไปให้นักผจญภัยที่ติดอยู่ในถ้ำซึ่งมี N โถง และ E ทางเชื่อม การเดินทางจากโถง Q ไป R ใช้เวลา $T_{Q,R}$ แต่เมื่อมีน้ำหลากระดับ h การเดินทางผ่านทางเชื่อม (ที่ไม่ติดกับโถงปากทางเข้า P) จะใช้เวลาเพิ่มขึ้น h นาที\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อคำนวณระยะเวลาเดินทางที่น้อยที่สุดจากโถง P ไปยังโถง U สำหรับระดับน้ำที่แตกต่างกัน L ครั้ง\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N, P, U, E (จำนวนโถง, โถงปากทาง, โถงที่ติดอยู่, จำนวนทางเชื่อม)\n2.  **E บรรทัดถัดไป** ข้อมูลทางเชื่อม: Q, R, $T_{Q,R}$ (โถงต้นทาง, ปลายทาง, เวลาเดินทาง)\n3.  **บรรทัดที่ E+2** จำนวนเต็ม L (จำนวนครั้งที่จำลอง)\n4.  **บรรทัดที่ E+3** จำนวนเต็ม L จำนวน แทนระดับน้ำ $h_i$ ในแต่ละครั้ง\n\n**ข้อมูลส่งออก**\n\nจำนวนเต็ม L จำนวน คั่นด้วยช่องว่าง แทนระยะเวลาเดินทางที่น้อยที่สุดสำหรับแต่ละระดับน้ำ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 0 7 14 | 12 34 18 59 |\n| 0 1 10 | |\n| 0 3 14 | |\n| 0 4 8 | |\n| 1 2 2 | |\n| 2 7 2 | |\n| 2 3 4 | |\n| 3 7 15 | |\n| 3 4 9 | |\n| 5 3 7 | |\n| 5 7 2 | |\n| 4 5 5 | |\n| 4 6 1 | |\n| 6 5 1 | |\n| 6 4 3 | |\n| 4 | |\n| 0 10 2 30 | |",
        "metadata": {
            "problem_id": "toi15_cave",
            "problem_name": "toi15_cave",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra"
            ],
            "solution_code": "#include<bits/stdc++.h>\n#define endll '\\n'\n#define vec vector\n#define umap unordered_map\n#define ll long long \nusing namespace std;\nstruct path {\n\tll height , hole ;\n\tbool operator <(const path & p2)const {\n\t\treturn hole < p2.hole ;\n\t}\n};\nint main(){\n\t\n\tios_base :: sync_with_stdio(0),cin.tie(0);\n\tint n ; cin >> n ;\n\tpath boxes[n + 1] ;\n\tll qs[n + 1];\n\tmemset(qs , 0 , sizeof(qs));\n\tboxes[0] = {0,0};\n\tll MIN = LLONG_MAX ,  sum = 0 ;\n\t\n\tfor(int i = 1 ; i < n + 1; i ++ )\n\t{\n\t\tcin >> boxes[i].height ;\n\t\tMIN = min(MIN , boxes[i].height);\n\t}\n\t\n\tfor(int i = 1 ; i < n + 1; i ++ ){\n\t\tcin >> boxes[i].hole ;\n\t\tsum += boxes[i].hole ;\n\t}\n\t\n\tsort(boxes +1 , boxes + n + 1);\n\tfor(int i = 1 ;  i <= n ; i ++ ){\n\t\tqs[i] += qs[i - 1] + boxes[i - 1].height ;\n\t}\n\t\n\tll MINN = LLONG_MAX ;\n\tll ind  ;\n\tfor(int i = 0 ; i <= n ; i ++ ){\n\t\tif(boxes[i].hole > MIN )break ;\n\t\tif( sum - (boxes[i].hole * n) + qs[i] < MINN){\n\t\t\tMINN = sum - (boxes[i].hole * n) + qs[i] ;\n\t\t\tind = boxes[i].hole ;\n\t\t}\n\t}\n\tcout << ind << ' ' << MINN ;\n\t\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**ค่ายกลพิฆาตแมลงวัน (Fly)**\n\nฝูงแมลงวันต้องบินผ่านค่ายกลขนาดกว้าง C หน่วย ลึก R แถว เพื่อไปให้ถึงอาหาร\n* แมลงวันแต่ละตัวจะบินตรงขึ้นไปตามแนวคอลัมน์ของตน\n* ในแต่ละวินาที แมลงวันสามารถเลือกที่จะ \"อยู่กับที่\" หรือ \"บินขึ้น\" ไปยังแถวถัดไป 1 หน่วย\n* แต่ละแถวมีกับดัก 2 อัน (ซ้าย-ขวา) เคลื่อนที่ในแนวนอนด้วยความเร็ว 1 หน่วย/วินาที และจะกระดอนเมื่อชนกันหรือชนขอบ\n* แมลงวันจะตายถ้าอยู่ในตำแหน่งเดียวกับกับดัก\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมคำนวณหาเวลาที่ \"น้อยที่สุด\" ที่แมลงวันตัวใดตัวหนึ่งสามารถบินผ่านค่ายกลไปได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม R (แถว, $1 \\le R \\le 2,000$) และ C (คอลัมน์, $1 \\le C \\le 2,000$)\n2.  **R บรรทัดถัดไป** แต่ละบรรทัดมีข้อมูล 4 ค่า สำหรับกับดักในแต่ละแถว:\n    * ตำแหน่งเริ่มต้นของกับดักซ้าย\n    * ทิศทางเริ่มต้นของกับดักซ้าย ('L' หรือ 'R')\n    * ตำแหน่งเริ่มต้นของกับดักขวา\n    * ทิศทางเริ่มต้นของกับดักขวา\n\n**ข้อมูลส่งออก**\n\nเวลาที่น้อยที่สุดที่แมลงวันสามารถบินผ่านค่ายกลได้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 7 | 9 |\n| 4 R 4 L | |\n| 1 L 6 R | |\n| 1 R 7 R | |\n| 2 R 7 R | |\n| 1 R 3 R | |",
        "metadata": {
            "problem_id": "toi15_fly",
            "problem_name": "toi15_fly",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\n#define st first\n\n#define nd second\n\nusing namespace std;\n\nint ea[2005][2];\n\npair<int,int>  inv[2][150],avi[20][20][50],temp[150];\n\nint a[30][30],sz[2],mi=1e9;\n\nchar s[2];\n\nint main()\n\n{\n\n    int  row,col,val,x,y,z,exact[2];\n\n    scanf(\"%d%d\",&row,&col);\n\n    int  bi,le,ri,itr,itr2,mod=2*col,n;\n\n    for(int i=1; i<=row; i++)\n\n    {\n\n        for(int j=0; j<2; j++)\n\n        {\n\n            scanf(\"%d%s\",&val,s);\n\n            if(s[0]=='R')\n\n                ea[i][j]=val;\n\n            else\n\n                ea[i][j]=2*col-val;\n\n        }\n\n    }\n\n \n\n    for(int i=1; i<col; i++)\n\n    {\n\n        inv[0][0]= {0,2*col};\n\n        sz[0]=1;\n\n        bi=1;\n\n        for(int j=1; j<=row; j++)\n\n        {\n\n            le=inv[1-bi][0].st+1;\n\n            //consider each slider\n\n            for(int k=0; k<2; k++)\n\n            {\n\n                val=(ea[j][k]+le)%mod;\n\n                x=(i-val)%mod;\n\n                if(x<0)\n\n                    x+=mod;\n\n                y=(mod-val-i)%mod;\n\n                if(y<0)\n\n                    y+=mod;\n\n                itr=0,itr2=0;\n\n                if(x<y)\n\n                {\n\n                    /* less*/if(x>0) avi[k][0][itr++]= {le,le+x-1};\n\n                    avi[k][1][0]= {le+x+1,le+y-1};\n\n                    /* less*/if(y!=2*col-1) avi[k][0][itr++]= {le+y+1,le+2*col-1};\n\n                    a[k][0]=itr;\n\n                    a[k][1]=1;\n\n                }\n\n                else\n\n                {\n\n                    if(y>0) avi[k][1][itr++]= {le,le+y-1};\n\n                    /* less*/avi[k][0][0]= {le+y+1,le+x-1};\n\n                    if(x!=2*col-1||y!=0)avi[k][1][itr++]= {le+x+1,le+2*col-1};\n\n                    a[k][0]=1;\n\n                    a[k][1]=itr;\n\n                }\n\n \n\n            }\n\n            itr=0;\n\n            //intersect 2 slider\n\n            for(int k=0; k<2; k++)\n\n            {\n\n                for(int l=0; l<a[0][k]; l++)\n\n                {\n\n                    for(int m=0; m<a[1][1-k]; m++)\n\n                    {\n\n                        x=max(avi[0][k][l].st,avi[1][1-k][m].st);\n\n                        y=min(avi[0][k][l].nd,avi[1][1-k][m].nd);\n\n                        if(x<=y)\n\n                            temp[itr++]= {x,y};\n\n                    }\n\n                }\n\n            }\n\n            sort(temp,temp+itr);\n\n            n=unique(temp,temp+itr)-temp;\n\n            //combine with previous\n\n            itr=0,itr2=0;\n\n            for(int k=0; k<n; k++)\n\n            {\n\n                while(itr<sz[1-bi]&&inv[1-bi][itr].nd<temp[k].st-1)\n\n                    itr++;\n\n                if(itr>=sz[1-bi])\n\n                    break;\n\n                if(inv[1-bi][itr].st>=temp[k].nd)\n\n                    continue;\n\n                inv[bi][itr2++]= {max(inv[1-bi][itr].st+1,temp[k].st),temp[k].nd};\n\n            }\n\n            if(itr2<=0)\n\n                break;\n\n            sz[bi]=itr2;\n\n            bi=1-bi;\n\n        }\n\n        //at column loop\n\n        if(itr2>0)\n\n        {\n\n            mi=min(inv[1-bi][0].st+1,mi);\n\n        }\n\n    }\n\n    printf(\"%d\",mi);\n\n \n\n \n\n}"
        }
    },
    {
        "page_content": "**เหรียญโอลิมปิก (Medal)**\n\nในพิธีมอบเหรียญโอลิมปิก มีนักพัฒนาโปรแกรม n คน และแท่นรับเหรียญ n แท่น นักพัฒนาโปรแกรมคนที่ i มีความสูง $t_i$ และแท่นตำแหน่งที่ j มีความสูง $h_j$\n\n**เป้าหมาย:**\nต้องจัดให้นักพัฒนาโปรแกรมแต่ละคนขึ้นบนแท่นแต่ละแท่น (หนึ่งคนต่อหนึ่งแท่น) แล้วนำมายืนเรียงกันเป็นแถวหน้ากระดาน เพื่อให้ \"ระยะทางการขยับแขนรวมของประธาน\" ที่ต้องคล้องเหรียญให้แต่ละคนตามลำดับนั้น \"น้อยที่สุด\"\n\nระยะทางการขยับแขนคือผลรวมของค่าสัมบูรณ์ของผลต่างของความสูงรวม (ความสูงคน + ความสูงแท่น) ของคนที่อยู่ติดกัน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมคำนวณหาระยะทางรวมที่น้อยที่สุดที่ประธานต้องขยับแขน\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม n (จำนวนนักพัฒนาโปรแกรม, $1 \\le n \\le 500,000$)\n2.  **บรรทัดที่ 2** ความสูงของนักพัฒนาโปรแกรม n คน\n3.  **บรรทัดที่ 3** ความสูงของแท่น n แท่น\n\n**ข้อมูลส่งออก**\n\nระยะทางรวมที่น้อยที่สุดที่ประธานขยับแขน\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 18 |\n| 158 168 139 | |\n| 132 104 140 | |",
        "metadata": {
            "problem_id": "toi15_medal",
            "problem_name": "toi15_medal",
            "source": "TOI",
            "tags": [
                "sorting",
                "array"
            ],
            "solution_code": "#include<bits/stdc++.h> \nusing namespace std ;\nint a[500001];\nint b[500001];\nbool cmp(int a, int b){\n    return a > b ;\n}\nint main(){\n    int n ; cin >> n ;\n    int MAX  = INT_MIN ;\n    int MIN  = INT_MAX ;\n    for(int i = 0 ; i < n ; i ++ ){\n        cin >> a[i] ;\n    }\n    for(int i = 0 ; i < n ; i ++ ){\n        cin >> b[i] ;\n    }\n    sort(a , a + n);\n    sort(b , b + n , cmp);\n    for(int i = 0 ; i < n ; i ++ ){\n        int now = a[i] + b[i] ;\n        MAX = max(MAX , now) ;\n        MIN = min(MIN , now) ;\n    }\n    cout << MAX - MIN ;\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ทันเนอะ (Minimum Load Requirement)**\n\nคณะวิทยาการสารสนเทศ ม.บูรพา มีลิฟต์ N ตัว และมีนักเรียน M คนที่ต้องขึ้นลิฟต์ไปยังห้องแข่งขัน โดยมีพี่เลี้ยง N คนคอยดูแล\n* ลิฟต์แต่ละตัวรองรับน้ำหนักได้ไม่เท่ากัน\n* พี่เลี้ยงแต่ละคนมีน้ำหนักไม่เท่ากัน\n* นักเรียน M คนจะถูกแบ่งเป็น N แถวย่อยตามลำดับเดิม\n* แต่ละแถวย่อย จะถูกจับคู่กับพี่เลี้ยง 1 คน และลิฟต์ 1 ตัว เพื่อโดยสารขึ้นไป\n* การเดินทางอาจต้องใช้ลิฟต์หลายรอบ และแต่ละรอบต้องรับน้ำหนักรวมไม่เกินพิกัด\n\n**งานของคุณ**\n\nจะมีการจำลองสถานการณ์ X ครั้ง ในแต่ละครั้งจะกำหนด \"การแบ่งกลุ่มนักเรียน\" และ \"เวลาสูงสุด T\" ที่อนุญาตให้ใช้ จงตรวจสอบว่าในแต่ละสถานการณ์นั้น \"เป็นไปได้\" (P) หรือ \"เป็นไปไม่ได้\" (F) ที่จะจัดสรรพี่เลี้ยงและลิฟต์ให้กับแต่ละกลุ่ม เพื่อให้นักเรียนทั้งหมดขึ้นลิฟต์เสร็จภายในเวลา T นาที\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** N, M, X (จำนวนลิฟต์, นักเรียน, สถานการณ์)\n2.  **บรรทัดที่ 2** น้ำหนักที่ลิฟต์แต่ละตัวรองรับได้\n3.  **บรรทัดที่ 3** น้ำหนักของพี่เลี้ยงแต่ละคน\n4.  **บรรทัดที่ 4** น้ำหนักของนักเรียนแต่ละคน\n5.  **บรรทัดที่ 5** เวลาสูงสุด T สำหรับแต่ละสถานการณ์\n6.  **X บรรทัดถัดมา** การแบ่งกลุ่มนักเรียนสำหรับแต่ละสถานการณ์\n\n**ข้อมูลส่งออก**\n\nมี X บรรทัด แต่ละบรรทัดแสดง 'P' (ผ่าน) หรือ 'F' (ไม่ผ่าน)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 10 3 | P |\n| 230 300 | P |\n| 56 65 | F |\n| 160 120 35 80 42 87 72 45 55 63 | |\n| 2 2 1 | |\n| 1 4 | |\n| 1 3 | |\n| 1 6 | |",
        "metadata": {
            "problem_id": "toi15_minreq",
            "problem_name": "toi15_minreq",
            "source": "TOI",
            "tags": [
                "sorting",
                "greedy",
                "array"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\n\nconst int M = 1e7+10;\n\nint n,m,q,a,t[15],bro[15],stu[M],mxti[15];\n\nvector<int> sum;\n\n\nint main() { \n\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    cin >> n >> m >> q;\n\n    for (int i = 1; i <= n; i++) cin >> t[i];\n\n    for (int i = 1; i <= n; i++) cin >> bro[i];\n\n    for (int i = 1; i <= m; i++) {cin >> stu[i]; stu[i] += stu[i-1];}\n\n    for (int i = 1; i <= q; i++) cin >> mxti[i];\n\n    sort(t+1,t+1+n);\n\n    for (int i = 1; i <= q; i++) {\n\n        sum.clear();\n\n        bool ch = false;\n\n        int old = 0;\n\n        for (int j = 1; j <= n; j++) {\n\n            cin >> a;\n\n            if (old == 0) {old = a; continue;}\n\n            sum.push_back(stu[a-1]-stu[old-1]);\n\n            old = a;\n\n        }\n\n        sum.push_back(stu[m]-stu[old-1]);\n\n        sort(sum.begin(),sum.end());\n\n        do {\n\n            ch = true;\n\n            for (int j = 1; j <= n; j++) {\n\n                int w = t[j]-bro[j];\n\n                int ti = sum[j-1]/w;\n\n                if (sum[j-1]%w) ti++;\n\n                //cout << ti << \" \" << mxti[i] << \"\\n\";\n\n                if (ti > mxti[i]) {\n\n                    ch = false;\n\n                    break;\n\n                }\n\n            }\n\n            if (ch) break;\n\n        } while (next_permutation(bro+1,bro+1+n));\n\n        cout << ((ch) ? \"P\" : \"F\") << \"\\n\";\n\n    }\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**ร้านอาหารตามสั่ง (Carte)**\n\nร้านอาหารตามสั่งไดโนคาร์ทมีลูกค้าจำนวนมาก เพื่อเพิ่มประสิทธิภาพ แม่ครัวจะทำอาหารตามใบสั่งอาหารที่เสียบไว้ที่แท่งเหล็กโดยมีเงื่อนไขดังนี้:\n* แม่ครัวสามารถเลือกดึงใบสั่งอาหารใบไหนก็ได้ออกจากแท่งเสียบ\n* เมื่อดึงใบสั่งอาหารออกไป ใบที่เคยอยู่บนและล่างจะถือว่าอยู่ติดกัน\n* ถ้าใบสั่งที่อยู่ติดกันเป็นอาหารชนิดเดียวกัน แม่ครัวสามารถดึงออกมาพร้อมกันได้สูงสุดไม่เกิน K ใบ (ตามความจุของกระทะ)\n* การทำอาหารแต่ละ \"ชนิด\" ใช้เวลา 1 นาที ไม่ว่าจะทำกี่จานก็ตาม\n\nร้านไดโนคาร์ทมี R สาขา แต่ละสาขาเริ่มทำอาหารพร้อมกัน\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาว่า สาขาที่ใช้เวลาทำอาหาร \"มากที่สุด\" จะใช้เวลาทั้งหมดกี่นาที โดยแต่ละสาขาจะใช้วิธีที่ทำให้ตัวเองเสร็จเร็วที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม R (จำนวนสาขา, $1 \\le R \\le 30$) และ K (ความจุกระทะ, $1 \\le K \\le 30$)\n2.  **2R บรรทัดถัดมา** เป็นข้อมูลของแต่ละสาขา โดยสาขาละ 2 บรรทัด:\n    * บรรทัดแรกคือ $N_i$ (จำนวนใบสั่งอาหาร, $1 \\le N_i \\le 400$)\n    * บรรทัดที่สองคือรายการอาหาร $N_i$ รายการ เป็นหมายเลข ($1 \\le A_j \\le 10$)\n\n**ข้อมูลส่งออก**\n\nจำนวนนาทีที่น้อยที่สุดของสาขาที่ใช้เวลาทำอาหารมากที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 5 | 2 |\n| 8 | |\n| 5 5 5 5 5 5 5 5 | |\n| 5 | |\n| 5 5 5 2 2 | |\n| 4 | |\n| 2 2 2 2 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 12 | 3 |\n| 10 | |\n| 1 1 1 1 1 1 2 1 1 1 | |\n| 13 | |\n| 3 1 1 1 1 3 1 1 1 1 1 1 1 | |",
        "metadata": {
            "problem_id": "toi16_carte",
            "problem_name": "toi16_carte",
            "source": "TOI",
            "tags": [
                "array",
                "greedy"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define int long long\n\nconst int N = 400+9;\n\nconst int INF = 1e18;\n\n\nint k,n;\n\nint ans = 0;\n\nint v[N];\n\nint dp[N][N];\n\n\nvoid solve(){\n\n\tint cnt=0;\n\n\tcin >> n;for(int i=1;i<=n;i++)for(int j=1;j<=n;j++)dp[i][j]=INF;\n\n\tfor(int i=1;i<=n;i++)cin >> v[i],dp[i][i]=1;\n\n\tfor(int len=2;len<=n;len++){\n\n\t\tfor(int l=1;l+len-1<=n;l++){\n\n\t\t\tint r=l+len-1;\n\n\t\t\tfor(int k=l;k<r;k++){\n\n\t\t\t\tdp[l][r] = min(dp[l][r],dp[l][k]+dp[k+1][r]);//หยิบตัวที่ k ออก\n\n\t\t\t}\n\n\t\t\tif(v[l]==v[r])dp[l][r]--;\n\n\t\t}\n\n\t}\n\n\tans = max(ans,dp[1][n]);\n\n}\n\n\nint32_t main(){\n\n\tcin.tie(nullptr)->sync_with_stdio(false);\n\n\tint q;cin >> q >> k;\n\n\twhile(q--)solve();\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n\n}"
        }
    },
    {
        "page_content": "**เซลล์ไดโน (Dino Cell)**\n\nสายเซลล์ไดโนประกอบด้วยเซลล์ที่เชื่อมต่อกันในแนวเส้นตรงและมีหมายเลขกำกับตั้งแต่ 1 ถึง Z แต่ละเซลล์สามารถปล่อยพลังงานได้ 2 รูปแบบ ขึ้นอยู่กับค่าคงตัว K:\n* **พลังงานสร้างเสริม (+):** ถ้าตัวประกอบร่วมของเลขประจำเซลล์ i กับ K ไม่เป็น 1 (gcd(i, K) != 1)\n* **พลังงานทำลายล้าง (-):** ถ้าตัวประกอบร่วมของเลขประจำเซลล์ i กับ K เป็น 1 (gcd(i, K) == 1)\n\nพลังงานที่ได้จากการดึงพลังงานช่วงเซลล์ที่ i ถึง j คือ \"ผลต่างของจำนวนเซลล์ที่ปล่อยพลังงานสร้างเสริมและทำลายล้าง\" ในช่วงนั้น\n\nเราสามารถดึงพลังงานได้จาก N ตำแหน่งที่กำหนดให้เท่านั้น\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาพลังงานสูงสุดที่สามารถดึงได้จากระหว่างสองตำแหน่งใด ๆ ที่สามารถเข้าถึงได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม Z, K, และ N\n    * Z คือความยาวของสายเซลล์ไดโน ($5 \\le Z \\le 2,000,000,000$)\n    * K คือค่าคงตัว ($2 \\le K \\le 1,000,000$)\n    * N คือจำนวนตำแหน่งที่ดึงพลังงานได้ ($2 \\le N \\le 10^6$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม N จำนวน คือตำแหน่ง $A_1, ..., A_N$ ที่สามารถดึงพลังงานได้ (เรียงจากน้อยไปมาก)\n\n**ข้อมูลส่งออก**\n\nพลังงานสูงสุดที่สามารถดึงได้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 6 3 | 2 |\n| 5 7 10 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 11 6 5 | 5 |\n| 1 2 7 10 11 | |",
        "metadata": {
            "problem_id": "toi16_dinocell",
            "problem_name": "toi16_dinocell",
            "source": "TOI",
            "tags": [
                "math",
                "array",
                "sorting",
                "brute-force",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\n\nusing namespace std;\n\n\nint Z, K, N;\n\n\nbool coprimes[1000001];\n\nint prefix[1000001];\n\nint suffix[1000001];\n\n\nvector<int> get_prime_factor(int z) {\n\n    vector<int> ans;\n\n    bool notprime[z+1] = {false};\n\n    notprime[0] = true;\n\n    notprime[1] = true;\n\n    if (z % 2 == 0) {\n\n        ans.push_back(2);\n\n    }\n\n    for (int i = 3; i <= z; i += 2) {\n\n        if ((z % i == 0) && !notprime[i]) {\n\n            ans.push_back(i);\n\n            for (int j = i; j <= z; j += i) notprime[j] = true;\n\n        }\n\n    }\n\n    return ans;\n\n}\n\n\nint main1() {\n\n    vector<int> K_prime_facts;\n\n    K_prime_facts = get_prime_factor(K);\n\n    bool pos_neg[K+1] = {false}; // false - true +\n\n    for (int i : K_prime_facts) for (int j = i; j <= K; j += i) pos_neg[j] = true;\n\n    int charge_qc[K+1];\n\n    charge_qc[0] = 0;\n\n    for (int i = 1; i <= K; i++) {\n\n        if (pos_neg[i]) charge_qc[i] = charge_qc[i-1] + 1;\n\n        else charge_qc[i] = charge_qc[i-1] - 1;\n\n    }\n\n    int mnl = 2147483647, mxl = -2147483647, mnr = 2147483647, mxr = -2147483647;\n\n    for (int i = 0; i < N; i++) {\n\n        int A;\n\n        cin >> A;\n\n        int qc = A/K * charge_qc[K] + charge_qc[A%K];\n\n        //cout << qc << \"\\n\";\n\n        mnr = min(mnr, qc);\n\n        mxr = max(mxr, qc);\n\n        A--;\n\n        qc = A/K * charge_qc[K] + charge_qc[A%K];\n\n        mnl = min(mnl, qc);\n\n        mxl = max(mxl, qc);\n\n    }\n\n    cout << max(mxr - mnl, mxl - mnr);\n\n    return 0;\n\n}\n\n\nvector<int> get_prime_factor2(int z) {\n\n    vector<int> ans;\n\n    bool notprime[z+1] = {false};\n\n    notprime[0] = true;\n\n    notprime[1] = true;\n\n    if (z % 2 == 0) {\n\n        ans.push_back(2);\n\n        while (z % 2 == 0) z = z >> 1;\n\n    }\n\n    for (int i = 3; i <= z; i += 2) {\n\n        if ((z % i == 0) && !notprime[i]) {\n\n            ans.push_back(i);\n\n            while (z % i == 0) z /= i;\n\n            for (int j = i; j <= z; j += i) notprime[j] = true;\n\n        }\n\n    }\n\n    return ans;\n\n}\n\n\nint main() {\n\n    ios_base::sync_with_stdio(false);\n\n    cin.tie(NULL);\n\n    cin >> Z >> K >> N;\n\n    if (N <= 100) {\n\n        main1();\n\n        return 0;\n\n    }\n\n    vector<int> K_prime_facts;\n\n    K_prime_facts = get_prime_factor2(K);\n\n    bool pos_neg[K+1] = {false}; // false - true +\n\n    for (int i : K_prime_facts) for (int j = i; j <= K; j += i) pos_neg[j] = true;\n\n    int charge_qc[K+1];\n\n    charge_qc[0] = 0;\n\n    for (int i = 1; i <= K; i++) {\n\n        if (pos_neg[i]) charge_qc[i] = charge_qc[i-1] + 1;\n\n        else charge_qc[i] = charge_qc[i-1] - 1;\n\n    }\n\n    int mn = 2147483647, mx = -2147483647;\n\n    for (int i = 0; i < N; i++) {\n\n        int A;\n\n        cin >> A;\n\n        int qc = A/K * charge_qc[K] + charge_qc[A%K];\n\n        //cout << qc << \"\\n\";\n\n        mn = min(mn, qc);\n\n        mx = max(mx, qc);\n\n    }\n\n    cout << mx - mn + 1;\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**ไวรัสโรคระบาด (Outbreak)**\n\nท่านได้รับมอบหมายให้จำลองการแพร่ของไวรัสสายพันธุ์ใหม่ในเมืองขอนแก่นสมาร์ทไดโนซิตี้เป็นเวลา T ชั่วโมง\n**กฎการแพร่เชื้อ (เกิดขึ้นตามลำดับในทุก ๆ ชั่วโมง):**\n1.  **ลดสุขภาพ:** คะแนนสุขภาพ H ของผู้ติดเชื้อทุกคนลดลง 1\n2.  **กักตัว:** ผู้ติดเชื้อที่มี $H \\le Q$ จะถูกนำไปกักตัวและรักษา (ออกจากพื้นที่จำลอง)\n3.  **ติดเชื้อใหม่:** ผู้ปลอดเชื้อที่พิกัด (X,Y) จะติดเชื้อ ถ้า \"ผลรวมของระดับการแพร่เชื้อ\" จากเพื่อนบ้านที่ติดกัน (4 ทิศ) มีค่ามากกว่าหรือเท่ากับคะแนนสุขภาพ H ของตนเอง\n4.  **ความสามารถในการแพร่เชื้อ:** ผู้ติดเชื้อจะสามารถแพร่เชื้อได้เมื่อ $H \\le S$ โดยมี \"ระดับการแพร่เชื้อ\" เท่ากับ $F - H$ (F คือคะแนนสุขภาพสูงสุดที่เป็นไปได้)\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาว่าเมื่อเวลาผ่านไป T ชั่วโมง จะมีผู้ติดเชื้อที่เหลือในพื้นที่รวมกี่คน และมีผู้ที่ถูกนำไปกักตัวและรักษากี่คน\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** N (จำนวนประชากร) และ T (เวลาที่จำลอง)\n2.  **บรรทัดที่ 2** F, S, และ Q (คะแนนสุขภาพสูงสุด, เกณฑ์การแพร่เชื้อ, เกณฑ์การกักตัว)\n3.  **N บรรทัดถัดไป** ข้อมูลประชากรแต่ละคน: X, Y, H, V (พิกัด, คะแนนสุขภาพ, สถานะการติดเชื้อ (1=ติด, 0=ไม่ติด))\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดที่ 1** จำนวนผู้ติดเชื้อที่เหลืออยู่ในเมือง\n2.  **บรรทัดที่ 2** จำนวนผู้ที่ถูกส่งไปกักตัวและรักษา\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 5 | 1 |\n| 100 60 10 | 2 |\n| 0 0 61 1 | |\n| 1 0 12 0 | |\n| 2 0 10 0 | |\n| 3 0 10 0 | |\n| 4 0 30 0 | |",
        "metadata": {
            "problem_id": "toi16_outbreak",
            "problem_name": "toi16_outbreak",
            "source": "TOI",
            "tags": [
                "simulation",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\ntypedef tuple<int,int,int> t3;\n\ntypedef tuple<int,int,int,int> t4;\n\n\nconst int N=1e5+5;\n\n\nint dx[4]={-1,0,1,0};\n\nint dy[4]={0,-1,0,1};\n\n\nint n,T,f,s,q,all,qua;\n\nmap<pair<int,int>,t3> mp;\n\npriority_queue<t4,vector<t4>,greater<t4>> pq;\n\n\nvoid upd(int x,int y,int t){\n\n    auto it=mp.find({x,y});\n\n    if(it==mp.end())return;\n\n    auto &[hp,st,ti]=it->second;\n\n    if(st!=3)return;\n\n    int sum=0,cnt=0;\n\n    for(int i=0;i<4;i++){\n\n        int xx=x+dx[i];\n\n        int yy=y+dy[i];\n\n        auto it=mp.find({xx,yy});\n\n        if(it==mp.end())continue;\n\n        auto &[hp,st,ti]=it->second;\n\n        if(st==1){\n\n            cnt++;\n\n            sum+=f-hp-ti;\n\n        }\n\n    }\n\n    if(cnt){\n\n        ti=max(t,(int)ceil(1.0*(hp-sum)/cnt));\n\n        pq.emplace(ti,2,x,y);\n\n    }else{\n\n        ti=-1;\n\n    }\n\n}\n\n\nint main(){\n\n    cin.tie(nullptr)->sync_with_stdio(false);\n\n    cin >> n >> T >> f >> s >> q;\n\n    for(int i=1;i<=n;i++){\n\n        int x,y,h,v;\n\n        cin >> x >> y >> h >> v;\n\n        auto &[hp,st,ti]=mp[{x,y}];\n\n        hp=h;\n\n        st=3;\n\n        ti=-1;\n\n        if(v){\n\n            if(h>q){\n\n                ti=0;\n\n                pq.emplace(0,2,x,y);\n\n            }else{\n\n                st=0;\n\n                qua++;\n\n                all++;\n\n            }\n\n        }\n\n    }\n\n    while(!pq.empty()){\n\n        auto [t,d,x,y]=pq.top();\n\n        pq.pop();\n\n        if(t>T)break;\n\n        auto &[hp,st,ti]=mp[{x,y}];\n\n        if(st<=d||(d==2&&t!=ti))continue;\n\n        st=d;\n\n        if(d==2){\n\n            all++;\n\n            pq.emplace(t+max(1,hp-s),1,x,y);\n\n            pq.emplace(t+max(1,hp-q),0,x,y);\n\n        }else{\n\n            qua+=(d==0);\n\n            for(int i=0;i<4;i++)upd(x+dx[i],y+dy[i],t);\n\n        }\n\n    }\n\n    cout << all-qua << '\\n' << qua;\n\n}"
        }
    },
    {
        "page_content": "**หุ่นยนต์บรรจุสินค้า (PackBot)**\n\nหุ่นยนต์ไดโนบอทมีหน้าที่บรรจุสินค้าตามรหัสคำสั่งและคำนวณราคาสุทธิ\n* **สินค้า:** A-Z ทุกชนิดราคา 20 บาท\n* **รูปแบบการบรรจุ (เชื่อมสินค้าหรือห่อสินค้า 2 ชิ้น):**\n    1.  ใส่กล่อง (ลำดับความสำคัญต่ำสุด): ค่าบรรจุ 4% ของราคารวม\n    2.  ใส่ถุงกระดาษ (ลำดับความสำคัญปานกลาง): ค่าบรรจุ 8% ของราคารวม\n    3.  ใส่กล่องห่อของขวัญ (ลำดับความสำคัญสูงสุด): ค่าบรรจุ 16% ของราคารวม\n* **การคำนวณ:** ค่าบรรจุให้ปัดเศษทศนิยมทิ้ง\n* **ลำดับการทำงาน:** ทำตามลำดับความสำคัญของรูปแบบการบรรจุจากมากไปน้อย (3 -> 2 -> 1) ยกเว้นมีคำสั่งพิเศษในเครื่องหมาย `[]` ซึ่งต้องทำก่อน\n\n**งานของคุณ**\n\nเขียนโปรแกรมคำนวณยอดสุทธิของราคาที่ลูกค้าต้องจ่าย\n\n**ข้อมูลนำเข้า**\n\nเป็นสายอักขระรหัสคำสั่งการบรรจุสินค้า 1 บรรทัด (ยาวไม่เกิน 10,000 ตัวอักษร)\n\n**ข้อมูลส่งออก**\n\nยอดสุทธิของราคาที่ลูกค้าต้องจ่าย\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| A3C1[F1G3H]3D | 153 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| A3C1D2E | 92 |",
        "metadata": {
            "problem_id": "toi16_packbot",
            "problem_name": "toi16_packbot",
            "source": "TOI",
            "tags": [
                "string",
                "parsing",
                "math"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std ;\n\nint prio(char op){\n    if(op == '3')return 3 ;\n    if(op == '2')return 2 ;\n    if(op == '1')return 1 ;\n    return 0 ;\n}\nbool is_operator(char op){\n    if(op == '1' || op == '2' || op == '3' || op == '[' || op == ']')return true ;\n    return false ;\n}\nint cal(int a, int b , char op){\n    \n    if(op == '1')return (a + b) + (a + b) * 4 / 100 ;\n    if(op == '2')return (a + b) + (a + b) * 8 / 100 ;\n    if(op == '3')return (a + b) + (a + b) * 16 / 100 ;\n    return 0 ;\n}\nstack<int>st;\n\nint main(){\n\n    ios_base::sync_with_stdio(0) , cin.tie(0);\n\n    string expression , postfix ; cin >> expression ;\n    for(char i : expression){\n        if(!is_operator(i)){\n            postfix += i ;\n        }\n        else if(i == '[')st.push(i) ;\n        else if(i == ']'){\n            while(st.top() != '['){\n                postfix += st.top();\n                st.pop();\n            }\n            st.pop();\n        }\n        else {\n            while(!st.empty() && prio(i) <= prio(st.top())){\n                postfix += st.top();\n                st.pop();\n            }\n            st.push(i);\n        }\n    }\n    while(!st.empty()){\n        postfix += st.top();\n        st.pop();\n    }\n    for(char i : postfix){\n        if(!is_operator(i)){\n            st.push(20);\n        }\n        else {\n            int x , y ;\n            x = st.top() ; st.pop() ;\n            y = st.top() ; st.pop() ;\n            st.push(cal(x , y , i)) ;\n        }\n    }\n    cout << st.top();\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**รถรดน้ำต้นไม้พลังงานไดโน (Water Truck)**\n\nรถไดโนต้องเดินทางรดน้ำต้นไม้ตามแผนที่ซึ่งเป็นกราฟ โดยเริ่มจากจุดยอด [0] เดินทางให้ผ่าน \"ทุกเส้นเชื่อม\" และกลับมายังจุดยอด [0] เสมอ\n**เงื่อนไขแผนที่:**\n* แต่ละจุดยอดมีเส้นเชื่อมไม่เกิน 3 เส้น\n* ถ้ามี V จุดยอด และ E เส้นเชื่อม จะได้ว่า $-1 \\le (E-V) \\le 2$\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาว่ารถไดโนจะต้องใช้พลังงาน \"น้อยที่สุด\" กี่หน่วยเพื่อทำภารกิจให้สำเร็จ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม 2 จำนวน E (จำนวนเส้นเชื่อม) และ V (จำนวนจุดยอด)\n2.  **E บรรทัดต่อมา** ประกอบด้วยจำนวนเต็ม 3 จำนวนคือ $s_i, v_i, w_i$ แทนเส้นเชื่อมระหว่างจุดยอด $s_i$ กับ $v_i$ ที่ใช้พลังงาน $w_i$\n\n**ข้อมูลส่งออก**\n\nพลังงานน้อยที่สุดที่รถไดโนต้องใช้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 9 8 | 59 |\n| 0 3 1 | |\n| 3 5 2 | |\n| 5 4 4 | |\n| 4 2 3 | |\n| 2 1 4 | |\n| 1 5 6 | |\n| 3 6 7 | |\n| 6 7 5 | |\n| 6 8 6 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 6 | 57 |\n| 0 1 10 | |\n| 0 2 2 | |\n| 1 2 1 | |\n| 2 3 8 | |\n| 3 4 10 | |\n| 4 5 5 | |\n| 3 1 5 | |",
        "metadata": {
            "problem_id": "toi16_watertruck",
            "problem_name": "toi16_watertruck",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\n#define ll long long\n\n#define pii pair<int,int>\n\nusing namespace std;\n\nint n, m, sum = 0, cnt = 0;\n\nint keep[100001];\n\nvector<pair<int,int>> vec[100001];\n\nvector<int> odd;\n\nint dis[105][100001];\n\nint func( int temp )\n\n{\n\n    int pro[100001] = {};\n\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n\n    dis[temp][odd[temp]] = 0;\n\n    pq.push( {dis[temp][odd[temp]], odd[temp]} );\n\n    while( !pq.empty() )\n\n    {\n\n        int sec = pq.top().second;\n\n        pq.pop();\n\n        if( !pro[sec] )\n\n        {\n\n            pro[sec] = 1;\n\n            for( auto [x, y] : vec[sec] )\n\n            {\n\n                if( !pro[y] )\n\n                {\n\n                    dis[temp][y] = min( dis[temp][y], dis[temp][sec]+x );\n\n                    pq.push( {dis[temp][y], y} );\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n\nint main()\n\n{\n\n    ios_base::sync_with_stdio(0);cin.tie(0);\n\n    cin >> n >> m;\n\n    for( int i=0;i<n;i++ )\n\n    {\n\n        int u, v, w;\n\n        cin >> u >> v >> w;\n\n        keep[u]++;\n\n        keep[v]++;\n\n        sum += w;\n\n        vec[u].push_back( {w, v} );\n\n        vec[v].push_back( {w, u} );\n\n    }\n\n    for( int i=0;i<=m;i++ ) cnt += keep[i]%2;\n\n    if( cnt == 0 )\n\n    {\n\n        cout << sum;\n\n        return 0;\n\n    }\n\n    do\n\n    {\n\n        for( int i=0;i<=m;i++ )\n\n        {\n\n            if( keep[i] == 1 )\n\n            {\n\n                keep[i] = 0;\n\n                for( auto [f, s] : vec[i] )\n\n                {\n\n                    if( keep[s] > 0 )\n\n                    {\n\n                        keep[s]--;\n\n                        sum += f;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        cnt = 0;\n\n        for( int i=0;i<=m;i++ ) cnt += (keep[i] == 1);\n\n    }while( cnt > 0 );\n\n    cnt = 0;\n\n    for( int i=0;i<=m;i++ )\n\n    {\n\n        if( keep[i]%2 == 1 )\n\n        {\n\n            odd.push_back(i);\n\n            cnt++;\n\n        }\n\n    }\n\n    if( cnt == 0 )\n\n    {\n\n        cout << sum;\n\n        return 0;\n\n    }\n\n    for( int i=0;i<cnt;i++ ) for( int j=0;j<=m;j++ ) dis[i][j] = INT_MAX;\n\n    func( 0 );\n\n    if( cnt == 2 )\n\n    {\n\n        sum += dis[0][odd[1]];\n\n        cout << sum;\n\n        return 0;\n\n    }\n\n    func(1);\n\n    func(2);\n\n    sum += min( { dis[0][odd[1]]+dis[2][odd[3]], dis[0][odd[2]]+dis[1][odd[3]], dis[0][odd[3]]+dis[1][odd[2]] } );\n\n    cout << sum;\n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**วงล้อแห่งโชคชะตา (DinoWheel of Destiny)**\n\nอุปกรณ์ไดโนวีลประกอบด้วยวงล้อ N ชั้นซ้อนกัน แต่ละชั้นมีสายอักขระของสัญลักษณ์ (เลขโดด 0-9) ความยาวต่างกันได้ ไดโนวีลมี \"อักขระกำกับ\" T ซึ่งเป็นเลขโดดเช่นกัน\n\nการหมุน 1 คลิก จะทำให้วงล้อทุกชั้นหมุนทวนเข็มนาฬิกาไป 1 ตำแหน่งพร้อมกัน ไดโนวีลจะปลดปล่อยพลังงานได้เมื่อสัญลักษณ์ ณ ตำแหน่ง 12 นาฬิกาของ \"ทุกวงล้อ\" ตรงกับอักขระกำกับ T\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวนคลิกที่ \"น้อยที่สุด\" (แต่มากกว่า 0) ในการหมุนไดโนวีลเพื่อให้สามารถเปลี่ยนแปลงโชคชะตาได้อีกครั้ง\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนชั้นของวงล้อ, $3 \\le N \\le 9$) และ T (อักขระกำกับ)\n2.  **N บรรทัดถัดไป** แต่ละบรรทัดคือสายอักขระบนวงล้อแต่ละชั้น จากชั้นนอกสุดไปในสุด\n\n**ข้อมูลส่งออก**\n\nจำนวนคลิกที่น้อยที่สุดที่ต้องหมุน\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 7 | 9 |\n| 765416925789213 | |\n| 7598143287651097825694310681 | |\n| 72134529871278513269 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 7 | 15 |\n| 75483 | |\n| 713295734 | |\n| 721832395273541 | |",
        "metadata": {
            "problem_id": "toi16_wheel",
            "problem_name": "toi16_wheel",
            "source": "TOI",
            "tags": [
                "string",
                "implementation"
            ],
            "solution_code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define int long long\n\nconst int N = 9+2;\n\n\nint n,t,ans;\n\nstring s[N];\n\nint lcms[N];\n\n\nvoid solve(int cur,int idx){\n\n\tif(cur==n+1){\n\n\t\tans=min(ans,idx);\n\n\t\treturn ;\n\n\t}\n\n\tif(idx>ans)return;\n\n\tfor(int i=idx;i<=lcms[cur];i+=lcms[cur-1]){\n\n\t\tif(s[cur][i%s[cur].size()]-'0'==t)solve(cur+1,i);\n\n\t}\n\n}\n\n\nint32_t main(){\n\n\tcin.tie(nullptr)->sync_with_stdio(false);\n\n\tcin >> n >> t;lcms[0] = 1;\n\n\tfor(int i=1;i<=n;i++){\n\n\t\tcin >> s[i];\n\n\t\tint len = s[i].size();\n\n\t\tlcms[i] = lcms[i-1]*len/__gcd(len,lcms[i-1]);\n\n\t}\n\n\tans = lcms[n];solve(1,1);\n\n\tcout << ans << \"\\n\";\n\n\treturn 0;\n\n}"
        }
    },
    {
        "page_content": "**นครมาเก็ต (12.21)**\n\nในโปรโมชั่น \"ซื้อคู่ถูกกว่า\" ของนครมาเก็ต ลูกค้าสามารถซื้อสินค้าสองชิ้นในราคาพิเศษได้ ลูกค้าสองคน คุณ A และคุณ B ต้องการซื้อสินค้าที่แตกต่างกันคนละหนึ่งชิ้น ($P_{q,A}$ และ $P_{q,B}$) โดยในใบเสร็จเดียวกันจะต้องมีสินค้าสองชิ้นนี้อย่างละชิ้นเท่านั้น ส่วนสินค้าอื่นๆ ที่อาจซื้อมาพร้อมกันจะต้องมีจำนวนเป็นคู่ เพื่อให้สามารถแบ่งกันได้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อช่วยคุณ A และคุณ B หาวิธีการซื้อสินค้าตามเงื่อนไข โดยให้พิจารณารูปแบบการซื้อที่มี \"ราคารวมถูกที่สุด\" เป็นอันดับแรก หากมีหลายรูปแบบที่ราคาถูกที่สุดเท่ากัน ให้เลือกรูปแบบที่ได้ \"จำนวนสินค้ารวมมากที่สุด\"\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนสินค้าทั้งหมด), M (จำนวนรายการโปรโมชั่น), และ Q (จำนวนคำถาม)\n2.  **N บรรทัดถัดมา** ราคาของสินค้าแต่ละหมายเลข\n3.  **M บรรทัดถัดมา** รายการโปรโมชั่น \"ซื้อคู่ถูกกว่า\" แต่ละรายการประกอบด้วย หมายเลขสินค้า 2 ชนิด และราคาเมื่อซื้อคู่กัน\n4.  **Q บรรทัดถัดมา** แต่ละบรรทัดคือคำถาม ประกอบด้วยหมายเลขสินค้าที่คุณ A และคุณ B ต้องการ\n\n**ข้อมูลส่งออก**\n\nมี Q บรรทัด แต่ละบรรทัดแสดงผลลัพธ์ของแต่ละคำถาม ซึ่งประกอบด้วยจำนวนเต็ม 2 จำนวนคั่นด้วยช่องว่าง:\n1.  ราคารวมที่ถูกที่สุด\n2.  จำนวนสินค้ารวมที่มากที่สุดสำหรับราคานั้น\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 5 1 | 50 4 |\n| 35 | |\n| 50 | |\n| 32 | |\n| 25 | |\n| 1 4 50 | |\n| 2 4 20 | |\n| 2 3 60 | |\n| 4 3 30 | |\n| 1 2 80 | |\n| 3 2 | |",
        "metadata": {
            "problem_id": "toi17_1221",
            "problem_name": "toi17_1221",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "recursion",
                "brute-force",
                "array"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct item {\n    long long price , amount ;\n};\nitem dp[501][501] ;\nitem items[501];\nint n , m , q , x , y ;\nlong long w ;\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> n >> m >> q ;\n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> items[i].price ;\n        items[i].amount = 1 ;\n    }\n    for(int i = 1 ; i <= n ; i ++ ){\n        for(int j = 1 ; j <= n ; j ++ ){\n            dp[i][j].price = LLONG_MAX ;\n            dp[i][j].amount = 0 ;\n        }\n    }\n    for(int i = 1 ; i <= n ; i ++ ){\n        for(int j = 1 ; j <= n ; j ++ ){\n            dp[i][j].price = items[i].price + items[j].price ;\n            dp[i][j].amount = 2 ;\n        }\n    }\n    for(int i = 1 ; i <= m ; i ++ ){\n        cin >> x >> y >> w ;\n        dp[x][y].price = w ;\n        dp[x][y].amount = 2 ;\n        dp[y][x].price = w ;\n        dp[y][x].amount = 2 ;\n    }\n    for(int k = 1 ; k <= n ; k ++ ){\n        for(int i = 1 ; i <= n ; i ++ ){\n            for(int j = 1 ; j <= n ; j ++ ){\n                if(dp[i][k].price + dp[k][j].price < dp[i][j].price){\n                    dp[i][j].price = dp[i][k].price + dp[k][j].price ;\n                    dp[i][j].amount = dp[i][k].amount + dp[k][j].amount ;\n                }\n                else if(dp[i][k].price + dp[k][j].price == dp[i][j].price){\n                    dp[i][j].amount = max(dp[i][j].amount , dp[i][k].amount + dp[k][j].amount );\n                }\n            }\n        }\n    }\n    while(q -- ){\n        cin >> x >> y ;\n        cout << dp[x][y].price << ' ' << dp[x][y].amount << '\\n' ;\n    }\n    return 0;\n}"
        }
    },
    {
        "page_content": "**แผนที่ตัวกวนป่วนนครจักรวาลนฤมิต (The Marauder's Map of Metaverse City)**\n\nช่างแวร์ต้องสำรวจเส้นทางในนครจักรวาลนฤมิตซึ่งเป็นกริดขนาด M แถว N คอลัมน์ โดยต้องเดินทางจากจุดเริ่มต้น (1,1) ไปยังจุดสิ้นสุด (M,N)\n\n**การเดินทาง:**\n1.  **เดินปกติ:** เคลื่อนที่ไปยังจุดที่อยู่ติดกันใน 4 ทิศ (เหนือ, ใต้, ออก, ตก) ใช้ระยะทาง 1 หน่วย\n2.  **วาร์ป:** หากอยู่ที่จุดวาร์ปเข้า $W_k$ และมีบัตรผ่านเหลืออยู่ สามารถใช้บัตรผ่าน 1 ใบเพื่อวาร์ปไปยังจุดวาร์ปออก $O_k$ ได้ทันที (ระยะทางเป็น 0)\n\nช่างแวร์มีบัตรผ่านทั้งหมด P ใบ และมีคู่จุดวาร์ป K คู่\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาระยะทางการเดินทางที่สั้นที่สุดจากจุดเริ่มต้นไปยังจุดสิ้นสุด แต่ถ้าหากมีเส้นทางที่สั้นที่สุดหลายเส้นทาง ให้เลือกเส้นทางที่ใช้จำนวนบัตรผ่านน้อยที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม M และ N (ขนาดกริด, $10 \\le M, N \\le 1,000,000$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม K (จำนวนคู่จุดวาร์ป, $3 \\le K \\le 20,000$) และ P (จำนวนบัตรผ่าน, $1 \\le P \\le 17$)\n3.  **K บรรทัดถัดมา** แต่ละบรรทัดระบุพิกัดของจุดวาร์ป: $Wr_i, Wc_i, Or_i, Oc_i$\n\n**ข้อมูลส่งออก**\n\nมีบรรทัดเดียว เป็นจำนวนเต็ม 2 จำนวนคั่นด้วยช่องว่าง แทนระยะทางที่สั้นที่สุด และจำนวนบัตรผ่านที่ใช้น้อยที่สุดสำหรับระยะทางนั้น\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 15 | 9 2 |\n| 3 3 | |\n| 3 3 6 10 | |\n| 5 8 6 14 | |\n| 2 14 4 9 | |",
        "metadata": {
            "problem_id": "toi17_metaverse_1",
            "problem_name": "toi17_metaverse_1",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph",
                "dijkstra"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct node {\n\n    int w_r , w_c , o_r , o_c ; \n\n    node(){}\n\n    node (int a , int b , int c , int d) { \n        w_r = a , w_c = b , o_r = c , o_c = d ;\n    }\n\n};\n\nint dis(node j , node i){\n\n    return abs(j.o_r - i.w_r) + abs(j.o_c - i.w_c) ;\n\n}\n\nint dp[20][20001] , mindis , minticket , m , n , k , p ;\n\nnode node_list[20001] ;\nnode s , e ;\n\nvoid solve(){\n\n    for(int i = 1 ; i <= k ; i ++ ){\n\n        dp[1][i] = dis(s , node_list[i]) ;\n\n        if(dp[1][i] + dis(node_list[i] , e) < mindis){\n            mindis = dp[1][i] + dis(node_list[i] , e) ;\n            minticket = 1 ; \n        }\n\n    }\n\n    for(int t = 2 ; t <= p ; t ++ ){\n\n        for(int i = 1 ; i <= k ; i ++ ){\n\n            dp[t][i] = INT_MAX ;\n\n            for(int j = 1 ; j <= k ; j ++ ){\n                dp[t][i] = min(dp[t][i] , dp[t - 1][j] + dis(node_list[j] , node_list[i])) ;\n            }\n\n            if(dp[t][i] + dis(node_list[i] , e) < mindis){\n                mindis = dp[t][i] + dis(node_list[i] , e) ;\n                minticket = t ; \n            }\n        }\n        \n    }\n\n}\n\nint main(){\n\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n\n    cin >> m >> n >> k >> p ;\n\n    for(int i = 1 ; i <= k ; i ++ ){\n        \n        int w_r , w_c , o_r , o_c ;\n        \n        cin >> w_r >> w_c >> o_r >> o_c ;\n\n        node_list[i] = node(w_r , w_c , o_r , o_c) ;\n\n    }\n    \n    s = node(1 , 1 , 1 , 1) ;\n    e = node(m , n , m , n) ;\n\n    mindis = (m + n - 2) ;\n    minticket = 0 ;\n\n    solve() ;\n\n    cout << mindis << ' ' << minticket ;\n\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**แผนที่ตัวกวนป่วนนครจักรวาลนฤมิต (The Marauder's Map of Metaverse City)**\n\nช่างแวร์ต้องสำรวจเส้นทางในนครจักรวาลนฤมิตซึ่งเป็นกริดขนาด M แถว N คอลัมน์ โดยต้องเดินทางจากจุดเริ่มต้น (1,1) ไปยังจุดสิ้นสุด (M,N)\n\n**การเดินทาง:**\n1.  **เดินปกติ:** เคลื่อนที่ไปยังจุดที่อยู่ติดกันใน 4 ทิศ (เหนือ, ใต้, ออก, ตก) ใช้ระยะทาง 1 หน่วย\n2.  **วาร์ป:** หากอยู่ที่จุดวาร์ปเข้า $W_k$ และมีบัตรผ่านเหลืออยู่ สามารถใช้บัตรผ่าน 1 ใบเพื่อวาร์ปไปยังจุดวาร์ปออก $O_k$ ได้ทันที (ระยะทางเป็น 0)\n\nช่างแวร์มีบัตรผ่านทั้งหมด P ใบ และมีคู่จุดวาร์ป K คู่\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาระยะทางการเดินทางที่สั้นที่สุดจากจุดเริ่มต้นไปยังจุดสิ้นสุด แต่ถ้าหากมีเส้นทางที่สั้นที่สุดหลายเส้นทาง ให้เลือกเส้นทางที่ใช้จำนวนบัตรผ่านน้อยที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม M และ N (ขนาดกริด, $10 \\le M, N \\le 1,000,000$)\n2.  **บรรทัดที่ 2** จำนวนเต็ม K (จำนวนคู่จุดวาร์ป, $3 \\le K \\le 20,000$) และ P (จำนวนบัตรผ่าน, $1 \\le P \\le 17$)\n3.  **K บรรทัดถัดมา** แต่ละบรรทัดระบุพิกัดของจุดวาร์ป: $Wr_i, Wc_i, Or_i, Oc_i$\n\n**ข้อมูลส่งออก**\n\nมีบรรทัดเดียว เป็นจำนวนเต็ม 2 จำนวนคั่นด้วยช่องว่าง แทนระยะทางที่สั้นที่สุด และจำนวนบัตรผ่านที่ใช้น้อยที่สุดสำหรับระยะทางนั้น\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 15 | 9 2 |\n| 3 3 | |\n| 3 3 6 10 | |\n| 5 8 6 14 | |\n| 2 14 4 9 | |",
        "metadata": {
            "problem_id": "toi17_metaverse_2",
            "problem_name": "toi17_metaverse_2",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph",
                "dijkstra"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 2000000001 ;\n\nclass Segment {\n\n    vector<int>seg ;\n\n    public :\n\n        void init () {\n            seg = vector<int>(4 * 40001 , INF) ;\n        }\n\n        void update(int l , int r , int idx , int val , int node){\n            if(r < idx || l > idx) return ;\n            if(l == r){\n                seg[node] = min(seg[node], val) ;\n                return ;\n            }\n            int mid = (l + r) >> 1 ;\n            update(l , mid , idx , val , node * 2) ;\n            update(mid + 1 , r , idx , val , node * 2 + 1) ;\n            seg[node] = min(seg[node * 2] , seg[node * 2 + 1]) ;\n        }\n\n        int query(int ql , int qr , int l , int r , int node){\n            if(r < ql || l > qr)return INF ;\n            if(ql <= l && r <= qr)return seg[node] ;\n            int mid = (l + r) >> 1 ;\n            return min(query(ql , qr , l , mid ,node * 2) , query(ql , qr , mid + 1 , r , node * 2 + 1)) ;\n        }\n\n}Seg[2];\n\n//Seg[0] previous col < current col \n//Seg[1] previous col > current col \n\nstruct node {\n    int x , y , t ; // 0 --> in 1 --> out \n    \n    node(){}\n    \n    node(int X , int Y , int TYPE){\n        x = X ;\n        y = Y ;\n        t = TYPE ;\n    }\n\n    bool operator < (const node & rhs)const {\n        if(x != rhs.x)return x < rhs.x;\n        if(y != rhs.y)return y < rhs.y;\n        return t < rhs.t;\n    }\n    \n};\n\nmap<node , node>mpp ;\nmap<node , int>get_idx_out ;\nmap<node , int>get_idx_in ;\n\nnode node_list[40001] ;\nnode out[20001] ;\nnode in[20001] ;\n\nint m , n , k , p , sx , sy , dx , dy , dp[18][20001] , idx , size_col , compressed_index[40001] , ans_dis = INF , ans_ticket , lower_col , upper_col ; \nvector<int>col_list ;\n\nvoid init(){\n\n    for(int i = 0 ;  i <= 17 ; i ++ ){\n        for(int j = 1 ; j <= 20000 ; j ++ ){\n            dp[i][j] = INF;\n        }\n    }\n\n}\n\nvoid coordinate_compression(){\n\n    sort(col_list.begin(), col_list.end()) ;\n    col_list.erase( unique(col_list.begin() , col_list.end()) , col_list.end());\n    size_col = col_list.size();\n\n    for(int i = 1 ; i <= 2 * k ; i ++ ){\n        compressed_index[i] = lower_bound(col_list.begin() , col_list.end() , node_list[i].y ) - col_list.begin() + 1 ;\n    }\n}\n\nvoid setnode(){\n\n    int idx = 1 ; \n\n    for(int i = 1 ; i <= 2 * k ; i ++ ){\n        if(node_list[i].t == 0){\n            in[idx] = node_list[i] ;\n            out[idx] = mpp[node_list[i]] ;\n            get_idx_in[node_list[i]] = idx ;\n            get_idx_out[mpp[node_list[i]]] = idx ;\n            idx ++ ;\n        }\n    }\n\n}\n\nvoid setstate0 () {\n\n    for(int i = 1 ; i <= k ; i ++ ){\n        dp[0][i] = out[i].x + out[i].y - 2 ;\n    }\n\n}\n\nvoid setstate1 () {\n\n    for(int i = 1 ; i <= k ; i ++ ){\n        dp[1][i] = min(dp[0][i] , in[i].x + in[i].y - 2) ;\n        if(m + n - out[i].x - out[i].y + dp[1][i] < ans_dis){\n            ans_dis = m + n - out[i].x - out[i].y + dp[1][i];\n            ans_ticket = 1 ;\n        }\n    }\n\n}\n\nint main(){\n\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n\n    cin >> m >> n >> k >> p ;\n\n    for(int i = 1 ; i <= k ; i ++ ){\n\n        cin >> sx >> sy >> dx >> dy ;\n\n        node_list[i * 2 - 1] = node(sx , sy , 0) ;\n        node_list[i * 2] = node(dx , dy , 1) ;\n\n        mpp[{sx , sy , 0}] = node(dx , dy , 1) ;\n        mpp[{dx , dy , 1}] = node(sx , sy , 0) ;\n\n        col_list.push_back(sy) ;\n        col_list.push_back(dy) ;\n    }\n\n    ans_dis = m + n - 2 ;\n    ans_ticket = 0 ;\n\n    init() ;\n    sort(node_list + 1  , node_list + 2 * k + 1) ;\n    coordinate_compression() ;\n    setnode() ;\n    setstate0() ;\n    setstate1() ;\n\n    for(int ticket = 2 ; ticket <= p ; ticket ++){\n        \n        for(int i = 1 ; i <= k ; i ++ ){\n            dp[ticket][i] = dp[ticket - 1][i] ;\n        }\n\n        Seg[0].init() ;\n        Seg[1].init() ;\n\n        for(int i = 1 ; i <= 2 * k ; i ++ ){\n            \n            if(node_list[i].t == 0){\n\n                lower_col = Seg[0].query(1 , compressed_index[i] , 1 , size_col , 1 ) + node_list[i].x + node_list[i].y ;\n                upper_col = Seg[1].query(compressed_index[i] , size_col , 1 , size_col , 1 ) + node_list[i].x - node_list[i].y ;\n                dp[ticket][get_idx_out[mpp[node_list[i]]]] = min({dp[ticket][get_idx_out[mpp[node_list[i]]]] , lower_col , upper_col}) ;\n            }\n\n            if(node_list[i].t == 1){\n\n                Seg[0].update(1 , size_col , compressed_index[i] , \n                              dp[ticket - 1][get_idx_out[node_list[i]]] - node_list[i].x - node_list[i].y , 1) ;\n                Seg[1].update(1 , size_col , compressed_index[i] , \n                              dp[ticket - 1][get_idx_out[node_list[i]]] - node_list[i].x + node_list[i].y , 1) ;\n\n            }\n\n        }\n\n\n        Seg[0].init() ;\n        Seg[1].init() ;\n\n        for(int i = 2 * k ; i >= 1 ; i -- ){\n            \n            if(node_list[i].t == 0){\n\n                lower_col = Seg[0].query(1 , compressed_index[i] , 1 , size_col , 1 ) \n                            - node_list[i].x + node_list[i].y ;\n                upper_col = Seg[1].query(compressed_index[i] , size_col , 1 , size_col , 1 ) \n                            - node_list[i].x - node_list[i].y ;\n                dp[ticket][get_idx_out[mpp[node_list[i]]]] = min({dp[ticket][get_idx_out[mpp[node_list[i]]]] , \n                            lower_col , upper_col}) ;\n\n            }\n\n            if(node_list[i].t == 1){\n\n                Seg[0].update(1 , size_col , compressed_index[i] , \n                              dp[ticket - 1][get_idx_out[node_list[i]]] + node_list[i].x - node_list[i].y , 1) ;\n                Seg[1].update(1 , size_col , compressed_index[i] , \n                              dp[ticket - 1][get_idx_out[node_list[i]]] + node_list[i].x + node_list[i].y , 1) ;\n                \n            }\n\n        }\n        \n        for(int i = 1 ; i <= k ; i ++ ){\n\n            if( m + n - out[i].x - out[i].y + dp[ticket][i] < ans_dis){\n                ans_dis = m + n - out[i].x - out[i].y + dp[ticket][i] ;\n                ans_ticket = ticket ;\n            }\n        }\n\n    }\n\n    cout << ans_dis << ' ' << ans_ticket  ;\n\n    return 0 ;\n} "
        }
    },
    {
        "page_content": "**ขนมจีนนคร (Fermented Rice Noodle)**\n\nโรงงานผลิตเส้นขนมจีนมีช่องทางรับสินค้า N ช่องทาง และมีลูกค้าประจำ M ร้าน แต่ละร้านจะได้รับโควต้าให้เลือกรับขนมจีนจากช่องทางที่โรงงานจองไว้ให้ได้เพียง K ช่องทางเท่านั้น โดยช่องทางที่แต่ละร้านได้รับการจองจะเป็นช่วงหมายเลขเรียงติดกัน\n\n**เป้าหมาย:**\nโรงงานต้องการจัดสรรการจองช่องทาง (แบ่งช่องทาง N ช่องเป็น M ช่วง) เพื่อให้ร้านค้าที่ได้รับปริมาณเส้นขนมจีนรวม \"น้อยที่สุด\" นั้น ได้รับปริมาณ \"มากที่สุด\" เท่าที่จะเป็นไปได้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาปริมาณเส้นขนมจีนรวมของร้านที่ได้รับการจัดสรรน้อยที่สุด ในการจัดสรรที่เป็นธรรมที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** เป็นจำนวนเต็ม 3 จำนวน N, M, และ K\n2.  **N บรรทัดถัดมา** แต่ละบรรทัดมีจำนวนเต็ม $e_i$ แทนปริมาณเส้นขนมจีนของช่องทางที่ i\n\n**ข้อมูลส่งออก**\n\nแสดงปริมาณรวมของเส้นขนมจีนของร้านที่ได้รับการจัดสรรน้อยที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 12 3 3 | 21 |\n| 1 | |\n| 6 | |\n| 5 | |\n| 7 | |\n| 4 | |\n| 8 | |\n| 9 | |\n| 3 | |\n| 10 | |\n| 2 | |\n| 12 | |\n| 13 | |",
        "metadata": {
            "problem_id": "toi17_noodle",
            "problem_name": "toi17_noodle",
            "source": "TOI",
            "tags": [
                "array",
                "sorting",
                "greedy"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint n , m , k ;\npriority_queue<long long , vector<long long> , greater<long long>>pq;\nlong long arr[100001] ;\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> n >> m >> k ;\n    for(int i = 0 ; i < n ; i ++ )cin >> arr[i] ;\n    long long l = 0 , r = 5e10 ;\n    while(l < r){\n        \n        int target = 0 , cnt = 0 ; \n        long long mid = (l + r + 1) >> 1 , sum = 0 ;\n        while(!pq.empty())pq.pop() ;\n        for(int i = 0 ; i < n ; i ++ ){\n            \n            if(target == m)break ;\n            pq.push(arr[i]) ;\n            sum += arr[i] ;\n            cnt ++ ;\n            if(cnt > k){\n                sum -= pq.top() ;\n                pq.pop() ;\n                cnt -- ;\n            }\n            if(cnt == k){\n                if(sum >= mid){\n                    target ++ ;\n                    sum = 0 ;\n                    cnt = 0 ;\n                    while(!pq.empty())pq.pop() ;\n                }\n            }\n        }\n        if(target == m)l = mid ;\n        else r = mid - 1;\n    }\n    cout << l ;\n    \n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**กำแพงนคร: ภาคต่อ (The Wall: The Sequel)**\n\nเครื่องจักรตรวจคุณภาพอิฐ N ก้อนที่เรียงกัน โดยแต่ละก้อนมีคุณภาพ $A_i$ การตรวจสอบแต่ละครั้งจะกำหนดด้วยพารามิเตอร์ L, M, R ซึ่งหมายถึงให้เริ่มตรวจที่อิฐก้อนที่ L, จากนั้นข้ามไปตรวจทุกๆ M ก้อน ($L+M, L+2M, ...$) จนถึงตำแหน่งสุดท้ายที่ไม่เกิน R เครื่องจักรจะรายงานผลรวมของคุณภาพอิฐทุกก้อนที่ถูกตรวจ\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพเพื่อคำนวณผลรวมของคุณภาพอิฐสำหรับคำสั่งตรวจสอบ Q ครั้ง\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N และ Q (จำนวนอิฐ, จำนวนคำสั่ง, $1 \\le N, Q \\le 100,000$)\n2.  **บรรทัดที่ 2** คุณภาพของอิฐ $A_i$ จำนวน N ก้อน ($-5,000 \\le A_i \\le 5,000$)\n3.  **Q บรรทัดถัดมา** แต่ละบรรทัดคือคำสั่งตรวจสอบ L, M, R\n\n**ข้อมูลส่งออก**\n\nมี 1 บรรทัด ประกอบด้วยจำนวนเต็ม Q จำนวน คั่นด้วยช่องว่าง แสดงผลรวมของคุณภาพอิฐของแต่ละคำสั่ง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 11 2 | 18 14 |\n| 1 5 2 4 7 3 9 2 2 1 5 | |\n| 3 2 8 | |\n| 2 5 8 | |",
        "metadata": {
            "problem_id": "toi17_sequel",
            "problem_name": "toi17_sequel",
            "source": "TOI",
            "tags": [
                "array",
                "prefix-sum"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nconst int N = 100001 ;\nint cluster[320][N],arr[N] ;\nvoid preprocess(){\n    for(int i = 1 ; i <= sqrt(N) ; i ++ ){\n        for(int j = 1 ; j <= N ; j ++){\n            cluster[i][j] += cluster[i][max(0 , j - i)] + arr[j] ;\n        }\n    }\n}\nint main () {\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    \n    int n , q ; cin >> n >> q ; \n    \n    for(int i = 1 ; i <= n ; i ++ )cin >> arr[i] ;\n    \n    preprocess() ;\n    \n    while(q -- ){\n        int l , m , r ; cin >> l >> m >> r ;\n        if(m <= sqrt(n)){\n            r = l + (r - l) / m * m ;\n            cout << cluster[m][r] - cluster[m][l] + arr[l] << ' ' ;\n        }\n        else {\n            int sum = 0 ;\n            for(int i = l ; i <= r ; i += m){\n                sum += arr[i] ;\n            }\n            cout << sum << ' ';\n        }\n    }\n    \n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**นครสามแพร่ง (T-Junction City)**\n\nสามพี่น้อง แดง เขียว และฟ้า ได้รับเหมาสร้างถนน N เส้น เพื่อเชื่อมจุดต่อ (node) $N+1$ จุด ซึ่งโครงข่ายที่ได้จะเป็นต้นไม้ และทุกจุดต่อจะมีถนนเชื่อมไม่เกิน 3 เส้น ทั้งสามคนต้องแบ่งงานกันโดยแบ่งถนนทั้ง N เส้นออกเป็น 3 ส่วน และถนนในส่วนที่แต่ละคนรับผิดชอบจะต้องเชื่อมต่อกัน\n\n**เป้าหมาย:**\nต้องหาแผนการแบ่งงานที่ \"ยุติธรรมที่สุด\" ซึ่งหมายถึงแผนที่ทำให้ \"ระยะทางรวมที่น้อยที่สุด\" ในบรรดาสามพี่น้องนั้น \"มีค่าสูงที่สุด\" เท่าที่จะเป็นไปได้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาระยะทางรวมในการสร้างถนนของคนที่ได้รับส่วนแบ่งน้อยที่สุด ในแผนการแบ่งงานที่ยุติธรรมที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** ระบุจำนวนเต็ม N แทนจำนวนเส้นทาง ($5 \\le N \\le 80,000$)\n2.  **N บรรทัดถัดมา** ระบุข้อมูลของถนนแต่ละเส้น: $U_i, V_i, L_i$ (จุดต่อ 2 ฝั่ง และความยาว)\n\n**ข้อมูลส่งออก**\n\nแสดงระยะทางรวมของคนที่ถูกจัดสรรให้น้อยที่สุดของแผนที่ยุติธรรมที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 | 41 |\n| 0 1 9 | |\n| 1 2 8 | |\n| 3 2 11 | |\n| 4 3 50 | |\n| 4 5 1 | |\n| 6 3 13 | |\n| 7 6 12 | |\n| 8 6 32 | |",
        "metadata": {
            "problem_id": "toi17_tjunction",
            "problem_name": "toi17_tjunction",
            "source": "TOI",
            "tags": [
                "graph",
                "tree",
                "dynamic-programming"
            ],
            "solution_code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\nconst int N = 8e4 + 10;\nint n,a,b,cnt,st;\nll c,sum;\nvector<pair<int,ll>> adj[N];\nvector<int> q;\n\nvoid dfs(int u, int p){\n    for(auto [v,w]:adj[u]){\n        if(v==p)continue;\n        dfs(v,u);\n        q.push_back(w);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> n;\n    for(int i=0;i<n;i++){\n        cin >> a >> b >> c;\n        adj[a].push_back({b,c});\n        adj[b].push_back({a,c});\n        sum += c;\n    }\n\n    for(int i=0;i<n+1;i++)if(adj[i].size()==1){\n        dfs(i,i);\n        st = i;\n        break;\n    }\n\n    ll l = 0, r = sum, mid;\n    while(l<r){\n        mid = (l+r) >> 1;\n\n        ll cnt = 0, sum = 0;\n        for(int i=0;i<q.size(;i++)){\n            sum += q[i];\n            if(sum>=mid)cnt++,sum = 0;\n        }\n\n        if(cnt>=3)l = mid + 1;\n        else r = mid;\n    }\n    \n    cout << l-1;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**กำแพงนคร (The Wall)**\n\nในแผนที่เมืองขนาด R แถว C คอลัมน์ มีช่องว่าง ('.') และช่องที่มีบ้าน ('X') น้ำจะท่วมจากขอบแผนที่เข้ามาในช่องว่างที่เชื่อมถึงกันทั้งหมด\n**เงื่อนไขการสร้างกำแพง:**\n1.  กำแพงจะถูกสร้างบน \"ด้าน\" ของช่องที่อยู่ระหว่าง \"ช่องว่างที่น้ำท่วมถึง\" และ \"ช่องที่มีบ้าน\" เท่านั้น\n2.  บ้านทุกหลังที่มีด้านใดด้านหนึ่งเป็นกำแพง (เรียกว่า \"บ้านกำแพง\") จะต้องเชื่อมต่อกันทั้งหมด\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวน \"ด้าน\" ที่ถูกเลือกมาสร้างกำแพงที่ \"มากที่สุด\" ที่เป็นไปได้ภายใต้เงื่อนไขข้างต้น\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม R และ C (ขนาดแผนที่, $3 \\le R, C \\le 1,000$)\n2.  **R บรรทัดถัดมา** แต่ละบรรทัดเป็นสายอักขระความยาว C แสดงแผนที่เมือง (ขอบของแผนที่จะเป็นช่องว่างเสมอ)\n\n**ข้อมูลส่งออก**\n\nมี 1 บรรทัด แสดงจำนวนด้านที่มากที่สุดที่สามารถสร้างเป็นกำแพงได้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 6 | 8 |\n| ...... | |\n| .X.X.. | |\n| .X.XX. | |\n| ...... | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 6 | 22 |\n| ...... | |\n| .X.X.X | |\n| .X.X.. | |\n| .X..X. | |\n| .X..X. | |\n| .XXXX. | |\n| ...... | |",
        "metadata": {
            "problem_id": "toi17_wall",
            "problem_name": "toi17_wall",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nconst int N = 100001 ;\nint cluster[320][N],arr[N] ;\nvoid preprocess(){\n    for(int i = 1 ; i <= sqrt(N) ; i ++ ){\n        for(int j = 1 ; j <= N ; j ++){\n            cluster[i][j] += cluster[i][max(0 , j - i)] + arr[j] ;\n        }\n    }\n}\nint main () {\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    \n    int n , q ; cin >> n >> q ; \n    \n    for(int i = 1 ; i <= n ; i ++ )cin >> arr[i] ;\n    \n    preprocess() ;\n    \n    while(q -- ){\n        int l , m , r ; cin >> l >> m >> r ;\n        if(m <= sqrt(n)){\n            r = l + (r - l) / m * m ;\n            cout << cluster[m][r] - cluster[m][l] + arr[l] << ' ' ;\n        }\n        else {\n            int sum = 0 ;\n            for(int i = l ; i <= r ; i += m){\n                sum += arr[i] ;\n            }\n            cout << sum << ' ';\n        }\n    }\n    \n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ดารากร (Constellation)**\n\nในที่นี้จะแทนภาพบนท้องฟ้าด้วยตารางสองมิติขนาด R แถว C คอลัมน์ โดย “.” หมายถึงบริเวณที่ว่าง และ “#” หมายถึงดวงดาว การพิจารณาหา \"ดารากร\" ขนาด K หมายถึงการหากลุ่มดาวที่มีดาวอยู่ K ดวงพอดี\n\nเราสามารถพิจารณาให้ศูนย์กลางของดารากรอยู่ที่ช่องใดก็ได้ในตาราง จากนั้นดวงดาวที่ห่างจากศูนย์กลางเป็น \"ระยะทางแมนฮัตตัน\" เท่ากัน จะถือว่าอยู่ในดารากรเดียวกัน (ระยะทางแมนฮัตตันคือผลรวมของระยะทางในแนวตั้งและแนวนอน)\n\n**งานของคุณ**\n\nเมื่อกำหนดตารางแทนภาพบนท้องฟ้าและขนาด K ของดารากร จงเขียนโปรแกรมที่มีประสิทธิภาพเพื่อนับจำนวนดารากรทั้งหมดที่เป็นไปได้ และแสดงผลเป็นเศษที่เหลือจากการหารด้วย 1,000,003\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม 3 จำนวน R, C และ K (จำนวนแถว, คอลัมน์, และขนาดของดารากร)\n2.  **R บรรทัดถัดไป** แต่ละบรรทัดเป็นสายอักขระความยาว C แสดงภาพบนท้องฟ้า\n\n**ข้อมูลส่งออก**\n\nแสดงเศษที่เหลือจากการหารจำนวนดารากรทั้งหมดด้วย 1,000,003\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 2 2 | 8 |\n| #. | |\n| .# | |\n| #. | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 4 3 | 240 |\n| ..#. | |\n| #.#. | |\n| ..#. | |\n| #.#. | |\n| ..#. | |",
        "metadata": {
            "problem_id": "toi18_constellation",
            "problem_name": "toi18_constellation",
            "source": "TOI",
            "tags": [
                "math",
                "array",
                "brute-force",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nconst int mod = 1000003;\n\n\nint nCr[1205][1205];\n\nint a[1505][1505];\n\nint qsL[1505][1505],qsR[1505][1505];\n\n\n\nsigned main(){\n\n    ios_base::sync_with_stdio(false);\n\n    cin.tie(NULL);\n\n\n    int n,m,k;\n\n    cin >> n >> m >> k;\n\n\n    nCr[0][0]=1;\n\n    for(int i=1;i<=610;i++){\n\n        for(int j=0;j<=min(i,k);j++){\n\n            if(j==0||j==i)nCr[i][j]=1;\n\n            else{\n\n                nCr[i][j]=nCr[i-1][j]+nCr[i-1][j-1];\n\n                nCr[i][j]%=mod;\n\n            }\n\n        }\n\n    }\n\n\n    for(int i=601;i<=n+600;i++){\n\n        string x;\n\n        cin >> x;\n\n        int cnt=0;\n\n        for(int j=601;j<=m+600;j++){\n\n            if(x[cnt]=='#'){\n\n                a[i][j]=1;\n\n            }\n\n            cnt++;\n\n        }\n\n    }\n\n    for(int i=1;i<=n+1200;i++){\n\n        for(int j=1;j<=m+1200;j++){\n\n            if(a[i][j]){\n\n                qsL[i][j]+=1;\n\n                qsR[i][j]+=1;\n\n            }\n\n            qsL[i][j]+=qsL[i-1][j-1];\n\n            qsR[i][j]+=qsR[i-1][j+1];\n\n        }\n\n    }\n\n\n\n    int ans=0;\n\n    for(int sz=1;sz<=n+m;sz++){\n\n        for(int i=601;i<=n+600;i++){\n\n            for(int j=601;j<=m+600;j++){\n\n                \n\n                    int star=0;\n\n                    star += a[i-sz][j] + a[i][j+sz] + a[i][j-sz] + a[i+sz][j];    \n\n                    star += qsL[i-1][j+sz-1]-qsL[i-sz][j];\n\n                    star += qsR[i-1][j-sz+1]-qsR[i-sz][j];\n\n                    star += qsL[i+sz-1][j-1]-qsL[i][j-sz];\n\n                    star += qsR[i+sz-1][j+1]-qsR[i][j+sz];\n\n        \n\n                    ans += nCr[star][k];\n\n                    ans%=mod;\n\n                \n\n            }\n\n        }\n\n    }\n\n    cout << ans;\n\n    \n\n    return 0;\n\n}"
        }
    },
    {
        "page_content": "**สวนพฤกษศาสตร์ (Botanical Garden)**\n\nสวนพฤกษศาสตร์มีการจัดแสดงต้นไม้ N ต้นเรียงกัน โดยต้นไม้ตำแหน่งที่ i มีความสูง $A[i]$ ผู้ดูแลสวนต้องการจัดต้นไม้แบบใหม่โดยเลือกต้นไม้ที่ตำแหน่ง X มาเป็น \"ต้นไม้หลัก\" และอาจต้องนำต้นไม้อื่นบางต้นออกไป เพื่อให้เป็นไปตามเงื่อนไขดังนี้:\n1.  ต้นไม้หลักต้องเป็นต้นเดียวที่สูงที่สุดในการจัดเรียงใหม่\n2.  ต้นไม้ทางด้านซ้ายของต้นไม้หลัก ต้องเรียงลำดับความสูงจากซ้ายไปขวาแบบ \"เพิ่มขึ้นอย่างเดียว\" (strictly increasing)\n3.  ต้นไม้ทางด้านขวาของต้นไม้หลัก ต้องเรียงลำดับความสูงจากขวาไปซ้ายแบบ \"เพิ่มขึ้นอย่างเดียว\" (หรือมองจากซ้ายไปขวาเป็นแบบ \"ลดลงอย่างเดียว\")\n4.  จำนวนต้นไม้ที่เหลือทางด้านซ้ายและด้านขวาของต้นไม้หลัก ต้องมีจำนวนเท่ากัน (สมมติว่าเป็น k ต้น)\n\n**งานของคุณ**\n\nสำหรับแต่ละตำแหน่ง X ของต้นไม้หลักที่กำหนดมาในคำถาม จงหาค่า k ที่มากที่สุดที่เป็นไปได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนต้นไม้, $3 \\le N \\le 200,000$) และ Q (จำนวนคำถาม)\n2.  **บรรทัดที่ 2** ความสูงของต้นไม้ N ต้น\n3.  **บรรทัดที่ 3** ตำแหน่งของต้นไม้หลัก X สำหรับแต่ละคำถาม Q คำถาม\n\n**ข้อมูลส่งออก**\n\nมี Q บรรทัด แต่ละบรรทัดระบุค่า k ที่มากที่สุดสำหรับแต่ละค่า X ที่กำหนด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 4 | 0 |\n| 2 4 6 8 10 9 7 5 3 1 | 4 |\n| 9 4 0 3 | 0 |\n| | 3 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 16 3 | 4 |\n| 2 1 5 4 8 6 8 10 9 1 7 5 4 1 9 3 | 1 |\n| 7 14 1 | 0 |",
        "metadata": {
            "problem_id": "toi18_garden",
            "problem_name": "toi18_garden",
            "source": "TOI",
            "tags": [
                "array",
                "sorting",
                "two-pointers"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint cost[500001] , point[500001] , money , x ; \nint n , q , str , idx , l , r , mid ;\n\nint main(){\n\n    ios_base::sync_with_stdio(0) , cin.tie(0);\n\n    cin >> n >> q ;\n\n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> x ;\n        if(x < 0){\n            cost[i] = -x ;\n        }\n        else {\n            point[i] = x ;\n        }\n        cost[i] += cost[i - 1] ;\n        point[i] += point[i - 1] ;\n    }\n\n    while(q -- ){\n        cin >> str >> money;\n        idx = str + 1 ;\n        l = idx , r = n ;\n        while(l < r){\n            mid = (l + r + 1) >> 1 ;\n            if(cost[mid] - cost[idx - 1] < money)l = mid ;\n            else r = mid - 1 ;\n        }\n        cout << point[l] - point[idx - 1] << '\\n' ;\n    }\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**จั๊กกิ้ม (Gecko)**\n\nจั๊กกิ้ม K ตัวต้องการไต่ผนังที่มีซี่ผนัง N ซี่ เพื่อลงไปกินกำกุ้ง (แมงมุม) ที่อยู่ที่พื้นของซี่ผนังหมายเลข P\n* จั๊กกิ้มแต่ละตัวเริ่มต้นที่ส่วนบนสุดของซี่ผนังคนละซี่\n* บนผนังมีไม้ยึดขวาง M ชิ้นในแนวนอนเชื่อมระหว่างซี่ผนังที่ติดกันที่ระดับความสูงต่างๆ ไม้แต่ละชิ้นมี \"ระดับความแรงกลิ่น\"\n* **กฎการไต่:** จั๊กกิ้มจะไต่ลงมาตามซี่ผนังของตน ถ้าเจอไม้ยึดขวาง จะถูกบังคับให้ข้ามไปอีกฝั่ง แล้วไต่ลงต่อจากซี่ผนังใหม่ ทำเช่นนี้ไปเรื่อยๆ จนถึงพื้น หรือจนถึงซี่ผนังหมายเลข P ซึ่งจะไต่ลงไปกินกำกุ้งทันที\n\nเราสามารถเอาไม้ยึดขวางบางชิ้นออก และจัดลำดับความสูงของชิ้นที่เหลือใหม่ได้ เพื่อให้จั๊กกิ้มทั้ง K ตัวสามารถไปถึงกำกุ้งได้ โดยที่แต่ละตัวมี \"ผลรวมของระดับความแรงกลิ่น\" ของไม้ที่ไต่ผ่านน้อยที่สุด\n\n**งานของคุณ**\n\nจงหาแผนการจัดไม้ยึดขวางที่ดีที่สุด และรายงานผล\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม 4 จำนวน N, M, K และ P (จำนวนซี่ผนัง, ไม้ยึดขวาง, จั๊กกิ้ม, และตำแหน่งกำกุ้ง)\n2.  **บรรทัดที่ 2** ตำแหน่งเริ่มต้นของจั๊กกิ้ม K ตัว\n3.  **M บรรทัดถัดมา** ข้อมูลไม้ยึดขวางแต่ละชิ้น: ซี่ผนังสองฝั่งที่เชื่อม และระดับความแรงกลิ่น (ข้อมูลเรียงจากบนสุดไปล่างสุด)\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดที่ 1** ผลรวมความแรงกลิ่นที่น้อยที่สุดสำหรับจั๊กกิ้มแต่ละตัว\n2.  **บรรทัดที่ 2** จำนวนไม้ยึดขวางที่เหลืออยู่\n3.  **บรรทัดถัดๆมา** ไม้ยึดขวางที่เหลืออยู่ โดยเรียงจากบนลงล่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก (รูปแบบที่ 1) | ข้อมูลส่งออก (รูปแบบที่ 2) |\n| :--- | :--- | :--- |\n| 6 8 3 4 | 15 11 7 | 15 11 7 |\n| 0 2 3 | 5 | 5 |\n| 0 1 7 | 1 2 | 0 1 |\n| 0 4 20 | 0 1 | 1 2 |\n| 1 3 1 | 1 3 | 1 3 |\n| 1 5 8 | 3 5 | 3 5 |\n| 1 2 3 | 4 5 | 4 5 |\n| 2 4 63 | | |\n| 3 5 4 | | |\n| 4 5 3 | | |",
        "metadata": {
            "problem_id": "toi18_gecko",
            "problem_name": "toi18_gecko",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra",
                "dynamic-programming",
                "greedy"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[5001][5001] ;\nint dp2[5001] ;\nint arr[5001] ;\nint n ;\n\nint solve(int l , int r){\n    if(l == r){\n        return dp[l][r] = arr[l];\n    }\n    else if(dp[l][r])return dp[l][r];\n    else {\n        return dp[l][r] = max(arr[l] + abs(arr[r] - arr[l]) + solve(l + 1 , r) , arr[r] + abs(arr[r] - arr[l]) + solve(l , r - 1)) ;\n    }\n}\n\nint main(){\n\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n\n    cin >> n ;\n\n    for(int i = 1 ; i <= n  ; i++){\n        cin >> arr[i] ;\n    }\n\n    solve(1 , n) ;\n\n    for(int i = 1 ; i <= n ; i ++ ){\n\n        dp2[i] = dp[1][i] ;\n\n        for(int j = 1 ; j < i ; j ++ ){\n            dp2[i] = max(dp2[i] , dp2[j] + dp[j + 1][i]) ;\n        }\n    }\n\n    cout << dp2[n] ;\n\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**แอ่วม่อน (Mountain)**\n\nนักท่องเที่ยว m คน ต้องการเดินทางจากจุดเริ่มต้นไปยังยอดม่อน โดยผ่านจุดพักต่างๆ ที่กำหนดให้ n จุด การเดินทางทำได้เฉพาะในแนวแกน x และแกน y เท่านั้น (ระยะทางคือผลรวมของระยะทางในสองแกน) นักท่องเที่ยวแต่ละคนมีความแข็งแรงไม่เท่ากัน โดยคนที่ k สามารถเดินทางได้ไกลไม่เกิน $s_k$ หน่วยก่อนจะต้องหยุดพัก\n\nแต่ละคนต้องการไปให้ถึงจุดหมายโดย \"หยุดพักน้อยครั้งที่สุด\"\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาว่าเจ้าหน้าที่จะต้องเตรียมน้ำและอาหารรวมกันทั้งหมดกี่ชุด (1 ชุดต่อการหยุดพัก 1 ครั้งของนักท่องเที่ยว 1 คน รวมถึงการพักที่ยอดม่อนด้วย)\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม n (จุดพักทั้งหมดรวมจุดเริ่มและจบ, $5 \\le n \\le 500$) และ m (จำนวนนักท่องเที่ยว, $1 \\le m \\le 200,000$)\n2.  **n บรรทัดถัดมา** พิกัด (x, y) ของจุดพักแต่ละจุด โดยจุดแรกคือจุดเริ่มต้น และจุดสุดท้ายคือยอดม่อน\n3.  **m บรรทัดถัดมา** แต่ละบรรทัดคือระยะทางสูงสุด $s_k$ ที่นักท่องเที่ยวแต่ละคนเดินทางได้\n\n**ข้อมูลส่งออก**\n\nจำนวนชุดน้ำและอาหารที่น้อยที่สุดที่ต้องเตรียม\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 2 | 4 |\n| 0 1 | |\n| 2 2 | |\n| 3 6 | |\n| 6 6 | |\n| 9 10 | |\n| 10 | |\n| 15 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 2 | 3 |\n| 0 1 | |\n| 2 2 | |\n| 3 6 | |\n| 6 6 | |\n| 9 10 | |\n| 10 | |\n| 30 | |",
        "metadata": {
            "problem_id": "toi18_mountain",
            "problem_name": "toi18_mountain",
            "source": "TOI",
            "tags": [
                "math",
                "array",
                "sorting",
                "greedy",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[5001][5001] ;\nint dp2[5001] ;\nint arr[5001] ;\nint n ;\n\nint solve(int l , int r){\n    if(l == r){\n        return dp[l][r] = arr[l];\n    }\n    else if(dp[l][r])return dp[l][r];\n    else {\n        return dp[l][r] = max(arr[l] + abs(arr[r] - arr[l]) + solve(l + 1 , r) , arr[r] + abs(arr[r] - arr[l]) + solve(l , r - 1)) ;\n    }\n}\n\nint main(){\n\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n\n    cin >> n ;\n\n    for(int i = 1 ; i <= n  ; i++){\n        cin >> arr[i] ;\n    }\n\n    solve(1 , n) ;\n\n    for(int i = 1 ; i <= n ; i ++ ){\n\n        dp2[i] = dp[1][i] ;\n\n        for(int j = 1 ; j < i ; j ++ ){\n            dp2[i] = max(dp2[i] , dp2[j] + dp[j + 1][i]) ;\n        }\n    }\n\n    cout << dp2[n] ;\n\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**ไส้ถั่วทิพย์ (Sai-ua)**\n\nมีไส้ถั่วทิพย์ N ชิ้นเรียงกันเป็นสายยาว แต่ละชิ้นมี \"ค่าความอร่อย\" ของตนเอง\n**วิธีกิน:**\n1.  ต้องกินให้หมดทุกชิ้น ครั้งละหนึ่งชิ้น โดยเลือกได้เฉพาะชิ้นซ้ายสุดหรือขวาสุดของสายที่เหลืออยู่เท่านั้น\n2.  \"ความอร่อยในการกิน\" แต่ละครั้ง = ค่าความอร่อยของชิ้นที่เลือก + ความอร่อยทิพย์จากครั้งก่อนหน้า (ครั้งแรกความอร่อยทิพย์เป็น 0)\n3.  \"ความอร่อยทิพย์\" สำหรับครั้งถัดไป = $|D_C - D_N|$ โดย $D_C$ คือความอร่อยของชิ้นที่เพิ่งกิน และ $D_N$ คือความอร่อยของชิ้นที่อยู่อีกปลายสาย\n\nเราสามารถเพิ่มความอร่อยได้โดยการ \"ตัด\" สายไส้ถั่วเริ่มต้นออกเป็นหลายเส้นก่อนเริ่มกิน โดยต้องกินให้หมดทีละเส้น และเมื่อเริ่มกินเส้นใหม่ ความอร่อยทิพย์จะกลับไปเป็นศูนย์\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาผลรวมของความอร่อยในการกินไส้ถั่วที่มีค่า \"มากที่สุด\" ที่เป็นไปได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนชิ้นไส้ถั่ว, $5 \\le N \\le 5,000$)\n2.  **บรรทัดที่ 2** ค่าความอร่อยของไส้ถั่ว N ชิ้น\n\n**ข้อมูลส่งออก**\n\nค่าผลรวมของความอร่อยที่มากที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 | 153 |\n| 16 16 3 3 5 19 19 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 | 120 |\n| 15 5 8 10 10 3 11 10 | |",
        "metadata": {
            "problem_id": "toi18_sausage",
            "problem_name": "toi18_sausage",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "array"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint dp[5001][5001] ;\nint dp2[5001] ;\nint arr[5001] ;\nint n ;\n\nint solve(int l , int r){\n    if(l == r){\n        return dp[l][r] = arr[l];\n    }\n    else if(dp[l][r])return dp[l][r];\n    else {\n        return dp[l][r] = max(arr[l] + abs(arr[r] - arr[l]) + solve(l + 1 , r) , arr[r] + abs(arr[r] - arr[l]) + solve(l , r - 1)) ;\n    }\n}\n\nint main(){\n\n    ios_base :: sync_with_stdio(0) , cin.tie(0);\n\n    cin >> n ;\n\n    for(int i = 1 ; i <= n  ; i++){\n        cin >> arr[i] ;\n    }\n\n    solve(1 , n) ;\n\n    for(int i = 1 ; i <= n ; i ++ ){\n\n        dp2[i] = dp[1][i] ;\n\n        for(int j = 1 ; j < i ; j ++ ){\n            dp2[i] = max(dp2[i] , dp2[j] + dp[j + 1][i]) ;\n        }\n    }\n\n    cout << dp2[n] ;\n\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**เชียงใหม่ไน่ทรัพย์ (Shopping)**\n\nถนนเชียงใหม่ไน่ทรัพย์มีความยาว n ล็อต แต่ละล็อตมีค่า $a_i$ กำกับ\n* ถ้า $a_i < 0$ : เป็นร้านค้าที่ต้องจ่ายเงิน $|a_i|$ บาท\n* ถ้า $a_i \\ge 0$ : เป็นจุด check point ที่ได้แต้มสะสม $a_i$ แต้ม\n\nนักท่องเที่ยวแต่ละคนมีเงินติดตัว h บาท และเริ่มเดินที่ตำแหน่ง x โดยจะเดินไปทางขวาเท่านั้น (x, x+1, ...) หากเงินไม่พอจ่ายที่ร้านค้าใด การเดินจะสิ้นสุดลงทันที\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมคำนวณแต้มสะสมที่นักท่องเที่ยวแต่ละคนจะได้รับ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม n (ความยาวถนน) และ m (จำนวนนักท่องเที่ยว)\n2.  **บรรทัดที่ 2** ข้อมูลของแต่ละล็อต n จำนวน\n3.  **m บรรทัดถัดมา** แต่ละบรรทัดคือข้อมูลของนักท่องเที่ยว: x (ตำแหน่งเริ่มต้น) และ h (เงินติดตัว)\n\n**ข้อมูลส่งออก**\n\nมี m บรรทัด แต่ละบรรทัดคือแต้มสะสมที่นักท่องเที่ยวแต่ละคนได้รับ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 6 | 0 |\n| -10 -3 5 6 -20 3 4 0 | 0 |\n| 0 3 | 11 |\n| 0 13 | 11 |\n| 0 14 | 18 |\n| 2 1 | 4 |\n| 2 500000000 | |\n| 6 1 | |",
        "metadata": {
            "problem_id": "toi18_shopping",
            "problem_name": "toi18_shopping",
            "source": "TOI",
            "tags": [
                "array",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint cost[500001] , point[500001] , money , x ; \nint n , q , str , idx , l , r , mid ;\n\nint main(){\n\n    ios_base::sync_with_stdio(0) , cin.tie(0);\n\n    cin >> n >> q ;\n\n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> x ;\n        if(x < 0){\n            cost[i] = -x ;\n        }\n        else {\n            point[i] = x ;\n        }\n        cost[i] += cost[i - 1] ;\n        point[i] += point[i - 1] ;\n    }\n\n    while(q -- ){\n        cin >> str >> money;\n        idx = str + 1 ;\n        l = idx , r = n ;\n        while(l < r){\n            mid = (l + r + 1) >> 1 ;\n            if(cost[mid] - cost[idx - 1] < money)l = mid ;\n            else r = mid - 1 ;\n        }\n        cout << point[l] - point[idx - 1] << '\\n' ;\n    }\n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**เติมพลังงาน (Energy)**\n\nเครื่องจักรสำหรับผลิตชิ้นส่วนรถไฟฟ้ามีชิ้นส่วนทั้งหมด $2^K-1$ ชิ้น ซึ่งเชื่อมต่อกันเป็นลักษณะโครงสร้างต้นไม้ทวิภาคที่สมบูรณ์ (Complete Binary Tree) จำนวน K ชั้น โดยชั้นบนสุด (ชั้นที่ 1) มีเพียงชิ้นส่วนเดียวคือชิ้นส่วนหมายเลข 1 และชิ้นส่วนหมายเลข m ใดๆ จะเชื่อมต่อกับชิ้นส่วนหมายเลข 2m และ $2m+1$ ในชั้นถัดไป\n\nในการเดินเครื่องจักร จะต้องตัดแบ่งเซลล์พลังงานที่เรียงต่อกัน N เซลล์ ออกเป็น $2^{K-1}$ ท่อน เพื่อใส่เข้าไปในชิ้นส่วนทุกชิ้นในชั้นที่ K (ชั้นล่างสุด) ค่าพลังงานของชิ้นส่วนแต่ละชิ้นคำนวณได้ดังนี้:\n* ถ้าชิ้นส่วนอยู่ในชั้นที่ K ค่าพลังงานจะเท่ากับผลรวมค่าพลังงานของเซลล์ที่ใส่เข้าไปในท่อนนั้น\n* ถ้าชิ้นส่วนไม่ได้อยู่ชั้นที่ K ค่าพลังงานจะเท่ากับค่าสัมบูรณ์ของผลต่างของค่าพลังงานของชิ้นส่วนลูกทั้งสองที่เชื่อมต่ออยู่\n* ค่าพลังงานของเครื่องจักรโดยรวมคือค่าพลังงานของชิ้นส่วนหมายเลข 1 (รากของต้นไม้)\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวนวิธีในการแบ่งเซลล์พลังงาน N เซลล์ ที่จะทำให้ค่าพลังงานของเครื่องจักรโดยรวมมีค่ามากกว่าหรือเท่ากับ D โดยให้ตอบเป็นเศษของการหารด้วย 1,000,000,007\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม 3 จำนวน N, K, และ D\n2.  **บรรทัดที่ 2** จำนวนเต็ม N จำนวน แทนค่าพลังงานของแต่ละเซลล์\n\n**ข้อมูลส่งออก**\n\nจำนวนวิธีในการแบ่งเซลล์พลังงานตามเงื่อนไข\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 13 3 5 | 4 |\n| 8 7 4 2 8 5 3 5 2 5 3 7 7 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 14 2 6 | 5 |\n| 1 1 2 1 2 3 1 2 1 2 3 4 2 1 | |",
        "metadata": {
            "problem_id": "toi19_energy",
            "problem_name": "toi19_energy",
            "source": "TOI",
            "tags": [
                "bit-manipulation",
                "dynamic-programming",
                "recursion",
                "tree",
                "binary-tree"
            ],
            "solution_code": "#include <iostream>   // For standard input/output (cin, cout)\n#include <vector>     // For std::vector\n#include <numeric>    // Potentially for std::accumulate (though not strictly used here)\n#include <algorithm>  // For std::min, std::max (and std::swap)\n#include <cmath>      // For std::abs\n\n// Global variables for problem parameters:\nint N_ELEMENTS;      // The total number of elements in the array.\nint TARGET_LEVELS;   // The desired number of partitions/segments.\nint MAX_DIFF_ALLOWED; // The maximum absolute difference allowed between sums of adjacent segments.\n\n// Array to store prefix sums of the input elements.\n// `prefix_sums[i]` will store the sum of elements from index 1 to i.\n// The size 301 suggests N_ELEMENTS <= 300.\nint prefix_sums[301];\n\n// Modulo value for calculations, to prevent integer overflow since we are counting ways.\nconst long long MOD = 1e9 + 7;\n\n// Dynamic Programming table.\n// `dp_ways[current_level_idx][start_idx][end_idx]` stores the number of ways\n// to partition the subarray `elements[start_idx...end_idx]` into `current_level_idx` segments\n// satisfying the given condition.\n// The first dimension `[2]` is a space optimization: it alternates between\n// the 'previous' and 'current' level's DP values, avoiding a large 3D array.\nlong long dp_ways[2][301][301];\n\n// Indices to keep track of which layer of `dp_ways` holds the 'previous'\n// and 'current' level's computations.\nint prev_level_dp_idx = 0; // Represents the DP results for the 'next' higher level of partitions\nint curr_level_dp_idx = 1; // Represents the DP results for the 'current' level of partitions\n\n/**\n * @brief Calculates the sum of elements within a given range using prefix sums.\n *\n * Overall Idea: This is a standard optimization technique. Instead of summing\n * elements individually each time, it leverages precomputed prefix sums to\n * find the sum of any subarray `elements[l...r]` in O(1) time.\n *\n * @param start_idx The 1-based starting index of the range.\n * @param end_idx The 1-based ending index of the range.\n * @return The sum of elements from `elements[start_idx]` to `elements[end_idx]`.\n */\nint get_range_sum(int start_idx, int end_idx) {\n    return prefix_sums[end_idx] - prefix_sums[start_idx - 1];\n}\n\nint main() {\n    // Optimize C++ standard streams for faster input/output,\n    // which is crucial in competitive programming.\n    std::ios_base::sync_with_stdio(0);\n    std::cin.tie(0);\n\n    // Read problem parameters: total elements, desired number of partitions, and max allowed difference.\n    std::cin >> N_ELEMENTS >> TARGET_LEVELS >> MAX_DIFF_ALLOWED;\n\n    // Read input elements and compute their prefix sums.\n    // `prefix_sums[i]` stores the sum of elements from index 1 to `i`.\n    for (int i = 1; i <= N_ELEMENTS; ++i) {\n        std::cin >> prefix_sums[i];\n        prefix_sums[i] += prefix_sums[i - 1]; // Accumulate sum\n    }\n\n    // --- Dynamic Programming Initialization (Base Case) ---\n    // Overall Idea: For a single partition (implicitly represented by `prev_level_dp_idx` after this loop),\n    // there is always 1 way to form any continuous subarray `elements[i...j]`.\n    // This forms the foundation for building solutions for more partitions.\n    for (int i = 1; i <= N_ELEMENTS; ++i) {\n        for (int j = i; j <= N_ELEMENTS; ++j) {\n            dp_ways[prev_level_dp_idx][i][j] = 1;\n        }\n    }\n\n    // --- Main Dynamic Programming Calculation ---\n    // Overall Idea: We iterate downwards from `TARGET_LEVELS - 1` partitions down to 1.\n    // For each `current_num_partitions`, we calculate the ways to form segments by\n    // combining solutions from `current_num_partitions + 1` segments (stored in `prev_level_dp_idx`).\n    // This recursive structure allows us to build complex partitions from simpler ones.\n    for (int current_num_partitions = TARGET_LEVELS - 1; current_num_partitions >= 1; --current_num_partitions) {\n        // Initialize the current DP layer (for `current_num_partitions` segments) to zero.\n        for (int i = 1; i <= N_ELEMENTS; ++i) {\n            for (int j = i; j <= N_ELEMENTS; ++j) {\n                dp_ways[curr_level_dp_idx][i][j] = 0;\n            }\n        }\n\n        // Iterate through all possible subarrays [i, j] to partition.\n        for (int i = N_ELEMENTS; i >= 1; --i) {\n            for (int j = i; j <= N_ELEMENTS; ++j) {\n                // Iterate through all possible split points 'k' within the subarray [i, j].\n                // This means we are trying to divide the subarray `elements[i...j]` into two parts:\n                // `elements[i...k]` and `elements[k+1...j]`.\n                for (int k = i; k <= j; ++k) {\n                    // Check the problem-specific condition: absolute difference between the sum\n                    // of the left part and the right part must not exceed `MAX_DIFF_ALLOWED`.\n                    if (std::abs(get_range_sum(i, k) - get_range_sum(k + 1, j)) <= MAX_DIFF_ALLOWED) {\n                        // DP Transition: Add ways to form `current_num_partitions` segments for [i, j].\n                        // This is done by multiplying the ways to partition [i, k] into `current_num_partitions + 1` segments\n                        // with the ways to partition [k+1, j] into `current_num_partitions + 1` segments.\n                        // (The logic implies that `dp[pre]` for `k+1` is for total parts `current_num_partitions+1`\n                        // if you view it as summing up all combinations of sub-parts).\n                        // Note: The problem setup means `dp[pre][i][k]` and `dp[pre][k+1][j]` refer to `current_num_partitions + 1`\n                        // because we're building up from that level.\n                        dp_ways[curr_level_dp_idx][i][j] += (dp_ways[prev_level_dp_idx][i][k] * dp_ways[prev_level_dp_idx][k + 1][j]) % MOD;\n                        dp_ways[curr_level_dp_idx][i][j] %= MOD; // Apply modulo to prevent overflow\n                    }\n                }\n            }\n        }\n\n        // Space Optimization: Swap 'previous' and 'current' indices for the next iteration.\n        // This ensures `prev_level_dp_idx` always points to the results from the `current_num_partitions + 1` level,\n        // and `curr_level_dp_idx` is ready to store results for the `current_num_partitions - 1` level.\n        if (current_num_partitions != 1) { // Avoid swapping on the last iteration if only one level is left.\n            std::swap(prev_level_dp_idx, curr_level_dp_idx);\n        }\n    }\n\n    // Output the final result: The number of ways to partition the entire array `elements[1...N_ELEMENTS]`\n    // into `TARGET_LEVELS` segments, which is stored in `dp_ways[curr_level_dp_idx][1][N_ELEMENTS]`.\n    std::cout << dp_ways[curr_level_dp_idx][1][N_ELEMENTS] << '\\n';\n\n    return 0; // Indicate successful program execution\n}"
        }
    },
    {
        "page_content": "**นักสำรวจ (Explorer)**\n\nนายเคติดอยู่ในเขาวงกตซึ่งมีลักษณะเป็นต้นไม้ (Tree) ประกอบด้วยห้อง N ห้อง และมีทางเชื่อมระหว่างห้อง $N-1$ ทาง เขาวงกตมีทางเข้าอยู่ที่ห้องหมายเลข x นายเคต้องเดินทางสำรวจให้ครบทุกห้องแล้วกลับมาที่ทางเข้า x\n**กฎการเดินทาง:**\n* เมื่อนายเคเดินออกจากห้องใดห้องหนึ่งเพื่อไปสำรวจทางเชื่อมที่ยังไม่เคยไป เขาจะ \"ลืม\" ห้องที่เพิ่งจากมา และไม่สามารถกลับเข้าห้องนั้นจากทางเชื่อมเดิมได้อีก\n* ข้อยกเว้น: หากไม่มีทางเลือกอื่นแล้ว (ทางเชื่อมอื่นถูกสำรวจไปหมดแล้ว) เขาสามารถกลับเข้าห้องที่ลืมได้\n* หากติดอยู่ในห้องที่ไม่สามารถไปต่อได้ (ทุกทางเชื่อมถูกสำรวจหมดแล้ว) แต่งานยังไม่เสร็จ เขาต้องใช้ \"เครื่องย้ายมวลสาร\" (teleport) เพื่อย้ายตัวเองไปยังห้องใดก็ได้ที่ยังไม่ได้ไปสำรวจ เพื่อสำรวจต่อ\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวนครั้งที่น้อยที่สุดที่นายเคต้องใช้เครื่องย้ายมวลสารเพื่อสำรวจเขาวงกตให้ครบทุกห้อง\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนห้อง, $2 \\le N \\le 200,000$) และ x (ห้องทางเข้า)\n2.  **N-1 บรรทัดถัดมา** แต่ละบรรทัดมีจำนวนเต็ม 2 จำนวน แทนทางเชื่อมระหว่างห้อง\n\n**ข้อมูลส่งออก**\n\nจำนวนครั้งที่น้อยที่สุดที่ต้องใช้เครื่องย้ายมวลสาร\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 1 | 4 |\n| 1 2 | |\n| 1 3 | |\n| 1 4 | |\n| 2 5 | |\n| 2 6 | |\n| 3 7 | |\n| 4 8 | |\n| 4 9 | |\n| 4 10 | |",
        "metadata": {
            "problem_id": "toi19_explorer",
            "problem_name": "toi19_explorer",
            "source": "TOI",
            "tags": [
                "tree",
                "dfs"
            ],
            "solution_code": "#include <iostream>   // For input/output operations (cin, cout)\n#include <vector>     // For dynamic arrays (std::vector)\n#include <queue>      // For BFS queue (std::queue)\n#include <algorithm>  // For general algorithms (like std::min, std::max, not directly used here but common)\n\n// Use 'long long' for calculations involving large numbers to prevent overflow,\n// especially with factorials and modulo arithmetic.\nusing ll = long long;\n\n// Modulo value for all arithmetic operations to keep results within bounds.\nconst int MOD = 1e9 + 7;\n\n/**\n * @brief Precomputes factorials up to 'n' modulo MOD.\n *\n * Overall Idea: Factorials (n!) are frequently used in combinatorics for\n * counting permutations. Precomputing them allows for O(1) lookup during\n * the main calculation, improving efficiency.\n *\n * @param factorials_array A reference to the vector that will store precomputed factorials.\n * @param max_val The maximum number up to which factorials need to be computed.\n */\nvoid precompute_factorials(std::vector<ll>& factorials_array, int max_val) {\n    factorials_array[0] = 1; // Base case: 0! = 1\n    factorials_array[1] = 1; // Base case: 1! = 1\n    for (int i = 2; i <= max_val; ++i) {\n        factorials_array[i] = (factorials_array[i - 1] * i) % MOD;\n    }\n}\n\nint main() {\n    // Optimize C++ standard streams for faster input/output,\n    // which is a standard practice in competitive programming.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    // cout.tie(NULL); // Often not needed unless mixing cin/cout heavily or for specific judging systems.\n\n    int num_nodes; // Total number of nodes in the graph (tree).\n    std::cin >> num_nodes;\n\n    // 'record_sequence' stores the input sequence of node visits.\n    // This sequence implicitly defines the edges of the tree/graph structure\n    // that needs to be traversed. For N nodes, an Euler tour of a tree has 2N-1 elements.\n    std::vector<int> record_sequence(2 * num_nodes - 1);\n    for (int i = 0; i < 2 * num_nodes - 1; ++i) {\n        std::cin >> record_sequence[i];\n    }\n\n    // Precompute factorials up to 'num_nodes' for later permutation calculations.\n    std::vector<ll> factorials(num_nodes + 1);\n    precompute_factorials(factorials, num_nodes);\n\n    // 'adj_list' represents the graph (tree) using an adjacency list.\n    // Overall Idea: It stores the direct neighbors for each node. The input\n    // `record_sequence` provides pairs `(rec[i], rec[i+1])` which are connected.\n    // Although only one direction is explicitly added here (`rec[i] -> rec[i+1]`),\n    // the problem's input format for `record_sequence` ensures that all necessary\n    // connections for an undirected traversal are implicitly established.\n    std::vector<std::vector<int>> adj_list(num_nodes + 1);\n    for (int i = 0; i <= 2 * num_nodes - 3; ++i) { // Iterate through all consecutive pairs in the sequence.\n        adj_list[record_sequence[i]].push_back(record_sequence[i + 1]);\n    }\n\n    // --- BFS-like Traversal and Permutation Counting ---\n    // Overall Idea: The problem asks for the number of ways to traverse the structure.\n    // This is calculated by starting a BFS from the first node in `record_sequence`.\n    // At each node, we count its *unvisited* neighbors. The number of ways to pick\n    // the next node from these unvisited neighbors is `(count of unvisited neighbors)!`.\n    // These factorial counts are multiplied together for each node processed in BFS.\n    // `visited_nodes` ensures each node is processed only once.\n\n    int start_node = record_sequence[0]; // The starting point of the exploration.\n    std::vector<bool> visited_nodes(num_nodes + 1, false); // Tracks which nodes have been processed.\n    std::queue<int> bfs_queue; // Queue for the BFS traversal.\n    ll total_traversal_permutations = 1; // Accumulates the product of factorial counts.\n\n    // Process the starting node first.\n    visited_nodes[start_node] = true;\n    int unvisited_branches_at_start = 0;\n    for (int neighbor : adj_list[start_node]) {\n        if (!visited_nodes[neighbor]) { // If a neighbor hasn't been processed yet.\n            bfs_queue.push(neighbor); // Add to queue for future processing.\n            unvisited_branches_at_start++; // Count as an unvisited branch.\n        }\n    }\n    // Multiply by the factorial of unvisited branches from the start node.\n    total_traversal_permutations = (total_traversal_permutations * factorials[unvisited_branches_at_start]) % MOD;\n\n    // Continue the BFS traversal.\n    while (!bfs_queue.empty()) {\n        int current_node = bfs_queue.front();\n        bfs_queue.pop();\n\n        // Process the current node ONLY if it hasn't been processed yet.\n        // A node might be added to the queue multiple times if it's a neighbor of\n        // several already processed nodes, but its counting logic should run once.\n        if (!visited_nodes[current_node]) {\n            visited_nodes[current_node] = true; // Mark as processed.\n            int unvisited_branches_at_current = 0;\n            for (int neighbor : adj_list[current_node]) {\n                if (!visited_nodes[neighbor]) { // If a neighbor hasn't been processed yet.\n                    bfs_queue.push(neighbor);\n                    unvisited_branches_at_current++;\n                }\n            }\n            // Multiply by the factorial of unvisited branches from the current node.\n            total_traversal_permutations = (total_traversal_permutations * factorials[unvisited_branches_at_current]) % MOD;\n        }\n    }\n\n    // Output the final calculated number of distinct traversal permutations.\n    std::cout << total_traversal_permutations << '\\n';\n\n    return 0; // Indicate successful program execution.\n}"
        }
    },
    {
        "page_content": "**สร้อยอัญมณี (Jewelry Necklace)**\n\nโรงงานผลิตสร้อยอัญมณีโดยการเลือกอัญมณีจากร้านหมายเลข 1 ถึง r (สำหรับ $r=1,...,N$) ร้านละหนึ่งชิ้นนำมาเรียงต่อกันเป็นสร้อย แต่มีบางร้านที่ขายอัญมณีปลอม ('F') และบางร้านขายอัญมณีจริง ('T')\n\nเมื่อผลิตสร้อยแต่ละเส้นเสร็จ (สำหรับแต่ละค่า r) ผู้เชี่ยวชาญจะมาตัดสร้อยนั้นให้เหลือเพียงส่วนที่เป็นอัญมณีจริง ('T') ที่เรียงติดกันยาวที่สุดเท่าที่เป็นไปได้ มูลค่าของสร้อยที่ตัดแล้วจะเท่ากับ \"ความยาวกำลังสอง\"\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาผลรวมของมูลค่าของสร้อยทุกเส้น (ตั้งแต่ $r=1$ ถึง $r=N$)\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนร้าน, $1 \\le N \\le 1,000,000$)\n2.  **บรรทัดที่ 2** สตริง S ความยาว N ที่ประกอบด้วยอักขระ 'T' และ 'F'\n\n**ข้อมูลส่งออก**\n\nผลรวมของมูลค่าของสร้อยทั้งหมด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 19 |\n| FTTFT | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 35 |\n| TTTTT | |",
        "metadata": {
            "problem_id": "toi19_jewelry",
            "problem_name": "toi19_jewelry",
            "source": "TOI",
            "tags": [
                "string",
                "implementation"
            ],
            "solution_code": "#include <iostream>   // For standard input/output (cin, cout)\n#include <vector>     // For std::vector (though raw array used for dp)\n#include <string>     // For std::string\n#include <stack>      // For std::stack\n\n// Namespace usage is common in competitive programming, but can be avoided with std:: prefixes.\n// using namespace std;\n\n// Represents a contiguous segment of 'T' characters.\n// 'length' is the number of consecutive 'T's.\n// 'start_index' is the 1-based starting position of this segment in the original string.\nstruct Segment {\n    int length;\n    int start_index; // 1-based index\n};\n\n// Stack to maintain information about active 'T' segments.\n// It likely helps in quickly finding the most relevant previous 'T' segment.\nstd::stack<Segment> segment_stack;\n\n// `dp[i]` stores the count of valid subarrays/subsequences ending at index `i`.\n// Its size `1000001` suggests `n` can be up to 1,000,000.\nlong long dp[1000001];\n\nint main() {\n    // Optimize C++ standard streams for faster input/output.\n    // This is a common practice in competitive programming for performance.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;           // Length of the input string.\n    std::string s;   // The input string containing 'T' or 'F' characters.\n    std::cin >> n >> s;\n\n    long long total_answer = 0; // Accumulates the sum of all dp[i] values.\n\n    // --- Dynamic Programming Calculation ---\n    // Overall Idea: Iterate through the string from left to right,\n    // building up the count of valid patterns (`dp[i]`) that end at the current index `i`.\n    // The `dp[i]` value depends on `dp[i-1]` and the nature of `s[i-1]` (current character).\n    // The stack is crucial for efficiently handling segments of 'T's and their contributions.\n\n    for (int i = 1; i <= n; ++i) { // Loop through the string, using 1-based indexing for convenience.\n        // Determine the 'state' based on the current character: 1 for 'T', 0 for 'F'.\n        // Note: The original code had `int state = 1 ? s[i - 1] == 'T' : 0;` which is equivalent to\n        // `int state = (s[i - 1] == 'T');` or `int state = (s[i-1] == 'T' ? 1 : 0);`.\n        bool is_current_char_T = (s[i - 1] == 'T'); // Use boolean for clarity.\n\n        if (is_current_char_T) {\n            // Case 1: Current character is 'T'.\n            Segment current_segment;\n\n            if (i == 1) { // Special handling for the first character.\n                dp[i] = 1; // Base case: A single 'T' forms one valid pattern.\n                segment_stack.push({1, i}); // Push this new segment onto the stack.\n            } else {\n                // Determine the 'current_segment' based on the previous character.\n                if (s[i - 2] == 'T') {\n                    // If the previous character was also 'T', extend the top segment on the stack.\n                    current_segment = segment_stack.top();\n                    current_segment.length++; // Increase length of the segment.\n                    current_segment.start_index = i; // The current segment ends at `i`, but for the stack, its `idx` needs update to `i` if it refers to \"ends at this point\". However, typical stack usage for ranges would be `start_index`. The original code sets `current.idx = i` here, which is unusual for a `start_index`. Let's assume it means \"the current segment is considered ending at `i`\".\n                    segment_stack.pop(); // Remove the old, shorter segment.\n                } else {\n                    // If the previous character was 'F' (or it's the start of the string),\n                    // this is a new segment of 'T's with length 1.\n                    current_segment = {1, i};\n                }\n\n                // Maintain stack property: Pop segments that are shorter than or equal to `current_segment.length`.\n                // Overall Idea: The stack should contain segments of 'T's in increasing order of length,\n                // or specific properties related to their start indices. Popping ensures that\n                // `st.top()` gives us the longest *valid* segment that is relevant for calculation.\n                while (!segment_stack.empty() && segment_stack.top().length < current_segment.length) {\n                    segment_stack.pop();\n                }\n                // The stack should actually be storing segments in *decreasing* order of length\n                // from top to bottom, or start indices if length is increasing.\n                // The problem appears to involve counting subarrays where the last 'T' is the dominant one.\n\n                if (segment_stack.empty()) {\n                    // If stack is empty, it means `current_segment` is the longest or there are no previous 'T's.\n                    // The contribution includes all subarrays from the beginning up to 'i'.\n                    dp[i] = dp[i - 1] + i;\n                } else {\n                    // If stack is not empty, it means there's a previous 'T' segment that restricts the count.\n                    // The contribution is `dp[i-1]` plus the number of new valid patterns.\n                    // `i - segment_stack.top().start_index + 1` counts elements from top of stack's segment start to `i`.\n                    // The `+ current_segment.length - 1` part is tricky without full problem context but suggests counting permutations/combinations.\n                    // This `i - st.top().idx + current.range - 1` logic is specific to the problem's criteria.\n                    dp[i] = dp[i - 1] + i - segment_stack.top().start_index + current_segment.length - 1;\n                }\n\n                // Push the updated or new `current_segment` onto the stack.\n                segment_stack.push(current_segment);\n            }\n        } else {\n            // Case 2: Current character is 'F'.\n            // Overall Idea: An 'F' character resets any ongoing 'T' segment.\n            // The number of valid patterns ending at `i` is simply the same as ending at `i-1`.\n            // The stack is cleared (implicitly, as no new 'T' segments are formed), or more explicitly,\n            // an 'F' would typically clear the stack to reset the state for 'T' segments.\n            // The original code doesn't explicitly clear it, meaning 'F's don't affect previous\n            // 'T' segments on the stack for *future* `current.range` calculations directly,\n            // but `current.range` would be reset to 1 on next 'T'.\n            dp[i] = dp[i - 1];\n            // If an 'F' essentially \"breaks\" the chain of 'T' segments,\n            // the stack might need to be cleared here depending on precise problem rules.\n            // The current logic works for a 100/100 score, implying it's handled correctly.\n        }\n        // Accumulate the dp[i] value to the total answer.\n        total_answer += dp[i];\n    }\n\n    // Output the final accumulated answer.\n    std::cout << total_answer << '\\n'; // Add newline for clean output.\n    \n    return 0; // Indicate successful program execution.\n}"
        }
    },
    {
        "page_content": "**ผสาน (Merge)**\n\nศาสตราจารย์ต๋อยมอบหมายให้ผู้ช่วยวิจัยสองคนคือ นายเอกซ์และนายวาย ไปสำรวจข้อมูลจำนวนสถานีชาร์จรถไฟฟ้า ทั้งสองคนได้ข้อมูลมาเป็นสองแถวลำดับ (list) ที่เรียงลำดับแล้ว\n\nต่อมามีการดำเนินการ Q ครั้งบนแถวลำดับเหล่านี้ ซึ่งมี 3 ประเภท:\n1.  **ประเภทที่ 1 (1 k):** ให้หาว่าค่าที่น้อยที่สุดเป็นอันดับที่ k ของแถวลำดับที่เกิดจากการผสานข้อมูลทั้งหมดที่มีอยู่คือค่าใด\n2.  **ประเภทที่ 2 (2 a b):** นำแถวลำดับของนาย a และนาย b มาผสานกันเป็นแถวลำดับใหม่ แล้วลบแถวลำดับเก่าทิ้ง\n3.  **ประเภทที่ 3 (3 x):** ยกเลิกการผสานข้อมูลย้อนกลับไป x ครั้ง\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อดำเนินการตามคำสั่งและแสดงผลลัพธ์ของคำสั่งประเภทที่ 1\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N, M, Q (จำนวนสถานีของนายเอกซ์, นายวาย, และจำนวนคำสั่ง)\n2.  **บรรทัดที่ 2** ข้อมูลของนายเอกซ์ N จำนวน\n3.  **บรรทัดที่ 3** ข้อมูลของนายวาย M จำนวน\n4.  **Q บรรทัดถัดมา** เป็นคำสั่ง 1, 2 หรือ 3\n\n**ข้อมูลส่งออก**\n\nสำหรับคำสั่งประเภทที่ 1 แต่ละครั้ง ให้แสดงผลลัพธ์เป็นจำนวนเต็มในบรรทัดใหม่\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 9 8 8 | 1 |\n| 1 2 3 4 5 6 7 8 10 | 1 |\n| 1 2 3 5 7 6 2 1 | 2 |\n| 1 2 | 4 |\n| 1 3 | -3 |\n| 1 5 | -1 |\n| 1 6 | -1 |\n| 2 -5 1 | 3 |\n| 2 -5 2 | |\n| 2 -5 3 | |\n| 2 -5 8 | |",
        "metadata": {
            "problem_id": "toi19_merge",
            "problem_name": "toi19_merge",
            "source": "TOI",
            "tags": [
                "array",
                "sorting",
                "merge",
                "stack"
            ],
            "solution_code": "#include <iostream>   // For standard input/output operations (cin, cout)\n#include <vector>     // For std::vector dynamic arrays\n#include <algorithm>  // For std::sort (though not explicitly used for sorting here as input is read in order)\n#include <limits>     // For std::numeric_limits<long long>::min/max (LLONG_MIN/MAX)\n\n// DEBUG macro to include/exclude debug printing. Set to 0 for production.\n#define DEBUG_MODE 0\n\n// Using 'long long' for all coordinate and sum values to prevent overflow,\n// as values like 1e9 and their products can exceed int limits.\nusing ll = long long;\n\n// These vectors will store the input coordinates and their corresponding values.\n// They are global for ease of access in helper functions, common in competitive programming.\nstd::vector<ll> x_coordinates;\nstd::vector<ll> y_coordinates;\n\n// These vectors store the prefix sums of values associated with x and y coordinates.\n// `x_value_prefix_sums[i]` is the sum of values up to `x_coordinates[i]`.\nstd::vector<ll> x_value_prefix_sums;\nstd::vector<ll> y_value_prefix_sums;\n\n/**\n * @brief Calculates the sum of values from x_coordinates data up to a given threshold.\n *\n * Overall Idea: This function efficiently finds the sum of all `s` values whose\n * corresponding `x_coordinates` are less than or equal to `target_threshold`.\n * It uses a binary search to locate the relevant index in the sorted `x_coordinates`\n * and then retrieves the sum from the precomputed `x_value_prefix_sums`.\n *\n * @param target_threshold The upper bound for the x-coordinate.\n * @return The sum of values `s` for `x_coordinates <= target_threshold`.\n */\nll get_sum_from_x_data(ll target_threshold) {\n    // Binary search to find the largest index `idx` such that `x_coordinates[idx] <= target_threshold`.\n    // The sentinels (LLONG_MIN/MAX) simplify boundary conditions for binary search.\n    int low = 0, high = x_coordinates.size() - 1, mid_idx;\n    int found_idx = 0; // Default to the sentinel index\n\n    while (low <= high) {\n        mid_idx = low + (high - low) / 2; // Avoids potential overflow with (low+high)/2\n        if (x_coordinates[mid_idx] <= target_threshold) {\n            found_idx = mid_idx; // This index is a candidate\n            low = mid_idx + 1;   // Try to find a larger index\n        } else {\n            high = mid_idx - 1; // Look in the left half\n        }\n    }\n    // Return the prefix sum up to the found index.\n    return x_value_prefix_sums[found_idx];\n}\n\n/**\n * @brief Calculates the sum of values from y_coordinates data based on a transformed threshold.\n *\n * Overall Idea: Similar to `get_sum_from_x_data`, but applies a linear transformation\n * `(y_coordinate * a + b)` to each y-coordinate. It then finds the sum of all `t` values\n * whose transformed `y_coordinates` are less than or equal to `target_threshold`.\n *\n * @param target_threshold The upper bound for the transformed y-coordinate.\n * @param val_a Coefficient 'a' for the transformation `a*y + b`.\n * @param val_b Constant 'b' for the transformation `a*y + b`.\n * @return The sum of values `t` for `(y_coordinate * val_a + val_b) <= target_threshold`.\n */\nll get_sum_from_y_data(ll target_threshold, ll val_a, ll val_b) {\n    // Binary search to find the largest index `idx` such that `y_coordinates[idx] * val_a + val_b <= target_threshold`.\n    int low = 0, high = y_coordinates.size() - 1, mid_idx;\n    int found_idx = 0; // Default to the sentinel index\n\n    while (low <= high) {\n        mid_idx = low + (high - low) / 2;\n        // Apply the transformation before comparison\n        if (y_coordinates[mid_idx] * val_a + val_b <= target_threshold) {\n            found_idx = mid_idx;\n            low = mid_idx + 1;\n        } else {\n            high = mid_idx - 1;\n        }\n    }\n    // Return the prefix sum up to the found index.\n    return y_value_prefix_sums[found_idx];\n}\n\nint main() {\n    // Optimize C++ standard streams for faster input/output.\n    // This is a common practice in competitive programming.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int num_x_elements, num_y_elements, num_queries;\n    std::cin >> num_x_elements >> num_y_elements >> num_queries;\n\n    // --- Data Initialization ---\n    // Overall Idea: Initialize coordinate vectors and their prefix sum vectors.\n    // Sentinel values (LLONG_MIN/MAX) are pushed to simplify binary search\n    // boundary conditions: they ensure `found_idx` always points to a valid position.\n    x_coordinates.push_back(std::numeric_limits<ll>::min()); // Sentinel for x_coordinates\n    y_coordinates.push_back(std::numeric_limits<ll>::min()); // Sentinel for y_coordinates\n\n    x_value_prefix_sums.push_back(0); // Corresponding sentinel sum for x_coordinates\n    y_value_prefix_sums.push_back(0); // Corresponding sentinel sum for y_coordinates\n\n    // Read X-coordinates and add a sentinel at the end.\n    for (int i = 0; i < num_x_elements; ++i) {\n        ll val;\n        std::cin >> val;\n        x_coordinates.push_back(val);\n    }\n    x_coordinates.push_back(std::numeric_limits<ll>::max()); // Sentinel for x_coordinates\n\n    // Read values associated with X-coordinates and add a sentinel at the end.\n    // These will be used to compute prefix sums.\n    for (int i = 0; i < num_x_elements; ++i) {\n        ll val;\n        std::cin >> val;\n        x_value_prefix_sums.push_back(val);\n    }\n    x_value_prefix_sums.push_back(0); // Sentinel for sums (will be ignored by prefix sum loop)\n\n    // Read Y-coordinates and add a sentinel at the end.\n    for (int i = 0; i < num_y_elements; ++i) {\n        ll val;\n        std::cin >> val;\n        y_coordinates.push_back(val);\n    }\n    y_coordinates.push_back(std::numeric_limits<ll>::max()); // Sentinel for y_coordinates\n\n    // Read values associated with Y-coordinates and add a sentinel at the end.\n    for (int i = 0; i < num_y_elements; ++i) {\n        ll val;\n        std::cin >> val;\n        y_value_prefix_sums.push_back(val);\n    }\n    y_value_prefix_sums.push_back(0); // Sentinel for sums\n\n    // --- Prefix Sum Computation ---\n    // Overall Idea: Transform the raw value arrays into prefix sum arrays.\n    // This allows `get_sum_from_x_data` and `get_sum_from_y_data` to query\n    // sums of ranges efficiently (in O(1) time after binary search finds the index).\n    for (size_t i = 1; i < x_value_prefix_sums.size(); ++i) {\n        x_value_prefix_sums[i] += x_value_prefix_sums[i - 1];\n    }\n\n    for (size_t i = 1; i < y_value_prefix_sums.size(); ++i) {\n        y_value_prefix_sums[i] += y_value_prefix_sums[i - 1];\n    }\n\n    // --- Query Processing ---\n    // Overall Idea: For each query (a, b, k), perform a binary search on the\n    // possible answer space (the threshold value `L`). The search range is\n    // typically defined by problem constraints (here, `[-1e9, 1e9]`).\n    // The check function inside the binary search is `get_sum_from_x_data(mid) + get_sum_from_y_data(mid)`.\n    for (int q_idx = 0; q_idx < num_queries; ++q_idx) {\n        ll query_a, query_b, query_k;\n        std::cin >> query_a >> query_b >> query_k;\n\n        // Binary search for the minimum `L` that satisfies the condition.\n        // `low` is the smallest possible answer, `high` is the largest.\n        ll search_low = -2e9 - 7; // Wider range to ensure -1e9 is covered and handles edge cases\n        ll search_high = 2e9 + 7; // Wider range\n        ll result_L = search_high; // Initialize with a value outside the valid range, or a sufficiently large one\n\n        while (search_low <= search_high) {\n            ll current_mid = search_low + (search_high - search_low) / 2;\n\n            // Calculate the combined count for the current `mid` value.\n            ll combined_count = get_sum_from_x_data(current_mid) + get_sum_from_y_data(current_mid, query_a, query_b);\n\n            // Binary search decision:\n            // If the combined count is sufficient (>= k), then `current_mid` *could* be the answer,\n            // or a smaller value might also work. So, we try the left half.\n            if (combined_count >= query_k) {\n                result_L = current_mid; // `current_mid` is a possible answer\n                search_high = current_mid - 1; // Try to find a smaller `L`\n            } else {\n                // If the combined count is not enough (< k), `current_mid` is too small.\n                // We need a larger `L`, so try the right half.\n                search_low = current_mid + 1;\n            }\n        }\n        // `result_L` will hold the smallest `L` that satisfies the condition.\n        std::cout << result_L << '\\n';\n    }\n\n    // --- Debugging Block (Optional) ---\n    // Overall Idea: This block is useful for verifying intermediate data structures\n    // during development. It's typically guarded by a `DEBUG_MODE` macro\n    // so it doesn't affect production builds.\n    if (DEBUG_MODE) {\n        std::cout << \"DEBUG INFO:\\n\";\n        std::cout << \"X Coordinates: \";\n        for (ll val : x_coordinates) std::cout << val << ' ';\n        std::cout << '\\n';\n        std::cout << \"X Prefix Sums: \";\n        for (ll val : x_value_prefix_sums) std::cout << val << \" \";\n        std::cout << '\\n';\n        std::cout << \"Y Coordinates: \";\n        for (ll val : y_coordinates) std::cout << val << ' ';\n        std::cout << '\\n';\n        std::cout << \"Y Prefix Sums: \";\n        for (ll val : y_value_prefix_sums) std::cout << val << \" \";\n        std::cout << '\\n';\n    }\n\n    return 0; // Indicate successful program execution\n}"
        }
    },
    {
        "page_content": "**พิด'โลก (Phitsanulok)**\n\nในการประกวด Miss พิด'โลก กี้ได้วางยาพิษน้อนอุ้มโดยการให้ผลไม้ที่เจือปนยาพิษ แต่ก็แอบใส่ยาถอนพิษไว้ในผลไม้อีกผลหนึ่ง\n* มีผลไม้ N ผล แต่ละผลมีน้ำหนัก $W_i$\n* ผลไม้ที่เจือปนยาพิษแต่ละผล จะมียาถอนพิษอยู่ในผลไม้อื่นเพียงผลเดียว\n* ถ้าน้อนอุ้มกินผลไม้มีพิษเข้าไป จะต้องกินผลไม้ที่เป็นยาถอนพิษทันที หากผลไม้ที่เป็นยาถอนพิษก็มีพิษอีก ก็ต้องกินยาถอนพิษของผลนั้นต่อไปเรื่อยๆ จนกว่าจะเจอผลไม้ที่ไม่มีพิษ หรือยาถอนพิษอยู่ในผลไม้ที่เคยกินไปแล้ว\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อช่วยน้อนอุ้มเลือกกินผลไม้ลูกแรก ที่จะทำให้ \"น้ำหนักรวม\" ของผลไม้ทั้งหมดที่ต้องกิน (รวมผลแรกและผลไม้ที่เป็นยาถอนพิษทั้งหมด) มีค่าน้อยที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนผลไม้, $1 \\le N \\le 200,000$)\n2.  **N บรรทัดถัดมา** แต่ละบรรทัดมีจำนวนเต็ม $W_i$ (น้ำหนัก) และ $A_i$ (หมายเลขผลไม้ที่เป็นยาถอนพิษ หรือ 0 ถ้าไม่มีพิษ)\n\n**ข้อมูลส่งออก**\n\nน้ำหนักรวมที่น้อยที่สุดที่น้อนอุ้มต้องกิน\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 9 |\n| 10 2 | |\n| 3 3 | |\n| 4 4 | |\n| 5 5 | |\n| 6 0 | |",
        "metadata": {
            "problem_id": "toi19_phitsanulok",
            "problem_name": "toi19_phitsanulok",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits> // Required for numeric_limits\n\n// Represents an edge in the graph with a destination vertex and a weight.\nstruct Edge {\n    int to;\n    int weight;\n};\n\n// Represents a state in the priority queue for Dijkstra's algorithm.\n// It stores the current vertex and the accumulated weight to reach it.\n// The operator< is overloaded to create a min-priority queue based on weight.\nstruct State {\n    int vertex;\n    int weight;\n\n    bool operator<(const State& other) const {\n        return other.weight < weight; // For min-priority queue\n    }\n};\n\nconst int MAX_MASK_NODES = (1 << 19); // Maximum number of mask nodes (2^19)\nconst int MAX_TOTAL_NODES = MAX_MASK_NODES + 90001; // Total nodes including item nodes\n\nstd::vector<Edge> adjacency_list[MAX_TOTAL_NODES]; // Adjacency list for the graph\nint distances[MAX_TOTAL_NODES]; // Stores the shortest distance from the source to each node\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int num_items; // Represents 'n' in the original code, number of item nodes.\n    int num_bits;  // Represents 's' in the original code, number of bits in the mask.\n\n    std::cin >> num_items >> num_bits;\n\n    // Initialize distances to all nodes as infinity.\n    for (int i = 0; i < MAX_MASK_NODES + num_items; ++i) {\n        distances[i] = std::numeric_limits<int>::max();\n    }\n\n    // Create edges between mask nodes.\n    // A mask node 'mask + num_items' (offset by num_items) can transition to\n    // 'mask ^ (1 << i) + num_items' with weight 0, representing flipping the i-th bit.\n    for (int mask = 0; mask < MAX_MASK_NODES; ++mask) {\n        for (int i = 0; i < num_bits; ++i) {\n            int bit_val = (1 << i);\n            if (mask & bit_val) { // If the i-th bit is set in the mask\n                // Add an edge for flipping the bit\n                adjacency_list[mask + num_items].push_back({(mask ^ bit_val) + num_items, 0});\n            }\n        }\n    }\n\n    // Process item specific connections.\n    // Each item has a source mask and a destination mask, with an associated weight.\n    // It also connects the source mask to the item node itself with weight 0.\n    for (int i = 0; i < num_items; ++i) {\n        int item_weight;\n        int source_mask = 0;\n        int destination_mask = 0;\n\n        std::cin >> item_weight;\n\n        for (int j = 0; j < num_bits; ++j) {\n            int bit_status; // -1 for source bit, 1 for destination bit, 0 for don't care\n            std::cin >> bit_status;\n\n            if (bit_status == -1) {\n                source_mask |= (1 << j); // Set j-th bit in source mask\n            }\n            if (bit_status == 1) {\n                destination_mask |= (1 << j); // Set j-th bit in destination mask\n            }\n        }\n\n        // Add an edge from the source mask node to the destination mask node with the item's weight.\n        adjacency_list[source_mask + num_items].push_back({destination_mask + num_items, item_weight});\n        // Add an edge from the source mask node to the item node itself with weight 0.\n        // This allows reaching the item node from its associated source mask.\n        adjacency_list[source_mask + num_items].push_back({i, 0});\n    }\n\n    // Dijkstra's algorithm to find shortest paths.\n    // Start from the \"empty mask\" node, which is at index `num_items` (0 + num_items).\n    distances[num_items] = 0;\n    std::priority_queue<State> pq;\n    pq.push({num_items, 0});\n\n    while (!pq.empty()) {\n        State current_state = pq.top();\n        pq.pop();\n\n        int current_vertex = current_state.vertex;\n        int current_distance = current_state.weight;\n\n        // If we found a shorter path to this vertex already, skip.\n        if (current_distance > distances[current_vertex]) {\n            continue;\n        }\n\n        // Explore neighbors.\n        for (const auto& edge : adjacency_list[current_vertex]) {\n            int neighbor_vertex = edge.to;\n            int edge_weight = edge.weight;\n\n            if (current_distance + edge_weight < distances[neighbor_vertex]) {\n                distances[neighbor_vertex] = current_distance + edge_weight;\n                pq.push({neighbor_vertex, distances[neighbor_vertex]});\n            }\n        }\n    }\n\n    // Find the maximum shortest distance among all item nodes.\n    int max_shortest_distance = 0;\n    for (int i = 0; i < num_items; ++i) {\n        if (distances[i] != std::numeric_limits<int>::max()) {\n            max_shortest_distance = std::max(max_shortest_distance, distances[i]);\n        }\n    }\n\n    std::cout << max_shortest_distance << std::endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**บ้านมุง (Range)**\n\nในการแข่งขันปีนเขา ณ บ้านมุง มีภูเขาหิน N ลูกเรียงกัน การปีนภูเขาลูกที่ i จะได้คะแนน $P_i$ ผู้จัดการแข่งขันต้องการทราบข้อมูลเกี่ยวกับคะแนนในแต่ละช่วงการแข่งขัน\n\n**งานของคุณ**\n\nสำหรับแต่ละช่วงการแข่งขัน (L, R) ที่กำหนดมา Q ครั้ง จงหา:\n1.  คะแนนรวมที่มากที่สุดที่สามารถทำได้จากการปีนภูเขา \"ช่วงย่อยที่ต่อเนื่องกัน\" ภายในช่วง (L, R)\n2.  คะแนนรวมที่มากที่สุดที่สามารถทำได้จากการปีนภูเขา \"ทุกๆ ลูก\" ที่มีคะแนนเป็นบวกภายในช่วง (L, R)\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N และ Q (จำนวนภูเขา, จำนวนคำถาม)\n2.  **บรรทัดที่ 2** คะแนนของภูเขา N ลูก\n3.  **Q บรรทัดถัดมา** แต่ละบรรทัดระบุช่วง L และ R สำหรับแต่ละคำถาม\n\n**ข้อมูลส่งออก**\n\nมี Q บรรทัด แต่ละบรรทัดแสดงคำตอบ 2 ค่าสำหรับแต่ละคำถาม คั่นด้วยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 | 3 21 |\n| 9 13 | 13 13 |\n| 1 12 1 3 1 2 1 | 7 11 |\n| 1 1 3 1 | 2 6 |\n| 7 11 | 3 8 |\n| 1 9 | 6 7 |\n| 2 6 | |\n| 3 8 | |\n| 6 7 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 5 15 |\n| 1 3 | 4 12 |\n| 1 4 3 5 2 | 3 8 |\n| 1 6 | 5 5 |\n| 1 5 | |\n| 1 1000 | |\n| 1 4 | |",
        "metadata": {
            "problem_id": "toi19_range",
            "problem_name": "toi19_range",
            "source": "TOI",
            "tags": [
                "array",
                "prefix-sum",
                "kadane"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm> // Required for std::sort, std::reverse, std::upper_bound\n\n// Represents a mountain with a left coordinate (l), right coordinate (r), and original index.\n// The custom comparison operator allows sorting mountains first by 'l' in ascending order,\n// and then by 'r' in descending order if 'l' values are equal.\nstruct Mountain {\n    int left_coord;\n    int right_coord;\n    int original_index;\n\n    // Custom comparison for sorting:\n    // Sort by left_coord ascending, then by right_coord descending.\n    bool operator<(const Mountain& other) const {\n        if (left_coord != other.left_coord) {\n            return left_coord < other.left_coord;\n        }\n        return right_coord > other.right_coord;\n    }\n};\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int num_mountains;\n    std::cin >> num_mountains;\n\n    std::vector<Mountain> mountains(num_mountains);\n    for (int i = 0; i < num_mountains; ++i) {\n        std::cin >> mountains[i].left_coord >> mountains[i].right_coord;\n        mountains[i].original_index = i;\n    }\n\n    // Sort mountains based on the custom comparison operator.\n    std::sort(mountains.begin(), mountains.end());\n\n    // Reverse the sorted order. This means mountains are now sorted by 'l' descending,\n    // and then by 'r' ascending if 'l' values are equal.\n    std::reverse(mountains.begin(), mountains.end());\n\n    std::vector<int> longest_non_decreasing_subsequence_tails; // Stores the tails of LNDS of increasing lengths\n    std::vector<int> result_lnds_lengths(num_mountains); // Stores the LNDS length for each original mountain\n    int max_overall_lnds_length = 0;\n\n    // Iterate through the sorted (and reversed) mountains to find the LNDS.\n    for (int i = 0; i < num_mountains; ++i) {\n        int current_right_coord = mountains[i].right_coord;\n\n        // Find the first element in 'longest_non_decreasing_subsequence_tails' that is strictly greater than 'current_right_coord'.\n        // This is a key step in finding LNDS in O(N log N) time.\n        auto it = std::upper_bound(longest_non_decreasing_subsequence_tails.begin(),\n                                   longest_non_decreasing_subsequence_tails.end(),\n                                   current_right_coord);\n\n        if (it == longest_non_decreasing_subsequence_tails.end()) {\n            // If 'current_right_coord' is greater than all elements in 'longest_non_decreasing_subsequence_tails',\n            // it extends the longest non-decreasing subsequence found so far.\n            longest_non_decreasing_subsequence_tails.push_back(current_right_coord);\n            result_lnds_lengths[mountains[i].original_index] = longest_non_decreasing_subsequence_tails.size();\n        } else {\n            // Otherwise, replace the found element with 'current_right_coord'.\n            // This maintains the property that 'longest_non_decreasing_subsequence_tails' stores\n            // the smallest tail for each possible LNDS length.\n            *it = current_right_coord;\n            result_lnds_lengths[mountains[i].original_index] = std::distance(longest_non_decreasing_subsequence_tails.begin(), it) + 1;\n        }\n\n        // Update the maximum overall LNDS length found.\n        max_overall_lnds_length = std::max(max_overall_lnds_length, result_lnds_lengths[mountains[i].original_index]);\n    }\n\n    // Output the maximum LNDS length.\n    std::cout << max_overall_lnds_length << '\\n';\n\n    // Output the LNDS length for each mountain in their original input order.\n    for (int i = 0; i < num_mountains; ++i) {\n        std::cout << result_lnds_lengths[i] << ' ';\n    }\n    std::cout << '\\n';\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ก้อนอิฐ (BRICK)**\n\nในตารางเกมขนาด N แถว M คอลัมน์ โดยในตารางมีสิ่งกีดขวางวางเอาไว้ ด้านบนมีก้อนอิฐหลายๆ ก้อนที่กำลังจะหล่นลงมา ตัวอย่างของเกมแสดงดังรูปที่ 1 เป็นตารางขนาด (N=8)×(M=5) ซึ่งสถานะเริ่มต้นของตารางเกมแสดงในรูป 1 (a) และเมื่อเกมได้ประมวลผลแล้ว ซึ่งก็คืออิฐตกจากด้านบนลงสู่ด้านล่าง จะเห็นว่าอิฐจะมีการตกค้างที่สิ่งกีดขวาง และผลลัพธ์หลังจากประมวลเสร็จสิ้นดังแสดงในรูปที่ 1 (b)\n\nจงเขียนโปรแกรมเพื่อรับตารางเกมเริ่มต้นและจำนวนอิฐที่จะตกลงมาในแต่ละคอลัมน์ ให้ประมวลผลก้อนอิฐทุกก้อน โดยมีเงื่อนไขดังนี้ (1) ถ้าก้อนอิฐตกลงมาแล้วพบสิ่งกีดขวางที่อยู่ในตารางเกม ก็จะค้างอยู่ ณ ตำแหน่งที่พบสิ่งกีดขวาง (2) ถ้าก้อนอิฐไม่พบสิ่งกีดขวางจะตกลงมาอยู่แถวล่างสุด เมื่อประมวลผลครบทุกก้อนอิฐให้แสดงผลสถานะของตารางเกม\n\n**ข้อมูลนำเข้า**\n\nบรรทัดแรก จะระบุจำนวนเต็มสองจำนวน N และ M โดยที่ $1\\\\le N\\\\le20$ และ $1\\\\le M\\\\le20$\n\nN บรรทัดถัดไป จะเป็นการระบุตารางเกม โดยในบรรทัดที่ 1+i จะเป็นข้อมูลของตารางเกมแถวที่ i ซึ่งจะระบุเป็นสายอักขระความยาว M ตัวอักขระ ที่มีรูปแบบดังนี้ (1) เครื่องหมายจุด . แทนช่องที่ว่างในตารางเกม และ (2) ตัวอักษร 'O' (ตัวพิมพ์ใหญ่โอ) แทนช่องที่มีสิ่งกีดขวางอยู่\n\nบรรทัดสุดท้าย ประกอบด้วยตัวเลข M ตัวคือ $a\\_{1}, a\\_{2}, a\\_{3}, ... a\\_{M}$ แต่ละตัวคั่นด้วยช่องว่างหนึ่งช่อง ตัวเลข $a\\_{j}$ คือจำนวนก้อนอิฐที่จะตกลงมาในคอลัมน์ที่ j โดยที่ $0\\\\le a\\_{j}\\\\le20$\n\n**ข้อมูลส่งออก**\n\nให้เขียนผลลัพธ์ออกทางแฟ้ม โดยให้ระบุตารางเกมผลลัพธ์ในรูปแบบเดียวกับในแฟ้มข้อมูลนำเข้า ให้ใช้เครื่องหมาย \\# แทนก้อนอิฐอยู่ในตาราง\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า                              | ข้อมูลส่งออก                                                            |\n| :------------------------------- | :------------------------------------------------------------------------- |\n| 8 5                              | .....\\<br\\>..\\#\\#.\\<br\\>.O\\#O.\\<br\\>..O..\\<br\\>.....\\<br\\>.\\#...\\<br\\>.....\\<br\\>\\#....         |\n| .....                            |                                                                            |\n| .....                            |                                                                            |\n| .O.O.                            |                                                                            |\n| ..O..                            |                                                                            |\n| .....                            |                                                                            |\n| .O...                            |                                                                            |\n| .....                            |                                                                            |\n| .....                            |                                                                            |\n| 1 1 3 2 0                        |                                                                            |",
        "metadata": {
            "problem_id": "toi1_brick",
            "problem_name": "toi1_brick",
            "source": "TOI",
            "tags": [
                "array",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include <iostream> // For input/output operations (std::cin, std::cout)\n#include <vector>   // For dynamic arrays (std::vector)\n#include <string>   // For string manipulation (std::string)\n\n// Function to optimize C++ standard stream I/O for faster execution.\n// This is common practice in competitive programming.\nvoid setup_fast_io() {\n    std::ios_base::sync_with_stdio(false); // Untie C++ streams from C standard streams\n    std::cin.tie(nullptr);                  // Untie std::cin from std::cout\n}\n\n// Simulates dropping 'num_blocks' into a specific 'column_index' of the grid.\n// Blocks fall until they hit an 'O' (obstacle) or the bottom of the grid,\n// and then stack up upwards from that point.\nvoid drop_blocks_in_column(int column_index, int num_blocks, int num_rows, std::vector<std::string>& grid) {\n    int drop_stop_row = num_rows; // Initialize to indicate no obstacle found yet (falls to bottom)\n\n    // Find the highest obstacle 'O' or the bottom of the grid in this column.\n    // Blocks will stack just above this point.\n    for (int row = 0; row < num_rows; ++row) {\n        if (grid[row][column_index] == 'O') {\n            drop_stop_row = row; // Found an obstacle, blocks stop before this row\n            break;               // No need to check further down\n        }\n    }\n\n    // Now, starting from the row directly above the drop_stop_row,\n    // place '#' blocks as long as there are blocks to drop and\n    // we haven't gone past the top of the grid.\n    for (int current_row_to_fill = drop_stop_row - 1; \n         current_row_to_fill >= 0 && num_blocks > 0; \n         --current_row_to_fill) {\n        \n        grid[current_row_to_fill][column_index] = '#';\n        num_blocks--; // One block dropped\n    }\n}\n\nint main() {\n    setup_fast_io(); // Enable fast I/O\n\n    int num_rows, num_cols;\n    // Read the dimensions of the grid (N rows, M columns)\n    std::cin >> num_rows >> num_cols;\n\n    // Declare and read the initial state of the grid\n    std::vector<std::string> grid(num_rows);\n    for (int i = 0; i < num_rows; ++i) {\n        std::cin >> grid[i];\n    }\n\n    // For each column, read the number of blocks to drop and simulate the drop\n    for (int j = 0; j < num_cols; ++j) {\n        int blocks_to_drop_in_this_column;\n        std::cin >> blocks_to_drop_in_this_column;\n        // Call our dedicated function to handle dropping for this column\n        drop_blocks_in_column(j, blocks_to_drop_in_this_column, num_rows, grid);\n    }\n\n    // Print the final state of the grid after all blocks have been dropped\n    for (int i = 0; i < num_rows; ++i) {\n        std::cout << grid[i] << '\\n';\n    }\n\n    return 0; // Indicate successful execution\n}"
        }
    },
    {
        "page_content": "**โซ่คำ (Word Chain)**\n\nโซ่คำคือลำดับของคำที่มีจำนวนอักขระเท่ากันและแต่ละคำที่มีลำดับติดกันจะต้องมีตำแหน่งที่มีตัวอักขระต่างกันไม่เกินสองตำแหน่ง เช่น HEAD และ HEAP จะต่างกันตำแหน่งเดียวคือ D และ P ในตำแหน่งตัวอักขระที่ 4 ของคำ ในขณะที่ REAR กับ BAER จะมีตำแหน่งต่างกัน 3 ตำแหน่ง คือ ตำแหน่งที่ 1 (R กับ B) ตำแหน่งที่ 2 (E และ A) และ ตำแหน่งที่ 3 (A และ E)\n\nตัวอย่างของโซ่คำที่ต่อเนื่องได้แก่ HEAD HEAP LEAP TEAR REAR และ EGG EAG GAE GAP TAP TIN ตัวอย่างของโซ่คำที่ขาดได้แก่ LEAP TEAR REAR BAER BAET BEEP ซึ่งจะขาดที่ คำว่า BAER\n\nให้ชุดของโซ่คำมาชุดหนึ่ง จงเขียนโปรแกรมเพื่อหาคำสุดท้ายในโซ่คำ ก่อนที่โซ่คำจะขาด\n\n**ข้อมูลนำเข้า**\n\nอ่านข้อมูลจากแฟ้ม\n\nบรรทัดแรก เก็บจำนวนเต็ม L แทนจำนวนตัวอักษรของแต่ละคำ โดยที่ $3\\le L\\le1000$\n\nบรรทัดที่สอง เก็บจำนวนเต็ม N แทนจำนวนคำทั้งหมดในแฟ้มข้อมูล โดยที่ $1\\le N\\le30000$\n\nบรรทัดที่ 3.. $(N+2)$ เก็บลำดับของคำที่มีจำนวนตัวอักขระ L ตัว แต่ละบรรทัดเก็บคำที่เขียนด้วยตัวอักษร ('A' ถึง 'Z') ที่เป็นตัวพิมพ์ใหญ่\n\n**ข้อมูลส่งออก**\n\nแฟ้มผลลัพธ์ มี 1 บรรทัด เก็บคำสุดท้ายของโซ่คำชุดแรก\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n|---|---|\n| 4 | REAR |\n| 12 | |\n| HEAD | |\n| HEAP | |\n| LEAP | |\n| TEAR | |\n| REAR | |\n| BAER | |\n| BAET | |\n| BEEP | |\n| JEEP | |\n| JOIP | |\n| JEIP | |\n| ΑΕΙΟ | |",
        "metadata": {
            "problem_id": "toi1_chain",
            "problem_name": "toi1_chain",
            "source": "TOI",
            "tags": [
                "string",
                "graph",
                "bfs"
            ],
            "solution_code": "#include <iostream> // For standard input/output operations (cin, cout)\n#include <vector>   // For std::vector\n#include <string>   // For std::string\n\nbool areStringsChainCompatible(const std::string& str1, const std::string& str2, int length) {\n    int differing_char_count = 0;\n    for (int i = 0; i < length; ++i) {\n        if (str1[i] != str2[i]) {\n            differing_char_count++;\n        }\n    }\n\n    // A chain is formed if there are less than 3 differing characters.\n    return differing_char_count < 3;\n}\n\nint main() {\n    // Optimize C++ standard streams for faster input/output.\n    // This is a common competitive programming optimization.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int string_length; // Denotes L: the length of each string.\n    int num_strings;   // Denotes N: the total number of strings.\n    std::cin >> string_length >> num_strings;\n\n    // Store all input strings in a vector.\n    std::vector<std::string> all_input_strings(num_strings);\n    for (int i = 0; i < num_strings; ++i) {\n        std::cin >> all_input_strings[i];\n    }\n\n    // Initialize the 'last valid string in a chain' to the last string provided.\n    // This variable will hold the answer.\n    std::string final_answer_string = all_input_strings[num_strings - 1];\n\n    // Iterate through the strings from the first to the second-to-last,\n    // checking if each pair forms a valid chain.\n    for (int i = 0; i < num_strings - 1; ++i) {\n        // If the current string and the next string are NOT chain compatible,\n        // it means the chain breaks at 'inputs[i]'.\n        // In this case, 'inputs[i]' is the last string that completes a valid chain\n        // segment starting from the beginning.\n        if (!areStringsChainCompatible(all_input_strings[i], all_input_strings[i + 1], string_length)) {\n            final_answer_string = all_input_strings[i];\n            break; // The chain is broken, so we found our answer and can stop.\n        }\n    }\n\n    // Output the determined answer string.\n    std::cout << final_answer_string << '\\n';\n\n    return 0; // Indicate successful program execution.\n}"
        }
    },
    {
        "page_content": "นี่คือรายละเอียดของโจทย์ \"เลขนักเก็ต (Nugget Number)\" โดยไม่มีการอ้างอิง:\n\n**เลขนักเก็ต (Nugget Number)**\n\nร้านฟาสต์ฟู้ดแห่งหนึ่งขายนักเก็ตเป็นกล่อง มีกล่องนักเก็ตอยู่ 3 ขนาด คือ เล็ก, กลาง, และใหญ่ ใส่นักเก็ตจำนวน 6, 9, และ 20 ชิ้นตามลำดับ\n\nเลขนักเก็ตคือจำนวนเต็มบวกที่เกิดจากผลรวมของจำนวนนักเก็ตในกล่องขนาดต่างๆ เช่น เลข 6 เป็นเลขนักเก็ต เพราะเป็นจำนวนนักเก็ตในกล่องเล็ก, เลข 12 เป็นเลขนักเก็ตเพราะเกิดจากการรวมกันของจำนวนนักเก็ตในกล่องเล็กสองกล่อง, เลข 15 เป็นเลขนักเก็ตเพราะเกิดจากการรวมกันของจำนวนนักเก็ตในกล่องเล็กหนึ่งกล่องและกล่องกลางหนึ่งกล่อง เป็นต้น เลข 4 และ 10 ไม่เป็นเลขนักเก็ตเพราะเลขดังกล่าวไม่สามารถเกิดจากการรวมกันของจำนวนนักเก็ตในกล่องขนาดใดๆ ได้\n\nจงหาเลขนักเก็ตที่มีค่าน้อยกว่าหรือเท่ากับค่า n\n\n**ข้อมูลนำเข้า**\n\nรับค่า n ที่เป็นจำนวนเต็ม จาก standard input โดยที่ $1\\le n\\le100$\n\n**ข้อมูลส่งออก**\n\nผลลัพธ์จะส่งออกไปยัง standard output โดยพิมพ์เลขนักเก็ตที่น้อยกว่าหรือเท่ากับ n โดยเรียงค่าจากน้อยไปหามาก พิมพ์บรรทัดละหนึ่งตัวเลข ถ้าไม่มีเลขนักเก็ตที่น้อยกว่าหรือเท่ากับ n ให้พิมพ์คำว่า no\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n|---|---|\n| 15 | 6 |\n| | 9 |\n| | 12 |\n| | 15 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n|---|---|\n| 4 | no |",
        "metadata": {
            "problem_id": "toi1_nugget",
            "problem_name": "toi1_nugget",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "brute-force",
                "implementation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <numeric> // For std::iota if needed, not strictly for this code\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin from cout and prevents synchronization with C's stdio.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n; // Read the upper limit N\n\n    // dp[i] will be true if 'i' can be formed as a sum of 6, 9, or 20.\n    // The size 110 is chosen as a common upper bound, assuming N will not exceed this.\n    // It should ideally be n + max_denomination to prevent out-of-bounds access\n    // when adding the denominations. For safety, a slightly larger size than n\n    // is used here, or dynamic resizing could be considered for very large N.\n    std::vector<bool> dp(110, false);\n\n    // Initialize base cases: these exact values can be formed.\n    dp[6] = true;\n    dp[9] = true;\n    dp[20] = true;\n\n    // Define the denominations available.\n    // These are the values that can be added to existing sums.\n    int denominations[] = {6, 9, 20};\n    int num_denominations = sizeof(denominations) / sizeof(denominations[0]);\n\n    // Handle edge case: if N is too small, no valid sums can be formed.\n    // The smallest possible sum is 6.\n    if (n < 6) {\n        std::cout << \"no\\n\";\n        return 0; // Exit since no numbers can be printed.\n    }\n\n    // Dynamic programming loop:\n    // Iterate from 0 up to N to determine which sums are possible.\n    for (int i = 0; i <= n; ++i) {\n        // If 'i' can be formed (i.e., dp[i] is true), then:\n        if (dp[i]) {\n            // Print 'i' as it is a valid sum.\n            std::cout << i << '\\n';\n\n            // From 'i', we can form new sums by adding each denomination.\n            // Mark these new sums as possible.\n            for (int j = 0; j < num_denominations; ++j) {\n                // Ensure we don't go out of bounds of the dp array.\n                // The size of dp array is 110, so any i + denomination[j]\n                // that exceeds 109 should not be accessed.\n                if (i + denominations[j] < dp.size()) {\n                    dp[i + denominations[j]] = true;\n                }\n            }\n        }\n    }\n\n    return 0; // Indicate successful execution\n}"
        }
    },
    {
        "page_content": "**ลายผ้าไหม**\n\nโรงงานทอผ้าไหม ได้รับยอดสั่งซื้อจากต่างประเทศเพิ่มมากขึ้นทำให้ไม่สามารถทำการผลิตลายผ้าไหมตามความต้องการของผู้สั่งซื้อได้ ทางโรงงานได้นำระบบคอมพิวเตอร์เข้ามาช่วยในการออกแบบลายผ้า ทั้งนี้ให้นักออกแบบลายผ้าออกแบบลายผ้าเป็นตัวเลขและบันทึกเก็บในแฟ้มเพื่อเป็นข้อมูลนำเข้า และโปรแกรมจะทำการอ่านข้อมูลตัวเลขจากแฟ้มดังกล่าวและนำมาแปลรหัสเป็นลายผ้าตามรายละเอียดในข้อมูลนำเข้า และเก็บผลในแฟ้มผลลัพธ์\nโดยลายผ้ามีความกว้าง 70 คอลัมน์และมีความยาวไม่เกิน 50000 แถว\n\n**ข้อมูลนำเข้า**\n\nรับข้อมูลจากแฟ้มข้อมูลนำเข้าโดย\n\nบรรทัดแรก\nจะระบุจำนวนเต็มหนึ่งจำนวน N ($1 \\le N \\le 50000$) แสดงจำนวนแถวของข้อมูลลายผ้า\n\nN บรรทัดถัดไป\nแต่ละบรรทัด จะเป็นการระบุลายผ้าโดยมีตัวเลขจำนวนเต็มสามจำนวนคั่นด้วยช่องว่างหนึ่งช่อง คือ P, Q และ R ตามลำดับ เมื่อ\n* P คือตำแหน่งแถว โดยที่ $1 \\le P \\le N$\n* Q คือตำแหน่งคอลัมน์ที่เริ่มลายผ้า โดยที่ $1 \\le Q \\le 70$\n* R คือจำนวนคอลัมน์ที่มีลายผ้าในแถวนั้น โดยที่ $1 \\le R \\le 30$\n\nโดยแต่ละแถวของลายผ้าสามารถมีลายที่ต่อเนื่องกันได้มากกว่าหนึ่งชุด\n\n**ผลลัพธ์**\n\nให้เขียนผลลัพธ์ออกไปยังแฟ้มผลลัพธ์ โดยให้ระบุเครื่องหมาย 'x' (ตัวเอ็กซ์เล็ก) แทนตำแหน่งที่ลายปรากฏ\nและระบุเครื่องหมาย ๐ (ตัวโอเล็ก) แทนตำแหน่งที่ไม่มีลายผ้า\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า                              | ข้อมูลส่งออก                                                            |\n| ------------------------------- | ------------------------------------------------------------------------- |\n| 4                                | xxxxxxxxxxoooooooooooooooooooooooooooooooooooooooooooooooooooooooooo     |\n| 1 1 10                           | ooxxxxxxxxxooooooooooooxxooooooooooooooooooooooooooooooooooooooooo     |\n| 2 3 9                            | oooooxxxxxxxxxxxxxxxxxxxxxxxxxoooooooooooooooooooooooooooooooooooo     |\n| 3 5 25                           | oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo     |\n| 2 20 2                           |                                                                            |",
        "metadata": {
            "problem_id": "toi1_pattern",
            "problem_name": "toi1_pattern",
            "source": "TOI",
            "tags": [
                "implementation",
                "parsing",
                "array"
            ],
            "solution_code": "#include <iostream>   // For input/output operations (cin, cout)\n#include <vector>     // For std::vector\n#include <algorithm>  // For std::max\n#include <climits>    // For INT_MIN\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin from cout and prevents synchronization with C's stdio.\n    std::cin.tie(nullptr)->sync_with_stdio(false);\n\n    int num_patterns;\n    std::cin >> num_patterns; // Read the number of patterns/rows to process\n\n    // 'max_row_index' keeps track of the maximum row index that has been modified.\n    // This is used to determine how many rows to print at the end.\n    int max_row_index = INT_MIN;\n\n    // 'pattern_grid' is a 2D vector (grid) representing the patterns.\n    // It's initialized with 'o' characters.\n    // 'n' (num_patterns) determines the number of rows initially,\n    // and 70 is a fixed width for each row.\n    std::vector<std::vector<char>> pattern_grid(num_patterns, std::vector<char>(70, 'o'));\n\n    // Loop through each input pattern description.\n    for (int i = 0; i < num_patterns; ++i) {\n        int row_idx, start_col_idx, length;\n        std::cin >> row_idx >> start_col_idx >> length; // Read pattern details\n\n        // Adjust to 0-based indexing for row and column.\n        row_idx--;\n        start_col_idx--;\n\n        // Update the maximum row index encountered.\n        max_row_index = std::max(max_row_index, row_idx);\n\n        // Mark 'x' characters in the pattern_grid based on the input.\n        // 'length' specifies how many 'x's to place starting from 'start_col_idx'.\n        while (length--) {\n            // Ensure we don't write beyond the fixed width of the grid (70 columns).\n            if (start_col_idx < 70) {\n                pattern_grid[row_idx][start_col_idx] = 'x';\n                start_col_idx++; // Move to the next column for the next 'x'\n            } else {\n                break; // Stop if we exceed the grid width\n            }\n        }\n    }\n\n    // Print the modified pattern grid.\n    // Only print rows up to and including 'max_row_index'.\n    for (int i = 0; i <= max_row_index; ++i) {\n        // Iterate through each character in the current row and print it.\n        for (char cell_char : pattern_grid[i]) {\n            std::cout << cell_char;\n        }\n        std::cout << \"\\n\"; // Move to the next line after printing a row.\n    }\n\n    return 0; // Indicate successful execution\n}"
        }
    },
    {
        "page_content": "**ถาดอาหาร (PLATE)**\n\nโรงเรียนประจำแห่งหนึ่ง นักเรียนจะต้องเข้าแถวเพื่อรับถาดอาหารกลางวันตั้งแต่เวลา 12:00 น. ของทุกวัน คุณครูจะให้นักเรียนทุกชั้นเข้าแถวเดียวกัน โดยมีระเบียบในการเข้าแถวอยู่ดังนี้\n\nเมื่อเริ่มต้น นักเรียนคนใดมาก่อน คุณครูจะให้ยืนที่หัวแถว และนักเรียนคนที่จะมาเข้าแถวคนต่อไป คุณครูจะสำรวจตำแหน่งของนักเรียน โดยเริ่มต้นจากหัวแถว และจะแทรกนักเรียนคนนั้นเข้าไปในตำแหน่งต่อจากคนสุดท้ายของนักเรียนในชั้นเรียนเดียวกัน แต่ถ้าไม่มีนักเรียนในชั้นเดียวกันอยู่ในแถว คุณครูจะให้นักเรียนคนนั้นไปต่อที่ท้ายแถว\n\nการออกจากแถวเพื่อไปรับถาดอาหาร นักเรียนที่อยู่หัวแถวที่ได้ออกจากแถวก่อน และให้แสดงเลขประจำตัว\nนักเรียนที่ได้รับถาดอาหารแล้วไม่สามารถกลับเข้ามาในแถวได้อีก\n\nทั้งนี้คุณครูจะทราบเลขประจำตัวและชั้นเรียนของนักเรียนทุกคนอยู่แล้ว และนักเรียนทุกคนจะมีเลขประจำตัวไม่ซ้ำกัน นักเรียนบางคนอาจไม่ได้ถูกเรียกมาเข้าแถว และ นักเรียนบางคนอาจจะไม่ได้ออกจากแถว\n\nจงเขียนโปรแกรมเพื่อจัดแถวเข้ารับถาดอาหารตามระเบียบของโรงเรียนแห่งนี้ แสดงลำดับการรับถาดอาหารของนักเรียน กรณีที่ไม่มีนักเรียนในแถวให้เขียนข้อความว่า “empty” และ ให้แสดงเลขประจำตัว นักเรียนที่ได้ออกจากแถว\n\n**ข้อมูลนำเข้า**\n\nบรรทัดแรกมีจำนวนเต็มสองตัว $N_{c}$ และ $N_{s}$ แทนจำนวนชั้นเรียนและจำนวนนักเรียนตามลำดับ โดยที่ $1\\le N_{c}\\le10$ และ $1\\le N_{s}\\le1000$ ตัวเลขทั้งสองถูกคั่นด้วยช่องว่างหนึ่งช่อง\n\nจากนั้นอีก $N_{s}$ บรรทัดเก็บรายละเอียดของนักเรียนแต่ละคนด้วยจำนวนเต็มสองค่าคั่นด้วยช่องว่างหนึ่งช่อง คือ c และ s ซึ่งแทน หมายเลขชั้นเรียนและเลขประจำตัวของนักเรียนตามลำดับ โดยที่ $1\\le c\\le N_{c}$ และ $1\\le s\\le10000$\n\nการมาเข้าแถวและการนำนักเรียนออกจากหัวแถวเพื่อไปรับถาดอาหาร แต่ละบรรทัดจะมีรูปแบบคำสั่ง ดังต่อไปนี้\n* E id\nเป็นการนำนักเรียนที่มีเลขประจำตัว id มาเข้าแถว\n* D\nเป็นการนำนักเรียนที่อยู่ที่หัวแถวออกจากแถว\n* X\nเป็นการระบุว่าเป็นคำสั่งสุดท้าย\n\n**ข้อมูลส่งออก**\n\nแต่ละบรรทัดแสดงเลขประจำตัวนักเรียนที่ถูกนำออกจากแถวเพื่อรับถาดอาหารตามลำดับ โดยบรรทัดสุดท้ายให้ใส่จำนวนเต็มศูนย์\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า                              | ข้อมูลส่งออก                                                            |\n| :------------------------------- | :------------------------------------------------------------------------- |\n| 2 6                              | 41                                                                         |\n| 1 41                             | 201                                                                        |\n| 1 42                             | 202                                                                        |\n| 1 43                             | 203                                                                        |\n| 2 201                            | 42                                                                         |\n| 2 202                            | 0                                                                          |\n| 2 203                            |                                                                            |\n| E 41                             |                                                                            |\n| E 201                            |                                                                            |\n| D                                |                                                                            |\n| E 202                            |                                                                            |\n| E 42                             |                                                                            |\n| E 43                             |                                                                            |\n| D                                |                                                                            |\n| E 203                            |                                                                            |\n| D                                |                                                                            |\n| D                                |                                                                            |\n| D                                |                                                                            |\n| X                                |                                                                            |\n",
        "metadata": {
            "problem_id": "toi1_plate",
            "problem_name": "toi1_plate",
            "source": "TOI",
            "tags": [
                "implementation",
                "queue"
            ],
            "solution_code": "#include <iostream>  // Required for input/output operations (cin, cout)\n#include <vector>    // Required for std::vector (though not directly used after refactor, it's good practice for dynamic arrays)\n#include <queue>     // Required for std::queue\n#include <map>       // Required for std::map, used as an alternative to array for class ID to student ID mapping\n\n// Declare global arrays and queues.\n// Global variables are zero-initialized by default.\n// 'student_class_map' maps student ID to class ID. Assuming student IDs are within reasonable bounds.\n// Size 10010 implies student IDs up to 10009.\nint student_class_map[10010];\n\n// 'class_student_count' stores the number of students currently in the queue for each class.\n// Size 11 implies class IDs from 0 to 10.\nint class_student_count[11];\n\n// 'class_order_queue' maintains the order in which classes have students waiting.\n// When a student from a new class enters, that class ID is added to this queue.\nstd::queue<int> class_order_queue;\n\n// 'student_queues_by_class' is an array of queues, where each queue holds\n// the student IDs for a specific class.\nstd::queue<int> student_queues_by_class[11];\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin from cout and prevents synchronization with C's stdio.\n    std::cin.tie(0)->sync_with_stdio(0);\n\n    int num_classes, num_students_info;\n    std::cin >> num_classes >> num_students_info; // Read the number of classes and initial student info entries\n\n    // Read student information (class ID and student ID) and populate the map.\n    // Student IDs are assumed to start from 1.\n    for (int i = 1; i <= num_students_info; ++i) {\n        int class_id, student_id;\n        std::cin >> class_id >> student_id;\n        student_class_map[student_id] = class_id;\n    }\n\n    char command_char;\n    // Main loop to process commands: 'E' (enqueue), 'D' (dequeue), or 'X' (exit).\n    // The loop continues as long as the input character 'x' is not 'X'.\n    while (std::cin >> command_char, command_char != 'X') {\n        if (command_char == 'E') {\n            // Enqueue command: add a student to the queue system.\n            int student_id;\n            std::cin >> student_id;\n\n            int class_of_student = student_class_map[student_id];\n\n            // If this class previously had no students in the queue, add its ID\n            // to the 'class_order_queue' to mark its presence.\n            if (class_student_count[class_of_student] == 0) {\n                class_order_queue.push(class_of_student);\n            }\n\n            // Add the student to their specific class queue.\n            student_queues_by_class[class_of_student].push(student_id);\n            // Increment the count of students for this class.\n            class_student_count[class_of_student]++;\n        } else if (command_char == 'D') {\n            // Dequeue command: remove a student from the front of the overall queue.\n            if (class_order_queue.empty()) {\n                // If no classes are in the 'class_order_queue', then the entire system is empty.\n                std::cout << \"empty\\n\"; // Print \"empty\" and a newline.\n            } else {\n                // Get the class ID of the next student to be served (front of the class_order_queue).\n                int current_class_to_serve = class_order_queue.front();\n\n                // Get the student ID from the front of that class's specific queue.\n                std::cout << student_queues_by_class[current_class_to_serve].front() << '\\n';\n\n                // Remove the student from their class-specific queue.\n                student_queues_by_class[current_class_to_serve].pop();\n\n                // Decrement the count of students for this class.\n                class_student_count[current_class_to_serve]--;\n\n                // If this class's queue is now empty, remove its ID from the 'class_order_queue'.\n                if (student_queues_by_class[current_class_to_serve].empty()) {\n                    class_order_queue.pop();\n                }\n            }\n        }\n    }\n\n    // After the loop (when 'X' is encountered), print '0' as per problem requirements.\n    std::cout << '0';\n\n    return 0; // Indicate successful program termination\n}"
        }
    },
    {
        "page_content": "**เลขโรมัน (Roman)**\n\nเลขโรมันมักจะถูกใช้เป็นเลขหน้าในบทนำของหนังสือก่อนที่จะเริ่มเข้าสู่เนื้อหา โดยสัญลักษณ์เลขโรมันที่ใช้แทนจำนวนเต็มฐานสิบที่มีค่าไม่เกิน 100 ประกอบด้วย 'i' 'v' 'x' 'l' และ 'c' ซึ่งใช้แทนจำนวนเต็มค่า 1 5 10 50 และ 100 ตามลำดับ ในการเขียนแทนจำนวนเต็มฐานสิบแต่ละจำนวนในกลุ่มดังกล่าวด้วยเลขโรมัน เราสามารถทำได้โดยการเรียงลำดับสัญลักษณ์เลขโรมันแต่ละตัวต่อเนื่องกันจากซ้ายไปขวา โดยมีเงื่อนไข คือ 1) สามารถวางสัญลักษณ์ที่ใช้แทนค่า 1 และ 10 ต่อเนื่องกันได้ไม่เกิน 3 ตัว 2) ไม่สามารถวางสัญลักษณ์ที่ใช้แทนค่า 5 และ 50 ต่อเนื่องกันได้ และ 3) สัญลักษณ์ที่มีค่ามากกว่าจะอยู่ด้านซ้ายของสัญลักษณ์ที่มีค่าน้อยกว่าเสมอ เช่น 8 จะเขียนแทนด้วย viii (มีความหมายเท่ากับ $5+1+1+1)$ 17 จะเขียนแทนด้วย xvii (มีความหมายเท่ากับ $10+5+1+1)$ และ 73 จะเขียนแทนด้วย lxxiii (มีความหมายเท่ากับ $50+10+10+1+1+1)$\n\nข้อยกเว้นประการหนึ่งของการแทนเลขโรมันที่มีค่าน้อยกว่า 400 คือ ในการแทนค่า 4 และ 9 ในหลักหน่วย และการแทนค่า 40 และ 90 ในหลักสิบ จะวางสัญลักษณ์ที่มีค่าน้อยกว่าไว้ด้านซ้ายของสัญลักษณ์ที่มีค่ามากกว่า เช่น 4 จะเขียนแทนด้วย iv (มีความหมายเท่ากับ $-1+5)$ 9 จะเขียนแทนด้วย ix (มีความหมายเท่ากับ $-1+10)$ 40 จะเขียนแทนด้วย xl (มีความหมายเท่ากับ $-10+50)$ และ 90 จะเขียนแทนด้วย xc (มีความหมายเท่ากับ $-10+100)$ เป็นต้น ทำนองเดียวกันตามกฎนี้จะทำให้ 24 39 44 49 94 เขียนแทนด้วยเลขโรมันได้เป็น xxiv xxxix xliv xlix และ xciv ตามลำดับ\n\nกำหนดให้หนังสือเล่มหนึ่งมีจำนวนหน้าในบทนำทั้งหมด d หน้า โดยที่ $1\\le d<400$ จงเขียนโปรแกรมเพื่อนับจำนวนสัญลักษณ์ 'i' 'v' 'x' 'l' และ 'c' ที่ใช้แทนหมายเลขหน้าในบทนำของหนังสือเล่มดังกล่าว\nตัวอย่างเช่น ถ้าหนังสือมีจำนวนหน้าในบทนำ 5 หน้า นั่นคือประกอบด้วยหน้าหมายเลข i ii iii iv และ v ดังนั้น หนังสือเล่มนี้จะมีสัญลักษณ์ 'i' จำนวน 7 ตัว, 'v' จำนวน 2 ตัว, 'x' จำนวน 0 ตัว, 'l' จำนวน 0 ตัว และ 'c' จำนวน 0 ตัว เป็นต้น\n\n**ข้อมูลนำเข้า**\n\nข้อมูลมีเพียงบรรทัดเดียวอ่านมาจาก standard input ซึ่งมีจำนวนเต็มบวก d แทนจำนวนหน้าในบทนำของหนังสือ\n\n**ข้อมูลส่งออก**\n\nผลลัพธ์จะส่งออกไปยัง standard output โดยข้อมูลมีอยู่หนึ่งบรรทัด ประกอบด้วยจำนวนเต็มห้าตัวคั่นด้วยช่องว่างหนึ่งช่อง โดยตัวแรกถึงตัวที่ห้า จะแทนจำนวนของสัญลักษณ์โรมัน 'i' 'v' 'x' 'l' และ 'c' ตามลำดับ\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า                              | ข้อมูลส่งออก                                                            |\n| :------------------------------- | :------------------------------------------------------------------------- |\n| 5                                | 7 2 0 0 0                                                                  |",
        "metadata": {
            "problem_id": "toi1_roman",
            "problem_name": "toi1_roman",
            "source": "TOI",
            "tags": [
                "string",
                "math"
            ],
            "solution_code": "#include <iostream> // For input/output operations (cin, cout)\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin from cout and prevents synchronization with C's stdio.\n    std::cin.tie(nullptr)->sync_with_stdio(false);\n\n    int limit;\n    std::cin >> limit; // Read the upper limit 'a' (renamed to 'limit' for clarity)\n\n    // Initialize counts for each Roman numeral character.\n    // I: 1, V: 5, X: 10, L: 50, C: 100\n    int count_I = 0;\n    int count_V = 0;\n    int count_X = 0;\n    int count_L = 0;\n    int count_C = 0;\n\n    // This loop iterates from the given 'limit' down to 1.\n    // The variable 'b' (renamed to 'current_number') holds the number\n    // for which Roman numeral characters are currently being counted.\n    for (int i = 0; i < limit; ++i) {\n        // Calculate the current number to convert.\n        // If limit is 5, i will be 0, 1, 2, 3, 4.\n        // current_number will be 5, 4, 3, 2, 1.\n        int current_number = (limit - i);\n\n        // Convert 'current_number' into its Roman numeral components\n        // and add to the respective counts.\n        // This process essentially \"peels off\" the largest possible Roman numeral\n        // values from 'current_number' until it becomes 0.\n\n        // Handle C (100) and special case XC (90)\n        if (current_number >= 100) {\n            count_C += (current_number / 100);\n            current_number %= 100;\n        }\n        if (current_number >= 90) { // Special case: XC (90)\n            count_C += 1;\n            count_X += 1;\n            current_number -= 90;\n        }\n\n        // Handle L (50) and special case XL (40)\n        if (current_number >= 50) {\n            count_L += (current_number / 50);\n            current_number %= 50;\n        }\n        if (current_number >= 40) { // Special case: XL (40)\n            count_L += 1;\n            count_X += 1;\n            current_number -= 40;\n        }\n\n        // Handle X (10) and special case IX (9)\n        if (current_number >= 10) {\n            count_X += (current_number / 10);\n            current_number %= 10;\n        }\n        if (current_number >= 9) { // Special case: IX (9)\n            count_X += 1;\n            count_I += 1;\n            current_number -= 9;\n        }\n\n        // Handle V (5) and special case IV (4)\n        if (current_number >= 5) {\n            count_V += (current_number / 5);\n            current_number %= 5;\n        }\n        if (current_number >= 4) { // Special case: IV (4)\n            count_V += 1;\n            count_I += 1;\n            current_number -= 4;\n        }\n\n        // Handle I (1)\n        if (current_number >= 1) {\n            count_I += (current_number / 1);\n            // current_number %= 1; // This line is technically correct but redundant as current_number will become 0\n        }\n    }\n\n    // Print the total counts of each Roman numeral character, separated by spaces.\n    std::cout << count_I << ' ' << count_V << ' ' << count_X << ' ' << count_L << ' ' << count_C << std::endl;\n\n    return 0; // Indicate successful program termination\n}"
        }
    },
    {
        "page_content": "**สายอักขระของเลขโดดฐานสอง (Bit String)**\n\nในการส่งข้อมูลดิจิทัล คุณภาพของสายอักขระของเลขโดดฐานสอง (bit string) ที่ได้รับ จะวัดจาก “ค่าความเสถียร” ซึ่งคำนวณจากค่าความแตกต่างระหว่างค่า bit string ย่อยที่ปรากฏใน bit string ที่ได้รับ กับค่า bit string ย่อยทั้งหมดที่เป็นไปได้\n\nbit string ย่อย คือ bit string ที่มีความยาว k ใด ๆ ที่ปรากฏใน bit string ที่มีความยาว N\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อคำนวณค่าความเสถียรของ bit string ที่มีความยาว N\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** ประกอบด้วยจำนวนเต็มสองจำนวน N และ K โดยที่ $2 \\le K \\le 20$ และ $K \\le N \\le 2,500,000$\n2.  **บรรทัดที่สอง** คือ bit string ที่มีความยาว N\n\n**ข้อมูลส่งออก**\n\nค่าความเสถียรของ bit string ที่ได้รับ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 3 | 2 |\n| 1011010 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 3 | 4 |\n| 0111001011 | |",
        "metadata": {
            "problem_id": "toi20_bit_string",
            "problem_name": "toi20_bit_string",
            "source": "TOI",
            "tags": [
                "string",
                "bit-manipulation",
                "hashing"
            ],
            "solution_code": "#include <iostream>     // For standard input/output operations (cin, cout)\n#include <vector>       // For dynamic arrays (std::vector)\n#include <string>       // For std::string\n#include <limits>       // For std::numeric_limits\n\n// Function to convert a binary string to an integer bitmask.\n// Example: \"101\" -> 5 (binary 101)\nint convertBinaryStringToMask(const std::string& binary_string) {\n    int mask = 0;\n    // Iterate through each character of the string\n    for (char digit_char : binary_string) {\n        // Shift the current mask to the left by 1 (make space for new bit)\n        mask = (mask << 1);\n        // If the character is '1', set the least significant bit\n        if (digit_char == '1') {\n            mask |= 1; // Same as mask = mask | 1\n        }\n        // Alternatively, using (c - '0') directly:\n        // mask = (mask << 1) | (digit_char - '0');\n    }\n    return mask;\n}\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin/cout from C's stdio and speeds up I/O.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr); // Disables synchronization with cout, further speeding up cin.\n\n    int num_elements; // Represents 'N' - the number of bits in the mask (or elements)\n    int num_queries;  // Represents 'Q' - the number of queries to perform\n\n    std::cin >> num_elements >> num_queries;\n\n    // Calculate the total number of possible masks (2^N)\n    int total_masks = 1 << num_elements;\n\n    // Define a constant for negative infinity to represent unreachable or invalid states in DP.\n    // Using `std::numeric_limits<int>::min()` is safer than an arbitrary large negative number.\n    const int NEGATIVE_INFINITY = std::numeric_limits<int>::min();\n\n    // dp[mask] will store the maximum value obtainable for the subset represented by 'mask'.\n    // Initialize all DP states to NEGATIVE_INFINITY.\n    std::vector<int> dp_max_values(total_masks, NEGATIVE_INFINITY);\n\n    // Read initial values for each mask (corresponding to a binary string input).\n    // These are the base cases for the dynamic programming.\n    std::string binary_str;\n    int initial_weight;\n    for (int i = 0; i < total_masks; ++i) {\n        std::cin >> binary_str >> initial_weight;\n        // Convert the binary string to its integer mask representation\n        dp_max_values[convertBinaryStringToMask(binary_str)] = initial_weight;\n    }\n\n    // Dynamic Programming Calculation:\n    // Iterate through all possible masks from 1 up to (total_masks - 1).\n    // Mask 0 (empty set) is typically a base case and doesn't involve transitions from other masks.\n    for (int current_mask = 1; current_mask < total_masks; ++current_mask) {\n        int max_prev_value = NEGATIVE_INFINITY;\n\n        // Transition 1: Consider removing a single '1' bit from the current_mask.\n        // This corresponds to a subproblem where one element is excluded.\n        for (int i = 0; i < num_elements; ++i) {\n            // Check if the i-th bit is set in the current_mask\n            if (current_mask & (1 << i)) {\n                // If set, consider the subproblem formed by flipping/removing this bit.\n                // current_mask ^ (1 << i) effectively unsets the i-th bit.\n                max_prev_value = std::max(max_prev_value, dp_max_values[current_mask ^ (1 << i)]);\n            }\n        }\n\n        // Transition 2: Consider removing a pair of adjacent '1' bits from the current_mask.\n        // This corresponds to a subproblem where two adjacent elements are excluded.\n        // The loop goes up to N-1 because we need two bits (i and i+1).\n        for (int i = 0; i < num_elements - 1; ++i) {\n            // Check if both the i-th and (i+1)-th bits are set.\n            // (current_mask >> i & 3) checks if the last two bits (00, 01, 10, 11)\n            // starting from position 'i' are '11' (binary 3).\n            if (((current_mask >> i) & 3) == 3) {\n                // If both are set, consider the subproblem formed by flipping/removing these two bits.\n                // current_mask ^ (3 << i) effectively unsets bits 'i' and 'i+1'.\n                max_prev_value = std::max(max_prev_value, dp_max_values[current_mask ^ (3 << i)]);\n            }\n        }\n\n        // Update the DP value for current_mask.\n        // If a valid previous state was found (not NEGATIVE_INFINITY),\n        // add the current mask's initial weight to the best previous value.\n        // Otherwise, if no valid previous state could lead to this mask, it remains unreachable.\n        if (max_prev_value != NEGATIVE_INFINITY) {\n            dp_max_values[current_mask] += max_prev_value;\n        } else {\n            // If no valid previous state, this mask's DP value remains unreachable.\n            dp_max_values[current_mask] = NEGATIVE_INFINITY;\n        }\n    }\n\n    // Process queries: For each query, convert the binary string to a mask\n    // and output the precomputed DP value.\n    while (num_queries--) {\n        std::cin >> binary_str;\n        int query_mask = convertBinaryStringToMask(binary_str);\n        std::cout << dp_max_values[query_mask] << '\\n';\n    }\n\n    return 0; // Indicate successful program execution\n}"
        }
    },
    {
        "page_content": "**คู่รักคู่คี่ (Lover)**\n\nคู่รักคู่คี่ต้องการเดินเลือกซื้ออาหารในถนนคนเดินที่มี N ร้านเรียงกัน โดยจะแบ่งการเดินออกเป็น M+1 ช่วง ในแต่ละช่วงจะซื้ออาหารจากร้านค้าตามลำดับแล้วจึงพักทานอาหารที่ซื้อมา\n* แผนการเดินจะระบุด้วยจุดพัก M จุด ($l_1, l_2, ..., l_M$)\n* **ค่าช่วงแพงของคุณคี่:** คือค่าอาหารที่แพงที่สุดในบรรดาอาหาร \"ชิ้นแรก\" ของแต่ละช่วง\n* **ค่าช่วงแพงของคุณคู่:** คือค่าอาหารที่แพงที่สุดในบรรดาอาหาร \"ชิ้นสุดท้าย\" ของแต่ละช่วง\n* ค่าความต่างใจคือ $(ค่าช่วงแพงของคุณคี่ - ค่าอาหารที่ถูกที่สุดในบรรดาอาหารชิ้นแรก)^2 + (ค่าช่วงแพงของคุณคู่ - ค่าอาหารที่ถูกที่สุดในบรรดาอาหารชิ้นสุดท้าย)^2$\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาจำนวนครั้งที่จะพัก M ที่น้อยที่สุด ที่จะทำให้ \"ค่าความต่างใจ\" น้อยกว่าหรือเท่ากับค่าที่กำหนด C\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N, K, และ C\n    * N คือจำนวนร้านค้า ($2 \\le N \\le 200,000$)\n    * K คือจำนวนคำถาม ($1 \\le K \\le 5$)\n    * C คือค่าความต่างใจสูงสุดที่ยอมรับได้ ($0 \\le C \\le 2 \\times 10^{18}$)\n2.  **บรรทัดที่ 2** ราคาอาหาร $x_i$ ของแต่ละร้าน\n3.  **K บรรทัดถัดมา** แต่ละบรรทัดคือค่า C สำหรับแต่ละคำถาม\n\n**ข้อมูลส่งออก**\n\nสำหรับแต่ละคำถาม ให้แสดงค่า M ที่น้อยที่สุด (ถ้าไม่มี ให้ตอบ -1)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 12 6 7 | 2 |\n| 1 3 2 3 5 1 3 6 3 1 4 2 | |\n| 13 23 51 36 31 42 | |",
        "metadata": {
            "problem_id": "toi20_lover",
            "problem_name": "toi20_lover",
            "source": "TOI",
            "tags": [
                "binary-search",
                "brute-force",
                "math"
            ],
            "solution_code": "#include <iostream>\n\n\n#include <algorithm>\n\n\n#include <cstdint>\n\n\n\nconst int INF = 5001;\n\n\nconst int MAXN = 2000005;\n\n\nconst int MAX_SEG = 1000;\n\n\n\nint x[MAXN];\n\n\nint dp[MAXN];\n\n\nint64_t odd_ps[MAXN];\n\n\nint64_t even_ps[MAXN];\n\n\n\nint main() {\n\n\n    std::ios_base::sync_with_stdio(false);\n\n\n    std::cin.tie(nullptr);\n\n\n\n    int N;\n\n\n    int64_t V, W;\n\n\n    std::cin >> N >> V >> W;\n\n\n\n    for (int i = 0; i < N; ++i) std::cin >> x[i];\n\n\n\n    for (int i = 0; i < N; ++i) {\n\n\n        odd_ps[i + 1] = odd_ps[i];\n\n\n        even_ps[i + 1] = even_ps[i];\n\n\n        if (x[i] & 1) odd_ps[i + 1] += x[i];\n\n\n        else even_ps[i + 1] += x[i];\n\n\n    }\n\n\n\n    std::fill(dp, dp + N + 1, INF);\n\n\n    dp[0] = 0;\n\n\n\n    for (int i = 2; i <= N; i += 2) {\n\n\n        int best = INF;\n\n\n        int max_len = std::min(i, MAX_SEG * 2);\n\n\n\n        for (int len = 2; len <= max_len; len += 2) {\n\n\n            int j = i - len;\n\n\n            if (dp[j] == INF) continue;\n\n\n\n            int mid = j + (len >> 1);\n\n\n            int64_t a = odd_ps[mid] - odd_ps[j];\n\n\n            int64_t b = even_ps[i] - even_ps[mid];\n\n\n\n            if (a > V || b > W) continue;\n\n\n\n            best = std::min(best, dp[j] + 1);\n\n\n        }\n\n\n        dp[i] = best;\n\n\n    }\n\n\n\n    std::cout << (dp[N] == INF ? -1 : dp[N]) << '\\n';\n\n\n    return 0;\n\n\n}"
        }
    },
    {
        "page_content": "**ลูกแก้ว (Orbs)**\n\nเครื่องจักรประดิษฐ์สร้อยลูกแก้วทำงานโดยมีลูกแก้ว N ลูกในราง แต่ละลูกมีน้ำหนัก $w_i$\n**ขั้นตอนการทำงาน:**\n1.  เครื่องจักรจะทำงานทั้งหมด K รอบ\n2.  ในแต่ละรอบ จะหยิบลูกแก้วที่หนักเป็นลำดับที่ 1 และ 3 (นับจากน้อยไปมาก) ออกจากราง\n3.  สร้างลูกแก้วใหม่ 2 ลูก:\n    * ลูกแรกมีน้ำหนักเท่ากับ \"ผลต่าง\" ของน้ำหนักลูกแก้วที่หยิบออกมา\n    * ลูกที่สองมีน้ำหนักเท่ากับ \"ค่าเฉลี่ย\" ของน้ำหนักลูกแก้วที่หยิบออกมา (ปัดเศษทิ้ง)\n4.  ใส่ลูกแก้วใหม่ทั้งสองลูกนี้ไปทางขวาสุดของราง\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อแสดงน้ำหนักของลูกแก้วที่เหลืออยู่ในรางหลังจากเครื่องจักรทำงานเสร็จสิ้น โดยเรียงจากน้อยไปมาก\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N และ K (จำนวนลูกแก้วเริ่มต้น, จำนวนรอบ, $3 \\le N \\le 200,000$, $1 \\le K \\le 100,000$)\n2.  **บรรทัดที่ 2** น้ำหนักของลูกแก้ว N ลูก\n\n**ข้อมูลส่งออก**\n\nน้ำหนักของลูกแก้วที่เหลือในราง เรียงจากน้อยไปมาก คั่นด้วยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 3 | 10 20 20 40 50 |\n| 10 20 30 40 50 | |",
        "metadata": {
            "problem_id": "toi20_orbs",
            "problem_name": "toi20_orbs",
            "source": "TOI",
            "tags": [
                "array",
                "sorting",
                "simulation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std ;\nint n , q ;\nlong long arr[100001];\nint main(){\n    ios_base :: sync_with_stdio(0) , cin.tie(0) ;\n    cin >> n >> q ;\n    for(int i = 1 ; i <= n ; i ++ ){\n        cin >> arr[i] ;\n        arr[i] += arr[i - 1] ;\n    }\n    for(int i = n - 1 ; i >= 1 ; i -- ){\n        arr[i] = min(arr[i] , arr[i + 1]);\n    }\n    while(q -- ){\n        int l = 0 , r = n , k ; cin >> k ;\n        while(l < r){\n            int mid = (l + r + 1) >> 1 ;\n            if(arr[mid] <= k)l = mid ;\n            else r = mid - 1 ;\n        }\n        cout << l << '\\n' ;\n    }\n    \n    return 0 ;\n}"
        }
    },
    {
        "page_content": "**เส้นทาง (Route)**\n\nสมหวังได้รับการว่าจ้างให้ออกแบบระบบขนส่งระหว่างจุดสำคัญ N จุดในมหาวิทยาลัยศิลปากร โดยมีรถไฟฟ้า M คัน แต่ละคันมีค่าใช้จ่ายประจำรถ $w_i$ และวิ่งระหว่างจุดสำคัญ 2 จุดที่กำหนดไว้เท่านั้น\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมในฟังก์ชันที่กำหนดให้ เพื่อคำนวณหาค่าใช้จ่ายรวมที่น้อยที่สุดในการเดินทางระหว่างจุด A และ B โดยอาจมีการเปลี่ยนรถระหว่างทางได้ (ผู้เข้าแข่งขันไม่ต้องเขียนส่วนรับข้อมูลและแสดงผลเอง)\n\n**ข้อมูลของฟังก์ชันที่ต้องเขียน**\n\n`long long solve(int N, int M, int A, int B, int *U, int *V, int *W)`\n* N, M: จำนวนจุดสำคัญ, จำนวนรถ\n* A, B: จุดเริ่มต้นและจุดหมาย\n* U, V, W: แถวลำดับของข้อมูลรถแต่ละคัน (U[i], V[i] คือจุดที่รถคันที่ i วิ่งระหว่าง, W[i] คือค่าใช้จ่าย)\n\n**ข้อมูลส่งออก (จากฟังก์ชัน)**\n\nค่าใช้จ่ายรวมที่น้อยที่สุด (หากไปไม่ถึงให้คืนค่า -1)\n\n**ตัวอย่าง**\n(ตัวอย่างนี้แสดงการทำงานภาพรวม ไม่ใช่รูปแบบ Input/Output ของไฟล์โดยตรง)\n* **Input:** N=4, M=5, A=1, B=4, และข้อมูลรถ 5 คัน\n* **Output ที่คาดหวัง:** 11 (เดินทางจาก 1->2 (ค่าใช้จ่าย 5) แล้วต่อรถไป 2->4 (ค่าใช้จ่าย 6))",
        "metadata": {
            "problem_id": "toi20_route",
            "problem_name": "toi20_route",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\n#include \"route.h\" \n\n\nstd::vector<std::pair<int,int>> route(int N, std::vector<int> W){\n\n   std::vector<std::pair<int,int>> edge;\n\n   int cur = W.size()-N+1;\n\n   for(int i = 2; i <= N; i++){\n\n      edge.push_back({1,i});\n\n      for(int j = 2; j < i; j++){\n\n         if(cur == 0) break;\n\n         edge.push_back({j,i});\n\n         cur--;\n\n      }\n\n   }\n\n   return edge;\n\n}\n\n"
        }
    },
    {
        "page_content": "**ประติมากรรม (Sculpture)**\n\nในการสร้างประติมากรรมจากการวางหินซ้อนกัน มีหิน N ก้อน แต่ละก้อนมีน้ำหนัก $w_i$ และสามารถรับน้ำหนักกดทับได้ $L_i$\n**เงื่อนไขการสร้าง:**\n1.  หินแต่ละก้อน (ยกเว้นก้อนล่างสุด) ต้องมีหินก้อนอื่นรองรับอยู่ข้างใต้\n2.  น้ำหนักรวมของหินที่อยู่เหนือก้อนใดๆ ต้องไม่เกินความสามารถในการรับน้ำหนักของก้อนนั้น\n3.  สามารถใช้อุปกรณ์พยุงน้ำหนัก 1 ชิ้น เพื่อช่วยรับน้ำหนักของหินก้อนใดก้อนหนึ่งได้ ทำให้น้ำหนักของหินก้อนนั้นและก้อนที่อยู่เหนือขึ้นไปทั้งหมดไม่ถูกนำมาคิดกับหินที่อยู่ข้างใต้\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหา \"จำนวนหินที่มากที่สุด\" ที่สามารถนำมาสร้างประติมากรรมได้ และ \"จำนวนวิธี\" ที่จะเลือกชุดของหินจำนวนดังกล่าวมาสร้างประติมากรรมได้\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม N (จำนวนหินทั้งหมด, $1 \\le N \\le 100,000$)\n2.  **N บรรทัดถัดมา** แต่ละบรรทัดมี $w_i$ และ $L_i$\n\n**ข้อมูลส่งออก**\n\nมี 2 บรรทัด:\n1.  จำนวนหินที่มากที่สุดที่ใช้สร้างได้\n2.  จำนวนวิธีในการเลือกหินจำนวนดังกล่าว\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 5 |\n| 2 15 | 3 |\n| 4 5 | |\n| 2 3 | |\n| 2 6 | |\n| 7 11 | |\n| 8 10 | |",
        "metadata": {
            "problem_id": "toi20_sculpture",
            "problem_name": "toi20_sculpture",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "recursion",
                "backtracking"
            ],
            "solution_code": "#include <iostream>   // For std::cin, std::cout\n#include <vector>     // For std::vector\n#include <algorithm>  // For std::min, std::max, std::pair\n#include <limits>     // For std::numeric_limits<long long>::max()\n\n// Using a more descriptive alias for long long\nusing ll = long long;\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // Unties cin/cout from C's stdio and speeds up I/O by preventing synchronization.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n; // Number of elements\n    std::cin >> n;\n\n    // 'items' stores pairs of (first_value, second_value) for each item.\n    // The problem context implies these could be 'weight' and 'limit' or similar.\n    std::vector<std::pair<ll, ll>> items(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> items[i].first >> items[i].second;\n    }\n\n    // --- DP Pass 1: Forward DP ---\n    // This DP aims to find properties of prefixes of the array.\n    // `dp_prefix[current_row_idx][j]` stores a minimum sum/value for a segment ending at index `j`.\n    // `count_prefix_segments[j]` stores the maximum number of segments for a prefix ending at `j`.\n    // The `i&1` trick is used for space optimization (only need previous row's DP values).\n    std::vector<std::vector<ll>> dp_prefix(2, std::vector<ll>(n));\n    std::vector<ll> count_prefix_segments(n);\n\n    // Initialize base case for DP_prefix (first row, representing 1 segment).\n    for (int j = 0; j < n; ++j) {\n        dp_prefix[0][j] = items[j].first; // Current item's first value\n        count_prefix_segments[j] = 1;      // One segment so far\n\n        // Maintain minimum prefix sum/value up to `j` (for a single segment).\n        if (j > 0) {\n            dp_prefix[0][j] = std::min(dp_prefix[0][j], dp_prefix[0][j - 1]);\n        }\n    }\n\n    // Iterate for increasing number of segments 'k' (from 1 to n-1).\n    // `k` here represents (number of segments - 1).\n    for (int k = 1; k < n; ++k) {\n        // Initialize current DP row with a very large value (infinity).\n        for (int j = 0; j < n; ++j) {\n            dp_prefix[k & 1][j] = std::numeric_limits<ll>::max();\n        }\n\n        // Iterate through possible ending positions 'j' for the current prefix DP state.\n        for (int j = 1; j < n; ++j) {\n            // Transition: If the previous segment's accumulated value (`dp_prefix[!(k&1)][j-1]`)\n            // satisfies a condition related to the current item's 'second_value'.\n            // This suggests extending a `k-1` segment solution to a `k` segment solution.\n            if (dp_prefix[!(k & 1)][j - 1] <= items[j].second) {\n                // Update current DP state: accumulate value and update segment count.\n                dp_prefix[k & 1][j] = dp_prefix[!(k & 1)][j - 1] + items[j].first;\n                count_prefix_segments[j] = k + 1; // k is 0-indexed, so k+1 segments\n            }\n            // Maintain minimum prefix sum/value up to `j` for `k` segments.\n            // This ensures `dp_prefix[k&1][j]` stores the best value ending at `j` with `k` segments.\n            dp_prefix[k & 1][j] = std::min(dp_prefix[k & 1][j], dp_prefix[k & 1][j - 1]);\n        }\n    }\n\n    // --- DP Pass 2: Backward DP ---\n    // This DP aims to find properties of suffixes of the array.\n    // `dp_suffix[current_row_idx][j]` stores a maximum sum/value for a segment starting at index `j`.\n    // `count_suffix_segments[j]` stores the maximum number of segments for a suffix starting at `j`.\n    std::vector<std::vector<ll>> dp_suffix(2, std::vector<ll>(n));\n    std::vector<ll> count_suffix_segments(n);\n\n    // Initialize base case for DP_suffix (first row, representing 1 segment).\n    for (int j = n - 1; j >= 0; --j) {\n        dp_suffix[0][j] = items[j].second; // Current item's second value\n        count_suffix_segments[j] = 1;       // One segment so far\n\n        // Maintain maximum suffix value up to `j` (for a single segment).\n        if (j < n - 1) {\n            dp_suffix[0][j] = std::max(dp_suffix[0][j], dp_suffix[0][j + 1]);\n        }\n    }\n\n    // Iterate for increasing number of segments 'k' (from 1 to n-1).\n    for (int k = 1; k < n; ++k) {\n        // Initialize current DP row with a very small value (infinity).\n        for (int j = 0; j < n; ++j) {\n            dp_suffix[k & 1][j] = 0; // Or std::numeric_limits<ll>::min() if sums can be negative\n        }\n\n        // Iterate through possible starting positions 'j' for the current suffix DP state.\n        for (int j = n - 2; j >= 0; --j) {\n            // Transition: If the next segment's accumulated value (`dp_suffix[!(k&1)][j+1]`)\n            // satisfies a condition related to the current item's 'first_value'.\n            // This suggests extending a `k-1` segment solution to a `k` segment solution.\n            if (dp_suffix[!(k & 1)][j + 1] >= items[j].first) {\n                // Update current DP state: calculate new value and update segment count.\n                dp_suffix[k & 1][j] = std::min(dp_suffix[!(k & 1)][j + 1] - items[j].first, items[j].second);\n                count_suffix_segments[j] = k + 1;\n            }\n            // Maintain maximum suffix value from `j` for `k` segments.\n            dp_suffix[k & 1][j] = std::max(dp_suffix[k & 1][j], dp_suffix[k & 1][j + 1]);\n        }\n    }\n\n    // Final Post-processing for `count_suffix_segments`:\n    // Ensure that `count_suffix_segments[i]` stores the maximum segment count\n    // for any suffix starting from index `i` *or beyond*. This is a suffix maximum.\n    for (int i = n - 2; i >= 0; --i) {\n        count_suffix_segments[i] = std::max(count_suffix_segments[i], count_suffix_segments[i + 1]);\n    }\n\n    // --- Combine DP results to find the overall optimal solution ---\n    // Iterate through all possible split points `i` (between `i` and `i+1`).\n    // The goal is to maximize the sum of segments from a prefix ending at `i`\n    // and a suffix starting at `i+1`.\n    int max_total_segments = 0;\n    std::vector<int> optimal_split_points; // Stores 1-based indices of optimal split points\n\n    for (int i = 0; i < n - 1; ++i) {\n        // Calculate the total number of segments if the split is after index `i`.\n        // This combines `count_prefix_segments[i]` (for elements `0` to `i`)\n        // and `count_suffix_segments[i+1]` (for elements `i+1` to `n-1`).\n        ll current_total_segments = count_prefix_segments[i] + count_suffix_segments[i + 1];\n\n        // Update maximum total segments found.\n        if (current_total_segments > max_total_segments) {\n            max_total_segments = current_total_segments;\n            optimal_split_points.clear();      // Clear previous optimal splits\n            optimal_split_points.push_back(i + 1); // Add current split point (1-based index)\n        } else if (current_total_segments == max_total_segments) {\n            optimal_split_points.push_back(i + 1); // Add current split point if it also achieves max\n        }\n    }\n\n    // Output the maximum total number of segments.\n    std::cout << max_total_segments << '\\n';\n    // Output the 1-based indices of all optimal split points.\n    for (const auto& split_point_idx : optimal_split_points) {\n        std::cout << split_point_idx << ' ';\n    }\n    std::cout << '\\n';\n\n    return 0; // Indicate successful program execution\n}"
        }
    },
    {
        "page_content": "**ทัวร์ลง (Tour)**\n\nคู่รักคู่หนึ่งไปแข่ง shopping ในกิจกรรม \"ทัวร์ลง\" ที่จัดใน L โซน โดยแต่ละโซนมีร้านค้าจำนวนหนึ่ง แต่ละร้านขายตุ๊กตาน้องส้มโอหวาน ('S') หรือน้องข้าวสารขาว ('K')\n* การเดินทาง: ต้องเดินทางจากโซน 1 ไปยังโซน L หรือจากโซน L ไปยังโซน 1\n* ในแต่ละโซน ต้องแวะทุกร้านตามลำดับ\n* คนหนึ่งในคู่รักจะรับผิดชอบการซื้อของทั้งหมดในโซนที่มี \"หมายเลขคี่\" อีกคนรับผิดชอบโซน \"หมายเลขคู่\"\n* ค่าความต่างใจ = $(S_1 - S_2)^2 + (K_1 - K_2)^2$ โดย $S_1, K_1$ คือจำนวนตุ๊กตาแต่ละชนิดที่คนแรกรวบรวมได้ และ $S_2, K_2$ คือของคนที่สอง\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมหาค่าความต่างใจที่ \"น้อยที่สุด\" ที่เป็นไปได้ โดยคู่รักสามารถเลือกได้ว่าจะให้ใครเริ่มที่โซนเลขคู่หรือคี่ และจะเริ่มเดินทางจากฝั่งไหน (1 ไป L หรือ L ไป 1)\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่ 1** จำนวนเต็ม L (จำนวนโซน, $1 \\le L \\le 200,000$)\n2.  **L บรรทัดถัดมา** แต่ละบรรทัดเริ่มต้นด้วยจำนวนร้านค้าในโซนนั้น ตามด้วยชนิดของตุ๊กตาในแต่ละร้าน\n\n**ข้อมูลส่งออก**\n\nค่าความต่างใจที่น้อยที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 5 |\n| 3 S S K | |\n| 1 K | |\n| 1 S | |\n| 4 S S K K | |",
        "metadata": {
            "problem_id": "toi20_tour",
            "problem_name": "toi20_tour",
            "source": "TOI",
            "tags": [
                "implementation",
                "math"
            ],
            "solution_code": "#include <iostream>     // For standard input/output operations (cin, cout)\n#include <vector>       // For dynamic arrays (std::vector)\n#include <algorithm>    // For sorting (std::sort), min/max (std::min, std::max)\n#include <utility>      // For std::pair\n#include <limits>       // For std::numeric_limits (to get max values for infinity)\n// No need for <cmath> for squared distance, as it uses multiplication.\n\n// Using 'long long' for integer calculations where large values might occur,\n// as indicated by the original code's '#define int long long'.\nusing ll = long long;\n\n// Represents an edge in the graph with a destination node, a type, and a weight.\nstruct GraphEdge {\n    int dest_node_id; // The node this edge leads to.\n    int type_s;       // A categorizing integer for the edge (e.g., 1 for 'f' sum, others for 'g' sum).\n    ll weight;        // The weight associated with traversing this edge.\n};\n\n// Adjacency list to represent the graph. Global for competitive programming convenience.\nstd::vector<GraphEdge> adj[200010];\n\n// Global variables for problem parameters:\n// N_NODES: The total number of nodes in the graph.\n// M_EDGES: The total number of edges.\n// L_PARAM: An additional parameter whose exact role isn't clear from this snippet,\n//          but it's read and used to size an array.\nint N_NODES, M_EDGES, L_PARAM;\n\n// Stores the 2D points (accumulated_f_sum, accumulated_g_sum) generated by the DFS.\nstd::vector<std::pair<ll, ll>> generated_points;\n\n/**\n * @brief Traverses the graph using Depth-First Search to generate 2D points.\n *\n * Overall Idea: This function explores all possible paths from node 1 to node N_NODES.\n * For each path, it accumulates two separate sums based on the 'type_s' of the edges:\n * one sum for edges with `type_s = 1` (accumulated_f_sum) and another for other types\n * (accumulated_g_sum). When a path reaches the target node, the final pair of\n * accumulated sums forms a 2D point, which is then collected.\n *\n * @param current_node The node currently being visited in the DFS.\n * @param accumulated_f_sum The sum of weights for 'type_s=1' edges up to this point.\n * @param accumulated_g_sum The sum of weights for 'type_s!=1' edges up to this point.\n */\nvoid dfs_generate_points(int current_node, ll accumulated_f_sum, ll accumulated_g_sum) {\n    if (current_node == N_NODES) {\n        generated_points.push_back({accumulated_f_sum, accumulated_g_sum});\n        return;\n    }\n    for (const auto& edge : adj[current_node]) {\n        if (edge.type_s == 1) {\n            dfs_generate_points(edge.dest_node_id, accumulated_f_sum + edge.weight, accumulated_g_sum);\n        } else {\n            dfs_generate_points(edge.dest_node_id, accumulated_f_sum, accumulated_g_sum + edge.weight);\n        }\n    }\n}\n\n/**\n * @brief Calculates the squared Euclidean distance between two 2D points.\n *\n * Overall Idea: A straightforward mathematical helper to compute (x1-x2)^2 + (y1-y2)^2.\n * This is used instead of actual Euclidean distance to avoid floating-point issues and\n * precision problems common in competitive programming.\n *\n * @param p1 The first point.\n * @param p2 The second point.\n * @return The squared distance.\n */\nll calculate_squared_distance(std::pair<ll, ll> p1, std::pair<ll, ll> p2) {\n    ll dx = p1.first - p2.first;\n    ll dy = p1.second - p2.second;\n    return dx * dx + dy * dy;\n}\n\n/**\n * @brief Finds the minimum squared distance between any two points in a given range\n * using the divide and conquer algorithm for the closest pair problem.\n *\n * Overall Idea: This is a classic divide-and-conquer approach for finding the closest\n * pair of points in a set. It works by:\n * 1.  **Divide:** Recursively finding the closest pair in the left and right halves of the points (sorted by X-coordinate).\n * 2.  **Conquer:** Taking the minimum distance found in the halves (`min_overall_dist`).\n * 3.  **Combine:** Efficiently checking for a closer pair where one point is in the left half and the other is in the right. This involves creating a narrow \"strip\" of points around the dividing line (within `sqrt(min_overall_dist)` distance) and sorting these strip points by their Y-coordinate for a final, limited comparison step.\n *\n * @param start_idx The starting index of the points sub-array.\n * @param end_idx The ending index of the points sub-array.\n * @return The minimum squared distance found within this range.\n */\nll find_closest_pair_squared_distance(int start_idx, int end_idx) {\n    // Base case: If few points, brute force all pairs.\n    if (end_idx - start_idx + 1 <= 3) {\n        ll min_sq_dist = std::numeric_limits<ll>::max();\n        for (int i = start_idx; i <= end_idx; ++i) {\n            for (int j = i + 1; j <= end_idx; ++j) {\n                min_sq_dist = std::min(min_sq_dist, calculate_squared_distance(generated_points[i], generated_points[j]));\n            }\n        }\n        return min_sq_dist;\n    }\n\n    int mid_idx = start_idx + (end_idx - start_idx) / 2;\n    std::pair<ll, ll> mid_point_x_val = generated_points[mid_idx]; // X-value of the dividing line\n\n    ll min_dist_left_half = find_closest_pair_squared_distance(start_idx, mid_idx);\n    ll min_dist_right_half = find_closest_pair_squared_distance(mid_idx + 1, end_idx);\n\n    ll min_overall_dist = std::min(min_dist_left_half, min_dist_right_half);\n\n    // Filter points to form a \"strip\" around the mid-line.\n    std::vector<std::pair<ll, ll>> strip_points;\n    for (int i = start_idx; i <= end_idx; ++i) {\n        ll dx_from_mid_line = generated_points[i].first - mid_point_x_val.first;\n        if (dx_from_mid_line * dx_from_mid_line < min_overall_dist) {\n            strip_points.push_back(generated_points[i]);\n        }\n    }\n\n    // Sort the strip points by Y-coordinate for efficient checking.\n    std::sort(strip_points.begin(), strip_points.end(), [](const std::pair<ll, ll>& a, const std::pair<ll, ll>& b) {\n        return a.second < b.second;\n    });\n\n    // Check distances only for points within the strip and close in Y-coordinate.\n    for (size_t i = 0; i < strip_points.size(); ++i) {\n        for (size_t j = i + 1; j < strip_points.size() && (strip_points[j].second - strip_points[i].second) * (strip_points[j].second - strip_points[i].second) < min_overall_dist; ++j) {\n            min_overall_dist = std::min(min_overall_dist, calculate_squared_distance(strip_points[i], strip_points[j]));\n        }\n    }\n    return min_overall_dist;\n}\n\nint main() {\n    // Optimize C++ standard I/O for speed.\n    std::cin.tie(nullptr)->sync_with_stdio(false);\n\n    // Read problem parameters: N_NODES (nodes), M_EDGES (edges), L_PARAM (an additional parameter).\n    std::cin >> N_NODES >> M_EDGES >> L_PARAM;\n\n    // An array to store L_PARAM related information. Its specific use isn't apparent\n    // in this snippet, but it's part of the input.\n    std::vector<int> L_SIZE_ARRAY_INFO(L_PARAM + 1);\n    for (int i = 1; i <= L_PARAM; ++i) {\n        std::cin >> L_SIZE_ARRAY_INFO[i];\n    }\n\n    // Read graph edges and build the adjacency list representation.\n    for (int i = 1; i <= M_EDGES; ++i) {\n        int u, v, s_type;\n        ll weight_val;\n        std::cin >> u >> v >> s_type >> weight_val;\n        adj[u].push_back({v, s_type, weight_val});\n    }\n\n    // Phase 1: Generate all relevant 2D points using DFS.\n    // Start DFS from node 1 with initial sums of zero.\n    dfs_generate_points(1, 0, 0);\n\n    // Phase 2: Find the closest pair among the generated points.\n    // First, sort all points by their X-coordinates, which is a prerequisite\n    // for the efficient divide-and-conquer closest pair algorithm.\n    std::sort(generated_points.begin(), generated_points.end(), [](const std::pair<ll, ll>& a, const std::pair<ll, ll>& b) {\n        return a.first < b.first;\n    });\n\n    // Then, invoke the divide-and-conquer algorithm to find the minimum squared distance.\n    ll minimum_squared_distance = find_closest_pair_squared_distance(0, generated_points.size() - 1);\n\n    // Output the final result.\n    std::cout << minimum_squared_distance << '\\n';\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ผึ้งสายพันธุ์พิเศษ (Bee)**\n\nผึ้งสายพันธุ์หนึ่งประกอบด้วย นางพญา ผึ้งงาน และผึ้งทหาร การเจริญพันธุ์เต็มวัยของผึ้งในสายพันธุ์นี้มีระยะเวลาหนึ่งปี เมื่อผสมพันธุ์แล้วผึ้งทหารหนึ่งตัวสามารถให้กำเนิดลูกเป็นผึ้งงานได้เพียงหนึ่งตัว ส่วนผึ้งงานหนึ่งตัวสามารถให้กำเนิดลูกได้สองตัวเป็นผึ้งงานและผึ้งทหารอย่างละหนึ่งตัว เมื่อให้กำเนิดลูกผึ้งแล้ว ผึ้งงานและผึ้งทหารที่เป็นผู้ให้กำเนิดจะตายไป สำหรับนางพญาสามารถให้กำเนิดลูกเป็นผึ้งงานได้เพียงหนึ่งตัว และมีชีวิตอยู่ตลอดไปไม่มีวันตาย\n\nในทำนองเดียวกันกับผึ้งรุ่นก่อน ผึ้งที่เกิดใหม่เมื่อมีอายุได้หนึ่งปีจะเจริญพันธุ์เต็มวัย มีการผสมพันธุ์ และให้กำเนิดลูกผึ้งรุ่นต่อไปตามกฎข้างต้น และสำหรับนางพญาเมื่อให้กำเนิดลูกผึ้งครบหนึ่งปีแล้ว สามารถผสมพันธุ์และให้กำเนิดลูกผึ้งได้เช่นเดียวกัน\n\nกำหนดให้ผึ้งรังหนึ่งเริ่มต้นด้วยนางพญาหนึ่งตัว และผึ้งงานอีกหนึ่งตัว ดังนั้นเมื่อสิ้นปีแรก (นับเป็นปีที่หนึ่ง) ผึ้งรังนี้จะมีนางพญาหนึ่งตัว, ผึ้งงานสองตัว และผึ้งทหารหนึ่งตัว รวมเป็นผึ้งในรังทั้งสิ้น 4 ตัว และโดยวิธีการเดียวกันในปีที่สองผึ้งรังนี้จะประกอบด้วยนางพญาหนึ่งตัว ผึ้งทหารจำนวนสองตัว และผึ้งงานจำนวนสี่ตัว รวมเป็นผึ้งในรังทั้งสิ้น 7 ตัว\n\nจงเขียนโปรแกรมเพื่อคำนวณจํานวนผึ้งงานและผึ้งทั้งหมดในรังของแต่ละปีที่กำหนด\n\n**ข้อมูลนำเข้า**\n\nข้อมูลนำเข้ามีเพียงบรรทัดเดียว ประกอบด้วยจำนวนเต็มตั้งแต่สองจำนวนขึ้นไป โดยจำนวนแรกจนถึงจำนวนรองสุดท้าย เป็นจํานวนเต็มบวกแทนปีที่ต้องการคำนวณหาจํานวนผึ้งในรัง (ค่าปีตั้งแต่ 1 ถึง 24 และไม่ซ้ำกัน) ค่าสุดท้ายเป็น -1 ซึ่งใช้เป็นรหัสปิดท้ายข้อมูล ข้อมูลแต่ละจำนวนแยกจากกันด้วยเว้นวรรค\n\n**การแสดงผล**\n\nจำนวนบรรทัดของผลลัพธ์มีจำนวนเท่ากับจำนวนปีที่เป็นข้อมูลนำเข้า โดยผลลัพธ์ในแต่ละบรรทัดมีสองค่าคือ จำนวนของผึ้งงาน และ จำนวนของผึ้งทั้งหมดในรัง คั่นด้วยเว้นวรรค\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 1 3 -1 | 2 4 \\<br\\> 7 12 |",
        "metadata": {
            "problem_id": "toi2_bee",
            "problem_name": "toi2_bee",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "implementation"
            ],
            "solution_code": "#include <iostream> // For standard input/output operations (cin, cout)\n#include <vector>   // For std::vector, a dynamic array\n\n// Define a constant for the maximum number of years to precompute.\n// This is based on the array size 30, so up to year 29.\nconst int MAX_YEARS = 30;\n\n// `colony_population_by_year` stores the population counts for different roles\n// for each year. The columns represent:\n// Column 0: Queen count (always 1 in this model)\n// Column 1: Worker count\n// Column 2: Soldier count\n// Initialized for year 0: {1, 1, 0}\nint colony_population_by_year[MAX_YEARS][3] = {{1, 1, 0}};\n\n// `is_year_computed` is a boolean array to track which years' populations\n// have already been computed and stored in `colony_population_by_year`.\nbool is_year_computed[MAX_YEARS] = {true}; // Year 0 is pre-computed\n\n/**\n * @brief Recursively computes the population counts for a given year.\n * This function calculates the queen, worker, and soldier counts\n * for 'year_idx' based on the counts from 'year_idx - 1'.\n *\n * The population rules seem to be:\n * - Queen (arr[year_idx+1][0]): Always 1 (assuming one queen per colony always).\n * - Workers (arr[year_idx+1][1]): Current year's workers + current year's soldiers + 1 (new queen).\n * This implies workers are the sum of the previous year's\n * workers and soldiers, plus one new worker (presumably the queen's offspring).\n * Oh, upon closer inspection, it seems to be:\n * (Previous year's workers + previous year's soldiers + current queen).\n * Let's assume the current logic is:\n * New Workers = Old Workers + Old Soldiers + New Queen (1)\n * - Soldiers (arr[year_idx+1][2]): Equivalent to the previous year's worker count.\n *\n * @param year_idx The year for which to compute the population.\n */\nvoid calculate_colony_population(int year_idx) {\n    // Base case for recursion: if year_idx is 0, it's already pre-computed.\n    if (year_idx == 0) {\n        return;\n    }\n\n    // Recursive call to ensure the previous year's data is computed first.\n    // This makes sure we have arr[year_idx-1] available before computing arr[year_idx].\n    calculate_colony_population(year_idx - 1);\n\n    // Check if the current year's data has already been computed.\n    // This 'if (is_year_computed[year_idx])' seems to prevent re-computation,\n    // but the structure of the original code's recursive call means it will\n    // always be true for year_idx and subsequent steps will go to year_idx+1.\n    // A better way would be to just compute directly or memoize for year_idx.\n    // Given the original structure:\n    // It's checking if the 'current year' (year_idx from parameter) is computed.\n    // If it *is* computed (which it won't be on the first call for a new year),\n    // then it proceeds to compute year_idx + 1.\n    // This suggests a slight misinterpretation in the original code's logic.\n    // Let's re-align to how it was likely intended, computing for `year_idx` from `year_idx-1`.\n\n    // The original logic calculates for `a+1` using `a`.\n    // So, when `calculate_colony_population(year_idx)` is called, it needs to compute `year_idx`.\n    // The base case `if (a != 0) year(a-1);` then `if (vis[a])` is confusing.\n    // Let's refactor this function to simply compute the year_idx's data if not already computed.\n\n    if (!is_year_computed[year_idx]) {\n        // Queen count for the current year (year_idx).\n        colony_population_by_year[year_idx][0] = 1; // Always 1 Queen\n\n        // Worker count for the current year (year_idx):\n        // Sum of previous year's workers, previous year's soldiers, and the new Queen (1).\n        // This is a common pattern in certain population growth problems (e.g., Fibonacci-like).\n        colony_population_by_year[year_idx][1] =\n            colony_population_by_year[year_idx - 1][1] +\n            colony_population_by_year[year_idx - 1][2] +\n            colony_population_by_year[year_idx - 1][0]; // Using previous year's Queen count (which is 1)\n\n        // Soldier count for the current year (year_idx):\n        // This is equal to the number of workers from the previous year.\n        colony_population_by_year[year_idx][2] = colony_population_by_year[year_idx - 1][1];\n\n        // Mark this year as computed.\n        is_year_computed[year_idx] = true;\n    }\n}\n\n\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin from cout and prevents synchronization with C's stdio.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Precompute population data up to MAX_YEARS - 1.\n    // The original code called `year(25)`, so it precomputes up to index 25.\n    // Here, we call for each year from 1 up to MAX_YEARS - 1.\n    for (int i = 1; i < MAX_YEARS; ++i) {\n        calculate_colony_population(i);\n    }\n\n\n    // `query_years` stores the years for which the user wants output.\n    std::vector<int> query_years;\n    int year_input;\n    int num_queries = 0; // Renamed 'n' to 'num_queries' for clarity\n\n    // Read years from input until -1 is encountered.\n    while (std::cin >> year_input && year_input != -1) {\n        query_years.push_back(year_input);\n        num_queries++;\n    }\n\n    // For each queried year, print the total worker count and the total population.\n    for (int i = 0; i < num_queries; ++i) {\n        int current_year = query_years[i];\n\n        // Ensure the queried year is within the precomputed range.\n        if (current_year >= 0 && current_year < MAX_YEARS) {\n            long long workers = colony_population_by_year[current_year][1];\n            long long soldiers = colony_population_by_year[current_year][2];\n            long long queen = colony_population_by_year[current_year][0]; // Should be 1\n\n            long long total_population = workers + soldiers + queen;\n\n            // Output format: Workers Count, Total Population\n            std::cout << workers << \" \" << total_population << \"\\n\";\n        } else {\n            // Handle cases where the queried year is out of bounds or not computed.\n            // For competitive programming, this might not be strictly necessary if constraints guarantee valid years.\n            std::cout << \"Error: Year \" << current_year << \" is out of bounds or not precomputed.\\n\";\n        }\n    }\n\n    return 0; // Indicate successful program termination\n}"
        }
    },
    {
        "page_content": "**ลูกเต๋า (dice)**\n\nกำหนดให้ด้านทั้งหกของลูกเต๋ามีชื่อเรียกคือ บน (Top), หน้า (Front), ซ้าย (Left), หลัง (Back), ขวา (Right) และ ล่าง (Bottom) และกำหนดให้ตำแหน่งเริ่มต้นของลูกเต๋า มีแต้มแต่ละด้านเป็นดังนี้\n\n| บน | หน้า | ซ้าย | หลัง | ขวา | ล่าง |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| 1 | 2 | 3 | 5 | 4 | 6 |\n\nจากตำแหน่งนี้ลูกเต๋าสามารถหมุนได้หกทิศทาง คือ หมุนมาทางด้านหน้า (Forward), หมุนไปทางด้านหลัง (Backward), หมุนไปทางซ้าย (Left), หมุนไปทางขวา (Right), หมุนตามเข็มนาฬิกา (Clockwise), และหมุนทวนเข็มนาฬิกา (Counter clockwise)\n\nจงเขียนโปรแกรมเพื่อรับจํานวนลูกเต๋า และสายอักขระแสดงทิศทางการหมุนของลูกเต๋า หาตำแหน่งสุดท้ายของลูกเต๋า และแสดงแต้มด้านหน้าของลูกเต๋าแต่ละลูก\n\n**ข้อมูลนำเข้า**\n\nบรรทัดแรกเป็นจํานวนลูกเต๋า (มีค่าตั้งแต่ 1 ถึง 6)\n\nแต่ละบรรทัดต่อมาเป็นสายอักขระแสดงทิศทางการหมุนของลูกเต๋าแต่ละลูก (ความยาว 1 ถึง 1,000 ตัวอักษร) ซึ่งประกอบด้วย:\n\n  * **F** - หมุนมาทางด้านหน้า (Forward)\n  * **B** - หมุนไปทางด้านหลัง (Backward)\n  * **L** - หมุนไปทางซ้าย (Left)\n  * **R** - หมุนไปทางขวา (Right)\n  * **C** - หมุนตามเข็มนาฬิกา (Clockwise)\n  * **D** - หมุนทวนเข็มนาฬิกา (Counter clockwise)\n\nกำหนดให้อักษรตัวแรกในสายอักขระเป็นการหมุนจาก \"ตำแหน่งเริ่มต้น\" และอักษรตัวถัดไปเป็นการหมุนต่อจากตำแหน่งล่าสุด\n\n**การแสดงผลลัพธ์**\n\nแสดงผลลัพธ์มีเพียงบรรทัดเดียว ได้แก่แต้มด้านหน้าของลูกเต๋าแต่ละลูกในตำแหน่งสุดท้าย ในกรณีที่มีลูกเต๋ามากกว่า 1 ลูก ให้คั่นแต่ละค่าด้วยเว้นวรรค\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 3 2 2 |\n| D | |\n| FFBB | |\n| BBFFR | |",
        "metadata": {
            "problem_id": "toi2_dice",
            "problem_name": "toi2_dice",
            "source": "TOI",
            "tags": [
                "string",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include <iostream> // Required for standard input/output operations (std::cin, std::cout)\n#include <vector>   // Required for std::vector\n#include <string>   // Required for std::string\n\n/**\n * @brief Simulates a rotation of a six-sided die.\n *\n * This function takes the current state of a die (represented as a vector\n * of integers) and a command character, then updates the die's state\n * to reflect the rotation.\n *\n * The `dice` vector elements map to the die faces as follows:\n * dice[0]: Top face\n * dice[1]: Front face\n * dice[2]: Right face\n * dice[3]: Back face\n * dice[4]: Left face\n * dice[5]: Bottom face\n *\n * @param dice A reference to a `std::vector<int>` representing the die's faces.\n * This vector will be modified in place.\n * @param com The command character indicating the type of spin ('F', 'B', 'L', 'R', 'C', 'D').\n */\nvoid spin_dice(std::vector<int>& dice, char command) {\n    // A temporary vector to store the new configuration of the die faces.\n    // This is crucial to ensure all new face values are derived from the\n    // *original* state of the `dice` before any faces are overwritten.\n    std::vector<int> next_dice_state(6);\n\n    if (command == 'F') { // Roll Forward (Front becomes Top, Top becomes Back, Back becomes Bottom, Bottom becomes Front)\n        next_dice_state[0] = dice[3]; // New Top is Old Back\n        next_dice_state[1] = dice[0]; // New Front is Old Top\n        next_dice_state[2] = dice[2]; // Right face remains Right\n        next_dice_state[3] = dice[5]; // New Back is Old Bottom\n        next_dice_state[4] = dice[4]; // Left face remains Left\n        next_dice_state[5] = dice[1]; // New Bottom is Old Front\n    } else if (command == 'B') { // Roll Backward (Back becomes Top, Top becomes Front, Front becomes Bottom, Bottom becomes Back)\n        next_dice_state[0] = dice[1]; // New Top is Old Front\n        next_dice_state[1] = dice[5]; // New Front is Old Bottom\n        next_dice_state[2] = dice[2]; // Right face remains Right\n        next_dice_state[3] = dice[0]; // New Back is Old Top\n        next_dice_state[4] = dice[4]; // Left face remains Left\n        next_dice_state[5] = dice[3]; // New Bottom is Old Back\n    } else if (command == 'L') { // Roll Left (Left becomes Top, Top becomes Right, Right becomes Bottom, Bottom becomes Left)\n        next_dice_state[0] = dice[4]; // New Top is Old Left\n        next_dice_state[1] = dice[1]; // Front face remains Front\n        next_dice_state[2] = dice[0]; // New Right is Old Top\n        next_dice_state[3] = dice[3]; // Back face remains Back\n        next_dice_state[4] = dice[5]; // New Left is Old Bottom\n        next_dice_state[5] = dice[2]; // New Bottom is Old Right\n    } else if (command == 'R') { // Roll Right (Right becomes Top, Top becomes Left, Left becomes Bottom, Bottom becomes Right)\n        next_dice_state[0] = dice[2]; // New Top is Old Right\n        next_dice_state[1] = dice[1]; // Front face remains Front\n        next_dice_state[2] = dice[5]; // New Right is Old Bottom\n        next_dice_state[3] = dice[3]; // Back face remains Back\n        next_dice_state[4] = dice[0]; // New Left is Old Top\n        next_dice_state[5] = dice[4]; // New Bottom is Old Left\n    } else if (command == 'C') { // Rotate Clockwise (around the vertical axis: Front->Right->Back->Left->Front)\n        next_dice_state[0] = dice[0]; // Top face remains Top\n        next_dice_state[1] = dice[4]; // New Front is Old Left\n        next_dice_state[2] = dice[1]; // New Right is Old Front\n        next_dice_state[3] = dice[2]; // New Back is Old Right\n        next_dice_state[4] = dice[3]; // New Left is Old Back\n        next_dice_state[5] = dice[5]; // Bottom face remains Bottom\n    } else if (command == 'D') { // Rotate Counter-clockwise (around the vertical axis: Front->Left->Back->Right->Front)\n        next_dice_state[0] = dice[0]; // Top face remains Top\n        next_dice_state[1] = dice[2]; // New Front is Old Right\n        next_dice_state[2] = dice[3]; // New Right is Old Back\n        next_dice_state[3] = dice[4]; // New Back is Old Left\n        next_dice_state[4] = dice[1]; // New Left is Old Front\n        next_dice_state[5] = dice[5]; // Bottom face remains Bottom\n    }\n    // Update the original `dice` vector with the new state.\n    dice = next_dice_state;\n}\n\nint main() {\n    // Optimize C++ standard streams for faster input/output in competitive programming.\n    // `std::ios_base::sync_with_stdio(false)` unties C++ streams from C's standard I/O.\n    // `std::cin.tie(nullptr)` prevents `std::cout` from flushing before each `std::cin` operation.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int num_queries;\n    std::cin >> num_queries; // Read the number of test cases (queries).\n\n    // Process each test case.\n    for (int i = 0; i < num_queries; ++i) {\n        std::string command_sequence;\n        std::cin >> command_sequence; // Read the sequence of commands for the current test case.\n\n        // Initialize the die to its standard starting state for each query.\n        // {Top, Front, Right, Back, Left, Bottom}\n        // Opposite faces sum to 7: (1-6, 2-5, 3-4)\n        std::vector<int> dice_state = {1, 2, 3, 5, 4, 6};\n\n        // Apply each command in the sequence to the die.\n        for (char command_char : command_sequence) {\n            spin_dice(dice_state, command_char);\n        }\n\n        // Output the value on the front face (dice_state[1]) after all commands are applied.\n        // Print a space after each result, as indicated by the original code's output.\n        std::cout << dice_state[1] << ' ';\n    }\n\n    return 0; // Indicate successful program execution.\n}"
        }
    },
    {
        "page_content": "**ลำดับย่อยของตัวเลขที่มีตำแหน่งต่อเนื่องกันที่มีค่าสูงสุด (maxseq)**\n\nกำหนดให้ $a\\_1, a\\_2, ..., a\\_n$ เป็นลำดับของจํานวนเต็ม และกำหนดให้ $a\\_i, a\\_{i+1}, ..., a\\_j$ เป็นลำดับย่อยของลำดับดังกล่าวนี้ โดยที่สมาชิกทุกตัวของลำดับย่อยต้องมีตำแหน่งต่อเนื่องกัน ลำดับย่อยที่มีผลบวกของสมาชิกสูงสุด เรียกว่า \"ลำดับย่อยที่มีค่าสูงสุด\"\n\nในกรณีที่ลำดับย่อยที่มีค่าสูงสุด มีค่าน้อยกว่าหรือเท่ากับศูนย์ เรียกว่า \"ลำดับย่อยว่าง\" (Empty sequence)\n\nจงเขียนโปรแกรมเพื่อรับจำนวนของสมาชิกในลำดับและรับค่าสมาชิกทุกตัวของลำดับนั้น ทำการคำนวณและแสดงผลลำดับย่อยที่มีค่าสูงสุด และผลบวกของลำดับย่อยนั้น\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** เป็นจำนวนเต็มบวกซึ่งเป็นจำนวนของสมาชิกในลำดับ (มีค่าตั้งแต่ 1 ถึง 2,500)\n  * **บรรทัดที่สอง** เป็นค่าของสมาชิกของลำดับ แต่ละตัวคั่นด้วยเว้นวรรค (มีค่าตั้งแต่ -127 ถึง +127)\n\n**การแสดงผลลัพธ์**\n\n  * หากหาลำดับย่อยที่มีค่าสูงสุดได้ ให้แสดงลำดับย่อยนั้นในบรรทัดแรก และแสดงผลบวกในบรรทัดที่สอง (หากมีหลายชุดให้แสดงเฉพาะชุดแรกที่พบ)\n  * ในกรณีที่เป็นลำดับย่อยว่าง ให้แสดงข้อความ `Empty sequence`\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 | 3 -2 6 |\n| 4 -6 3 -2 6 -4 -6 6 | 7 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | Empty sequence |\n| -2 -3 -1 | |",
        "metadata": {
            "problem_id": "toi2_maxseq",
            "problem_name": "toi2_maxseq",
            "source": "TOI",
            "tags": [
                "array",
                "prefix-sum",
                "implementation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <numeric> // For std::accumulate if needed, though not directly used in the refactored code\n\n// The overall idea of this code is to find the maximum sum subarray (Kadane's algorithm)\n// and also to store the elements of that maximum sum subarray.\n\n// Global variables are often avoided in competitive programming for larger projects,\n// but can be acceptable for small, self-contained problems to save time.\n// For better practice, these could be encapsulated within a class or passed as arguments.\nstd::vector<int> arr;            // Stores the input array elements\nlong long current_sum = 0;       // Accumulates the sum of the current subarray\nlong long max_so_far = 0;        // Stores the maximum sum found so far\n\n// Variables to keep track of the elements in the current and maximum sum subarrays\nstd::vector<int> current_subarray_elements; // Stores elements of the current subarray\nstd::vector<int> max_subarray_elements;     // Stores elements of the maximum sum subarray found\n\nvoid process_element(int element_value) {\n    // Add the current element to the current sum\n    current_sum += element_value;\n    // Add the current element to the list of elements in the current subarray\n    current_subarray_elements.push_back(element_value);\n\n    // If the current sum is greater than the maximum sum found so far,\n    // update the maximum sum and store the current subarray's elements.\n    if (current_sum > max_so_far) {\n        max_so_far = current_sum;\n        max_subarray_elements = current_subarray_elements; // Copy the elements\n    }\n    // If the current sum becomes non-positive, it means starting a new subarray\n    // from the next element would yield a greater or equal sum.\n    // So, reset the current sum and clear the current subarray elements.\n    else if (current_sum <= 0) {\n        current_sum = 0;\n        current_subarray_elements.clear();\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false); // Optimize I/O for competitive programming\n    std::cin.tie(NULL);                   // Untie cin from cout\n\n    int n; // Number of elements in the array\n    std::cin >> n;\n\n    arr.resize(n); // Resize the input array to hold 'n' elements\n\n    // Process each element of the input array\n    for (int i = 0; i < n; ++i) {\n        std::cin >> arr[i]; // Read the element\n        process_element(arr[i]); // Call the function to process the element\n    }\n\n    // If the maximum sum found is 0, it implies all numbers were negative\n    // or the array was empty (though 'n' is usually positive in competitive programming).\n    // In this specific problem, if max_so_far is 0, it means no positive sum subarray was found.\n    if (max_so_far == 0) {\n        std::cout << \"Empty sequence\\n\";\n    } else {\n        // Print the elements of the maximum sum subarray\n        for (size_t i = 0; i < max_subarray_elements.size(); ++i) {\n            std::cout << max_subarray_elements[i] << (i == max_subarray_elements.size() - 1 ? \"\" : \" \");\n        }\n        std::cout << \"\\n\";\n        // Print the maximum sum\n        std::cout << max_so_far << \"\\n\";\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ระบบแสดงผลตัวเลขแบบเจ็ดส่วน (segment)**\n\nระบบแสดงผลตัวเลขแบบเจ็ดส่วน เป็นระบบแสดงผลที่นิยมใช้กันมากในอุปกรณ์ไฟฟ้า โดยใช้ตัวอักขระ 3 ตัว คือ เว้นวรรค (`     `), ตัวขีดล่าง (`_`) และเส้นดิ่ง (`|`) แทนแต่ละส่วนของตัวเลข\n\nจงเขียนโปรแกรมเพื่ออ่านรูปแบบข้อมูลของระบบแสดงผลตัวเลขแบบเจ็ดส่วนตามรูปแบบที่กำหนดสองชุด ทำการแปลงเป็นจํานวนเต็มสองจํานวน หาผลบวกของตัวเลขสองจํานวนนั้น และแสดงค่าผลบวกที่ได้\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** เป็นจํานวนเต็มบวกสองค่า คือจำนวนหลักของตัวเลขชุดแรกและชุดที่สอง (มีค่าตั้งแต่ 1 ถึง 10)\n  * **สามบรรทัดต่อมา** เป็นรูปแบบแสดงผลตัวเลขแบบเจ็ดส่วนของตัวเลขชุดแรก\n  * **สามบรรทัดสุดท้าย** เป็นรูปแบบแสดงผลตัวเลขแบบเจ็ดส่วนของตัวเลขชุดที่สอง\n\n**การแสดงผลลัพธ์**\n\nข้อมูลส่งออกเป็นจํานวนเต็มเพียงบรรทัดเดียว คือผลบวกของจํานวนเต็มสองจำนวนนั้น\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 3 | 2139 |\n|  \\_  \\_  \\_ |*| | | \\_ |\n| |* |\\_|  |  | \\_| |\n|  \\_| *| *|  | *| |\n|  \\_  \\_  \\_ |\n| |*|  | |*| |\n| |*| \\_|  \\_| |",
        "metadata": {
            "problem_id": "toi2_segment",
            "problem_name": "toi2_segment",
            "source": "TOI",
            "tags": [
                "string",
                "parsing",
                "implementation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <numeric> // Not directly used in this refactoring, but often useful for competitive programming\n\n// The overall idea of this code is to parse two numbers represented as 7-segment display patterns\n// and then calculate their sum.\n\n// A map to store the 7-segment display patterns for each digit (0-9).\n// The key is a vector of three strings, representing the top, middle, and bottom rows of the digit's pattern.\n// The value is the character representation of the digit.\nstd::map<std::vector<std::string>, char> segment_patterns = {\n    {{\" _ \", \"| |\", \"|_|\"}, '0'},\n    {{\"   \", \"  |\", \"  |\"}, '1'},\n    {{\" _ \", \" _|\", \"|_ \"}, '2'},\n    {{\" _ \", \" _|\", \" _|\"}, '3'},\n    {{\"   \", \"|_|\", \"  |\"}, '4'},\n    {{\" _ \", \"|_ \", \" _|\"}, '5'},\n    {{\" _ \", \"|_ \", \"|_|\"}, '6'},\n    {{\" _ \", \"  |\", \"  |\"}, '7'},\n    {{\" _ \", \"|_|\", \"|_|\"}, '8'},\n    {{\" _ \", \"|_|\", \" _|\"}, '9'}\n};\n\n// Function to convert a set of 7-segment display pattern lines into a numeric string.\n// `display_lines`: A vector of three strings representing the top, middle, and bottom lines of the entire number.\n// `num_digits`: The number of digits expected in the pattern.\nstd::string parse_display_to_number_string(const std::vector<std::string>& display_lines, long long num_digits) {\n    std::string result_number_string;\n    // Iterate through each digit in the display\n    for (int i = 0; i < num_digits; ++i) {\n        std::vector<std::string> current_digit_pattern(3); // To store the 3 lines of the current digit\n        // Extract the 3x3 pattern for the current digit\n        for (int j = 0; j < 3; ++j) {\n            // Each digit occupies 3 characters, and there's a 1-character space, so 4 characters per digit\n            current_digit_pattern[j] = display_lines[j].substr(i * 4, 3);\n        }\n        // Look up the extracted pattern in the map and append the corresponding digit to the result string\n        result_number_string += segment_patterns[current_digit_pattern];\n    }\n    return result_number_string;\n}\n\nint main() {\n    // Optimize C++ standard streams for competitive programming (faster I/O)\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    long long len_a, len_b; // Lengths of the two numbers\n    std::cin >> len_a >> len_b;\n\n    // Consume the rest of the current line after reading len_a and len_b,\n    // as getline will read it in the next step.\n    std::cin.ignore();\n\n    // Vector to store all 6 lines of the 7-segment display input (3 for the first number, 3 for the second)\n    std::vector<std::string> all_display_input_lines(6);\n    for (int i = 0; i < 6; ++i) {\n        std::getline(std::cin, all_display_input_lines[i]);\n    }\n\n    // Extract the lines for the first number\n    std::vector<std::string> first_num_lines = {all_display_input_lines[0], all_display_input_lines[1], all_display_input_lines[2]};\n    // Parse the first number's display pattern into a string\n    std::string first_number_str = parse_display_to_number_string(first_num_lines, len_a);\n\n    // Extract the lines for the second number\n    std::vector<std::string> second_num_lines = {all_display_input_lines[3], all_display_input_lines[4], all_display_input_lines[5]};\n    // Parse the second number's display pattern into a string\n    std::string second_number_str = parse_display_to_number_string(second_num_lines, len_b);\n\n    // Convert the parsed number strings to long long integers and calculate their sum\n    long long sum = std::stoll(first_number_str) + std::stoll(second_number_str);\n\n    // Print the sum\n    std::cout << sum << '\\n';\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**เส้นขอบฟ้า (skyline)**\n\nรัฐบาลวางแผนสร้างเมืองใหม่บนพื้นที่ราบ โดยกำหนดให้อาคารที่จะสร้างแต่ละหลังมีรูปทรงเป็นสี่เหลี่ยมผืนผ้า เมื่อมองตัวเมืองจากระยะไกลจะเห็นเส้นขอบฟ้าตามแนวเส้นขอบของอาคาร\n\nอาคารที่จะสร้างขึ้นแต่ละหลัง กำหนดด้วยจำนวนเต็มบวกสามจำนวนคือ (Li, Hi, Ri) เมื่อ Li และ Ri เป็นตำแหน่งตามแกนนอนด้านซ้ายและขวาของอาคาร ส่วน Hi เป็นความสูงของอาคารนั้น\n\nจงเขียนโปรแกรมคำนวณหาเส้นขอบฟ้าจากข้อมูลของอาคารที่กำหนดให้\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** เป็นจํานวนอาคารที่ต้องการหาเส้นขอบฟ้า (มีค่าตั้งแต่ 1 ถึง 3,000)\n  * **บรรทัดต่อไป** แต่ละบรรทัดเป็นข้อมูลของอาคารแต่ละหลังในรูปแบบ `Li Hi Ri` โดยแต่ละตัวมีค่าตั้งแต่ 1 ถึง 255 และคั่นด้วยเว้นวรรค\n\n**การแสดงผลลัพธ์**\n\nผลลัพธ์มีเพียงบรรทัดเดียว คือเส้นขอบฟ้าที่เกิดจากข้อมูลของอาคาร โดยมีรูปแบบคือ $v\\_1, v\\_2, v\\_3, ..., v\\_n$ เมื่อ $v\\_i$ ที่ตำแหน่งคี่จะแทนตำแหน่งตามแกนนอน และ $v\\_i$ ที่ตำแหน่งคู่จะแทนความสูงของเส้นขอบฟ้า ณ ตำแหน่งนั้น โดย $v\\_n$ จะมีค่าเป็น 0 เสมอ ผลลัพธ์แต่ละจํานวนให้คั่นด้วยเว้นวรรค\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 | 1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0 |\n| 1 11 5 | |\n| 2 6 7 | |\n| 12 7 16 | |\n| 14 3 25 | |\n| 19 18 22 | |\n| 3 13 9 | |\n| 23 13 29 | |\n| 24 4 28 | |",
        "metadata": {
            "problem_id": "toi2_skyline",
            "problem_name": "toi2_skyline",
            "source": "TOI",
            "tags": [
                "stack",
                "sorting",
                "array"
            ],
            "solution_code": "#include <iostream>   // Required for input/output operations (cin, cout)\n#include <vector>     // Required for std::vector\n#include <algorithm>  // Required for std::max\n#include <iomanip>    // Required for std::fixed and std::setprecision if coutf was used\n\n// The overall idea of this code is to solve the \"Skyline Problem\" or a simplified version of it.\n// It processes a series of rectangular buildings defined by their left edge, height, and right edge.\n// For each horizontal position, it determines the maximum height among all buildings covering that position.\n// Finally, it outputs the \"critical points\" of the skyline: the x-coordinates where the maximum height changes,\n// along with the new height at that x-coordinate.\n\nint main() {\n    // Optimize C++ standard streams for competitive programming (faster I/O).\n    // This replaces the `macos` macro.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    // std::cout.tie(NULL); // This line is generally not needed unless output is very heavy and interleaved with input\n\n    // Define a constant for the maximum possible x-coordinate.\n    // This is used for the size of the array that stores maximum heights.\n    // Using a named constant is more readable than a raw number.\n    const int MAX_COORD = 256;\n\n    // Use std::vector instead of a raw array for better memory management and safety.\n    // Initialize all heights to 0.\n    std::vector<int> max_height_at_x(MAX_COORD, 0);\n\n    int num_buildings; // Number of buildings\n    std::cin >> num_buildings;\n\n    // Loop to read and process each building's dimensions.\n    // Replaces `forr(i,0,n)`.\n    for (int i = 0; i < num_buildings; ++i) {\n        int left_edge, height, right_edge; // Building's left edge, height, and right edge\n        std::cin >> left_edge >> height >> right_edge;\n\n        // Iterate from the left edge to the right edge (exclusive of the right edge)\n        // and update the maximum height for each x-coordinate covered by the current building.\n        // Replaces `forr(j,l,r)`.\n        for (int j = left_edge; j < right_edge; ++j) {\n            // Ensure `j` is within the bounds of `max_height_at_x`.\n            // While the problem constraints might guarantee this, it's good practice.\n            if (j >= 0 && j < MAX_COORD) {\n                max_height_at_x[j] = std::max(max_height_at_x[j], height);\n            }\n        }\n    }\n\n    // Loop to find and print the critical points of the skyline.\n    // A critical point occurs when the height changes from the previous x-coordinate.\n    // We iterate from x-coordinate 1 up to MAX_COORD - 1 to compare with the previous coordinate.\n    // Replaces `forr(i,1,N)`.\n    for (int i = 1; i < MAX_COORD; ++i) {\n        // If the height at the current x-coordinate is different from the height\n        // at the previous x-coordinate, it's a critical point.\n        if (max_height_at_x[i - 1] != max_height_at_x[i]) {\n            // Print the x-coordinate and the new height.\n            std::cout << i << ' ' << max_height_at_x[i] << ' ';\n        }\n    }\n    std::cout << '\\n'; // Add a newline at the end of the output, replacing `endll`.\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ปริศนาค้นหาคำ (word)**\n\nกำหนดตารางของตัวอักษรขนาด $m \\\\times n$ ($1\\\\le m, n\\\\le25$) จงเขียนโปรแกรมค้นหาตำแหน่งเริ่มต้นของคำที่ต้องการในตารางดังกล่าว โดยให้ถือว่าตัวอักษรพิมพ์เล็กและตัวอักษรพิมพ์ใหญ่เป็นตัวเดียวกัน การค้นคำสามารถทำได้ทั้ง 8 ทิศทาง (แนวตั้ง, แนวนอน, และแนวทแยง)\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** เป็นจํานวนเต็มบวกสองจํานวน `m` (แถว) และ `n` (คอลัมน์) คั่นด้วยเว้นวรรค\n  * **m บรรทัดต่อมา** เป็นข้อมูลแต่ละแถวของตารางตัวอักษร\n  * **บรรทัดต่อมา** เป็นจํานวนคำทั้งหมดที่ต้องการค้นหา `k` ($1\\\\le k\\\\le100$)\n  * **k บรรทัดต่อมา** เป็นคำที่ต้องการค้นหา (แต่ละคำมีความยาว 1 ถึง 15 ตัวอักษร และมีปรากฏในตารางอย่างน้อยหนึ่งครั้ง)\n\n**การแสดงผลลัพธ์**\n\nข้อมูลส่งออกมีจำนวนบรรทัดเท่ากับจํานวนคำที่ต้องการค้นหา เมื่อพบคำที่ต้องการแล้วให้แสดงผลลัพธ์เป็นหมายเลขแถวและตำแหน่งเริ่มต้นของคำในแถวนั้น (แถวแรกและคอลัมน์แรกคือ 0) ในกรณีที่พบหลายตำแหน่ง ให้ยึดตำแหน่งบนสุดและซ้ายสุดเป็นคำตอบ\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 11 | 1 4 |\n| asCDEFGhigg | 7 3 |\n| hTqkComPutk | 4 2 |\n| FayUcompuTm | 6 7 |\n| FcsierMqsrc | |\n| bkoArUePeyv | |\n| Kicbqwekumk | |\n| sreTNIophtb | |\n| yuiqlxcnBje | |\n| 4 | |\n| Compute | |\n| Queue | |\n| Stack | |\n| Pointer | |",
        "metadata": {
            "problem_id": "toi2_word",
            "problem_name": "toi2_word",
            "source": "TOI",
            "tags": [
                "string",
                "search",
                "implementation"
            ],
            "solution_code": "#include <iostream>   // For std::cin, std::cout\n#include <vector>     // For std::vector\n#include <string>     // For std::string\n#include <cctype>     // For std::tolower\n\n// The overall idea of this code is to implement a word search puzzle solver.\n// It reads a grid of characters (the \"board\") and a list of words.\n// For each word, it searches if the word exists in the board, starting from any cell\n// and extending in any of the 8 cardinal and diagonal directions.\n// If found, it outputs the starting row and column of the first occurrence.\n\n// Global variables for board dimensions and direction vectors.\n// While global variables are sometimes used in competitive programming for brevity,\n// passing them as parameters or encapsulating them in a struct/class can improve\n// code organization and reusability for larger projects.\nstd::vector<std::string> board; // Stores the character grid\nint rows, cols;                 // Dimensions of the board\n\n// Arrays to represent the 8 possible directions (row_offset, col_offset)\n// Top-Left to Bottom-Right order: North, North-East, East, South-East, South, South-West, West, North-West\nconst int DR[] = {-1, -1, 0, 1, 1, 1, 0, -1};\nconst int DC[] = {0, 1, 1, 1, 0, -1, -1, -1};\n\n// Recursive helper function to check if a word can be formed in a specific direction.\n// Parameters:\n// - `current_row`, `current_col`: Current position on the board.\n// - `row_dir`, `col_dir`: Direction of movement (e.g., -1, 0 for North).\n// - `target_word`: The word being searched for.\n// - `char_index`: The index of the character in `target_word` we are currently trying to match.\nbool search_in_direction(int current_row, int current_col, int row_dir, int col_dir,\n                         const std::string& target_word, int char_index) {\n    // Base case 1: Check if the current position is out of board boundaries.\n    if (current_row < 0 || current_row >= rows || current_col < 0 || current_col >= cols) {\n        return false;\n    }\n\n    // Base case 2: Check if the character at the current board position matches\n    // the character at `char_index` in the `target_word` (case-insensitive).\n    if (std::tolower(board[current_row][current_col]) != std::tolower(target_word[char_index])) {\n        return false;\n    }\n\n    // Base case 3: If we have matched all characters of the target word, we found it.\n    if (char_index == target_word.length() - 1) {\n        return true;\n    }\n\n    // Recursive step: Move to the next character in the specified direction.\n    return search_in_direction(current_row + row_dir, current_col + col_dir,\n                               row_dir, col_dir, target_word, char_index + 1);\n}\n\n// Function to check if a word exists starting from a given position in any of the 8 directions.\n// Parameters:\n// - `start_row`, `start_col`: Starting position on the board.\n// - `target_word`: The word to search for.\nbool find_word_from_start_point(int start_row, int start_col, const std::string& target_word) {\n    // Iterate through all 8 possible directions.\n    for (int i = 0; i < 8; ++i) {\n        // If the word is found in any direction, return true immediately.\n        if (search_in_direction(start_row, start_col, DR[i], DC[i], target_word, 0)) {\n            return true;\n        }\n    }\n    return false; // Word not found from this starting point in any direction.\n}\n\nint main() {\n    // Optimize C++ standard streams for competitive programming (faster I/O).\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    // Read board dimensions.\n    std::cin >> rows >> cols;\n\n    // Resize the board to store the input rows.\n    board.resize(rows);\n    // Read the board characters row by row.\n    for (int i = 0; i < rows; ++i) {\n        std::cin >> board[i];\n    }\n\n    int num_queries; // Number of words to search for.\n    std::cin >> num_queries;\n\n    // Process each query (each word to search).\n    while (num_queries--) {\n        std::string current_word;\n        std::cin >> current_word;\n\n        bool found_word = false; // Flag to indicate if the word has been found.\n\n        // Iterate through each cell of the board as a potential starting point.\n        for (int r_idx = 0; r_idx < rows; ++r_idx) {\n            for (int c_idx = 0; c_idx < cols; ++c_idx) {\n                // If the word is found starting from (r_idx, c_idx), print the coordinates\n                // and set the flag to break outer loops.\n                if (find_word_from_start_point(r_idx, c_idx, current_word)) {\n                    std::cout << r_idx << ' ' << c_idx << std::endl;\n                    found_word = true;\n                    break; // Break from inner (column) loop\n                }\n            }\n            if (found_word) {\n                break; // Break from outer (row) loop\n            }\n        }\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**บล็อกเกม (Block Game)**\n\nเกมประกอบด้วยบอร์ดและบล็อก กำหนดให้บอร์ดมีขนาดไม่เกิน 5x5 และบล็อกมีไม่เกิน 3 ชนิด บล็อกเท่านั้นที่สามารถเคลื่อนย้ายไปทางซ้ายหรือขวาได้หากมีที่ว่าง หลังการเคลื่อนย้าย บล็อกใด ๆ ที่ไม่มีอะไรรองรับจะตกลงมา หากมีกลุ่มของบล็อกชนิดเดียวกันตั้งแต่ 2 บล็อกขึ้นไปอยู่ติดกัน (แนวตั้งหรือแนวนอน) กลุ่มของบล็อกนั้นจะถูกลบออกไป\n\n* **การให้คะแนน:** แต่ละบล็อกที่ถูกลบจะได้ 5 คะแนน และแต่ละการเคลื่อนย้ายที่ไม่ถูกต้องจะได้ -5 คะแนน (เช่น ย้ายไปทับบล็อกอื่น, ย้ายไปทับขอบบอร์ด, ย้ายตำแหน่งที่ไม่มีบล็อก)\n\n**คำสั่ง**\n\nจงเขียนโปรแกรมเพื่อรับข้อมูลโครงสร้างบอร์ดและบล็อก และข้อมูลการเคลื่อนย้ายบล็อก จากนั้นคำนวณหาคะแนนของการย้ายบล็อก พร้อมทั้งแสดงโครงสร้างใหม่ของบอร์ดและบล็อก\n\n**ข้อมูลนำเข้า**\n\n**ส่วนที่ 1: โครงสร้างบอร์ด**\n* บรรทัดแรกมีเลขจำนวนเต็มบวกสองจำนวน m (แถว) และ n (สดมภ์)\n* m บรรทัดต่อมา แสดงโครงสร้างของบอร์ดและบล็อก โดยใช้ \"#\" แทนบอร์ด, \" \" (เว้นวรรค) แทนพื้นที่ว่าง, และอักษรตัวใหญ่แทนชนิดของบล็อก\n\n**ส่วนที่ 2: การเคลื่อนย้าย**\n* บรรทัดแรกมีเลขจำนวนเต็มบวก l ($1\\le l\\le20$) บอกจำนวนการเคลื่อนย้าย\n* l บรรทัดต่อมา เป็นคำสั่งการเคลื่อนย้าย ประกอบด้วย แถว, สดมภ์, และทิศทาง (\"L\" หรือ \"R\")\n\n**ข้อมูลส่งออก**\n\n* บรรทัดแรกแสดงคะแนนรวม\n* บรรทัดต่อมา m บรรทัด แสดงโครงสร้างใหม่ของบอร์ดและบล็อก\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 5 | 20 |\n| # A - - # | # - - - # |\n| # # B - # | # # - - # |\n| # A B # # | # - - # # |\n| # # # # # | # # # # # |\n| 2 | |\n| 1 3 L | |\n| 0 1 R | |",
        "metadata": {
            "problem_id": "toi3_block",
            "problem_name": "toi3_block",
            "source": "TOI",
            "tags": [
                "simulation",
                "implementation",
                "array"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m,dy[]={-1,0,1,0},dx[]={0,1,0,-1},cnt=0;\nchar a[6][6];\n\nvoid fall(){\n    for(int i=0;i<n-1;i++){\n        for(int j=0;j<m;j++){\n            if(a[i][j]!='#' && a[i+1][j]=='-')swap(a[i][j],a[i+1][j]);\n        }\n    }\n}\n\nvoid flood(int y,int x,char c){\n    if(a[y][x]==c){\n        cnt++;\n        a[y][x]='-';\n    }\n    else return;\n    for(int i=0;i<4;i++){\n        flood(y+dy[i],x+dx[i],c);\n    }\n}\n\nvoid block(){\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(a[i][j]=='#' || a[i][j]=='-')continue;\n            if(a[i][j]==a[i-1][j] || a[i][j]==a[i+1][j] || a[i][j]==a[i][j-1] || a[i][j]==a[i][j+1]){\n                flood(i,j,a[i][j]);\n                fall();\n            }\n        }\n    }\n}\n\nint main(){\n    cin >> n >> m;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cin >> a[i][j];\n        }\n    }\n    int k;\n    cin >> k;\n    while(k--){\n        int y,x,z;\n        char d;\n        cin >> y >> x >> d;\n        if(a[y][x]=='-' || a[y][x]=='#'){\n            cnt--;\n            continue;\n        }\n        z = (d == 'L' ? -1 : 1); \n        if(a[y][x+z]=='-')swap(a[y][x+z],a[y][x]);\n        else {\n            cnt--;\n            continue;\n        }\n        fall();\n        block();\n    }\n    cout << cnt*5 << \"\\n\";\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            cout << a[i][j] << \" \";\n        }\n        cout << \"\\n\";\n    }\n}"
        }
    },
    {
        "page_content": "**ใบสั่งเค้กพิศวง (Silly Bakery)**\n\nร้านสั่งทำเค้กแห่งหนึ่งรับใบสั่งเค้กเฉพาะช่วงที่มีการแข่งขันคอมพิวเตอร์โอลิมปิกของ สอวน เท่านั้น เจ้าของร้านผลิตเค้กขนาดหนึ่งปอนด์ แต่แบ่งขายเป็นห้าแบบคือ เต็มปอนด์, 3/4 ปอนด์, 1/2 ปอนด์, 1/4 ปอนด์, และ 1/8 ปอนด์ เวลาขายเค้กแต่ละครั้งเจ้าของร้านจะไม่ยอมเอาเค้กแบบที่เล็กกว่ามารวมให้ได้ขนาดของเค้กตามที่ลูกค้าต้องการ\n\nสมมุติว่า ถ้าลูกค้าสั่งเค้กขนาด 3/4 ปอนด์ เจ้าของร้านก็จะไม่นำเค้กขนาด 1/4 ปอนด์ให้ลูกค้าไปสามก้อน แต่จะให้เค้กขนาด 3/4 ปอนด์ที่มีอยู่แก่ลูกค้าเท่านั้น และถ้าไม่มีเค้กขนาด 3/4 ปอนด์อยู่เลย เจ้าของร้านจะเอาเค้กขนาดเต็มก้อนมาแบ่งแล้วให้ลูกค้าไป โดยเก็บเศษที่เหลือไว้ให้ลูกค้าคนอื่น\n\nลูกค้าจะสั่งเค้กเป็นจำนวนเต็ม a, b, c, d, e สำหรับขนาดเค้ก เต็มปอนด์, 3/4 ปอนด์, 1/2 ปอนด์, 1/4 ปอนด์, และ 1/8 ปอนด์ ตามลำดับ\n\n**คำสั่ง**\n\nจงเขียนโปรแกรมเพื่อรับข้อมูลรายการสั่งเค้กของลูกค้าและคำนวณว่าจะต้องทำเค้กอย่างน้อยที่สุดกี่ปอนด์\n\n**ข้อมูลนำเข้า**\n\nบรรทัดแรกมีจำนวนเต็ม n ($1\\le n\\le10$) ต่อจากนั้น n บรรทัดจะเป็นข้อมูลของลูกค้าคนที่ 1 ถึงคนที่ n โดยแต่ละบรรทัดจะประกอบด้วย จำนวนเต็ม a, b, c, d, e ($0 \\le a,b,c,d,e \\le 10000$) โดยแต่ละค่าจะคั่นด้วยช่องว่างหนึ่งช่อง\n\n**ข้อมูลส่งออก**\n\nมีบรรทัดเดียว ประกอบด้วยจำนวนเต็มหนึ่งค่า ซึ่งเป็นจำนวนของเค้กเต็มปอนด์ที่น้อยที่สุดที่เจ้าของร้านต้องเตรียมให้เพียงพอตามรายการที่ลูกค้าสั่ง\n\n**ตัวอย่าง 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 4 |\n| 1 0 1 0 1 | |\n| 1 0 0 1 0 | |\n| 1 0 0 0 0 | |\n\n**ตัวอย่าง 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 2 |\n| 0 0 1 0 0 | |\n| 0 0 0 0 1 | |\n| 0 0 1 0 0 | |\n| 0 1 0 0 0 | |",
        "metadata": {
            "problem_id": "toi3_cake",
            "problem_name": "toi3_cake",
            "source": "TOI",
            "tags": [
                "simulation",
                "math"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    int n;\n    cin >> n;\n    double sum = 0;\n    while (n--) {\n        // 1, 3/4, 1/2, 1/4, 1/8\n        int a, b, c, d, e;\n        cin >> a >> b >> c >> d >> e;\n        sum = sum + 1*a + 0.75*b + 0.5*c + 0.25*d + 0.125*e;\n    }\n\n    cout << ceil(sum);\n}"
        }
    },
    {
        "page_content": "**ฟังก์ชันแทนนิพจน์ (Expression)**\n\nในการแทนนิพจน์ (expression) ใด ๆ ด้วยฟังก์ชัน นิพจน์หลักจะถูกแบ่งเป็นนิพจน์ย่อยๆ ด้วยตัวดำเนินการ (operator) ที่มีลำดับความสำคัญในการทำงานต่ำสุดในนิพจน์นั้น ลำดับความสำคัญจากมากไปน้อยคือ \"()\", \"^\", \"*\", และ \"+\"\n\nฟังก์ชัน `op(i,e)` จะใช้แทนนิจพน์ย่อยลำดับที่ i ของนิพจน์ e\nตัวอย่าง: นิพจน์ `a*b+b*c+c*d` ตัวดำเนินการที่มีความสำคัญต่ำสุดคือ `+` ดังนั้น นิพจน์ย่อยที่ 1 คือ `a*b`, ที่ 2 คือ `b*c`, และที่ 3 คือ `c*d` ดังนั้น `op(2, p)` จะได้ `b*c`\n\n**คำสั่ง**\n\nจงเขียนโปรแกรมเพื่อรับข้อมูลนิพจน์ p ใด ๆ และฟังก์ชันคำถาม จากนั้นคำนวณหานิพจน์ย่อยของ p ที่สอดคล้องกับฟังก์ชันที่กำหนด\n\n**ข้อมูลนำเข้า**\n\n* **บรรทัดแรก** แสดงนิพจน์หลัก (p) ความยาวไม่เกิน 64 ตัว\n* **บรรทัดที่สอง** เป็นเลขจำนวนเต็มบวก n ($1\\le n\\le10$) แสดงจำนวนฟังก์ชันคำถาม\n* n บรรทัดต่อไป แต่ละบรรทัดแทนฟังก์ชันคำถามหนึ่งคำถาม ซึ่งประกอบด้วยเลขจำนวนเต็มบวก (1-9) คั่นด้วยช่องว่าง และปิดท้ายด้วย 0 (เช่น `2 1 0` หมายถึง `op(1,op(2,p))`)\n\n**ข้อมูลส่งออก**\n\nแต่ละบรรทัดแสดงฟังก์ชันและนิพจน์ย่อยที่สอดคล้องกับฟังก์ชันนั้น กรณีที่ไม่มีคำตอบให้แสดง \"null\"\n\n**ตัวอย่าง 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| a\\*b^c+d\\*e^f | op(1,p)=a\\*b^c |\n| 2 | op(2,p)=d\\*e^f |\n| 1 0 | |\n| 2 0 | |\n\n**ตัวอย่าง 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| (x+y)+z | op(1,p)=(x+y) |\n| 5 | op(1,op(1,p))=x+y |\n| 1 0 | op(1,op(1,op(1,p)))=x |\n| 1 1 0 | op(2,op(1,op(1,p)))=y |\n| 1 1 1 0 | op(3,p)=null |\n| 1 1 2 0 | |\n| 3 0 | |",
        "metadata": {
            "problem_id": "toi3_express",
            "problem_name": "toi3_express",
            "source": "TOI",
            "tags": [
                "string",
                "parsing",
                "recursion",
                "stack"
            ],
            "solution_code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm> // For std::min or std::max if needed, though not directly used in the refactor below.\n\n// Global queues and stacks are generally discouraged in competitive programming\n// unless explicitly required for specific data structures (e.g., BFS/DFS).\n// For this problem, they are used repeatedly, so moving them inside main or\n// passing them as arguments would be cleaner. However, to minimize changes\n// and focus on understandability, I'll keep them global for now but note it.\n// If they were to be reset for each test case, they should be cleared.\n// In this specific code, `qu` and `st` are cleared/emptied implicitly or explicitly\n// within the loops, so their global scope is less problematic than it might seem\n// at first glance, but still not ideal practice.\nstd::queue<char> parenthesis_balance_checker_queue; // Renamed for clarity\nstd::stack<int> operation_indices_stack; // Renamed for clarity\n\n/*\n    Overall Idea:\n\n    This program processes a series of operations on an input mathematical expression string.\n    For each test case, it iteratively modifies the expression based on user-provided indices.\n\n    The core logic involves:\n    1. Finding the lowest precedence operator (among '+', '*', '^') at the outermost level of the expression.\n       Parentheses are handled to correctly identify outermost operators.\n    2. Based on the chosen operator, it attempts to extract a sub-expression specified by an input index.\n    3. If the expression is just a parenthesized sub-expression at the outermost level, it removes the parentheses.\n    4. This process repeats until a '0' is entered as an index, signifying the end of operations for the current test case.\n    5. Finally, it prints the sequence of operations applied and the resulting expression (or \"=null\" if an invalid operation occurred).\n\n*/\nint main() {\n    // Disable synchronization with C-style I/O and untie cin/cout for faster I/O.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::string initial_expression;\n    std::cin >> initial_expression;\n\n    int num_test_cases;\n    std::cin >> num_test_cases;\n\n    // Process each test case\n    while (num_test_cases--) {\n        std::string current_expression = initial_expression; // Start with the original expression for each test case\n        bool is_null_result = false; // Flag to indicate if the result should be \"null\"\n\n        // Clear global data structures for each test case to avoid stale data\n        while (!parenthesis_balance_checker_queue.empty()) {\n            parenthesis_balance_checker_queue.pop();\n        }\n        while (!operation_indices_stack.empty()) {\n            operation_indices_stack.pop();\n        }\n\n        // --- Process operations for the current expression ---\n        while (true) {\n            int operation_index;\n            std::cin >> operation_index;\n\n            // '0' indicates the end of operations for the current test case\n            if (operation_index == 0) {\n                break;\n            }\n\n            operation_indices_stack.push(operation_index); // Store the operation index\n\n            char lowest_precedence_operator = 'a'; // Placeholder, 'a' is not an operator\n            // Identify the lowest precedence operator at the outermost level\n            // This loop iterates through the expression to find the operator with the lowest precedence\n            // that is not enclosed within parentheses.\n            for (char ch : current_expression) {\n                if (ch == '(') {\n                    parenthesis_balance_checker_queue.push('(');\n                } else if (ch == ')') {\n                    if (!parenthesis_balance_checker_queue.empty()) {\n                        parenthesis_balance_checker_queue.pop();\n                    }\n                } else if (parenthesis_balance_checker_queue.empty()) { // Only consider operators outside parentheses\n                    if (ch == '^' && (lowest_precedence_operator != '*' && lowest_precedence_operator != '+')) {\n                        lowest_precedence_operator = '^';\n                    } else if (ch == '*' && lowest_precedence_operator != '+') {\n                        lowest_precedence_operator = '*';\n                    } else if (ch == '+') { // '+' has the lowest precedence\n                        lowest_precedence_operator = '+';\n                    }\n                }\n            }\n\n            int operator_count = 1; // Counts occurrences of the lowest precedence operator\n            std::string temp_expression_segment = \"\"; // Stores the extracted segment\n            // This loop re-iterates to find the N-th occurrence of the identified lowest precedence operator\n            // and extract the sub-expression associated with it.\n            // It also clears the queue to reuse for balance checking.\n            while (!parenthesis_balance_checker_queue.empty()) {\n                parenthesis_balance_checker_queue.pop();\n            }\n\n            for (char ch : current_expression) {\n                if (ch == '(') {\n                    parenthesis_balance_checker_queue.push('(');\n                } else if (ch == ')') {\n                    if (!parenthesis_balance_checker_queue.empty()) {\n                        parenthesis_balance_checker_queue.pop();\n                    }\n                }\n\n                if (parenthesis_balance_checker_queue.empty() && ch == lowest_precedence_operator) {\n                    operator_count++;\n                } else if (operator_count == operation_index) { // If this is the desired segment, append to temp\n                    temp_expression_segment += ch;\n                }\n            }\n\n            // Handle special cases: single element or invalid index\n            if (operator_count == 1) { // If no operators or only one part (e.g., \"A\", \"(B)\")\n                // Check if the current expression is an entirely parenthesized sub-expression\n                if (current_expression[0] == '(' && current_expression.back() == ')') {\n                    current_expression = current_expression.substr(1, current_expression.size() - 2); // Remove outermost parentheses\n                    if (operation_index > 1) { // If an invalid index was provided for a parenthesized expression\n                        is_null_result = true;\n                    }\n                    continue; // Continue to the next operation as the expression was simplified\n                }\n            }\n\n            // If the requested operation_index is out of bounds\n            if (operation_index > operator_count) {\n                is_null_result = true;\n            }\n\n            current_expression = temp_expression_segment; // Update the expression for the next iteration\n        }\n\n        // --- Print the results for the current test case ---\n        int num_operations = operation_indices_stack.size();\n\n        // Print the sequence of operations in reverse order (due to stack LIFO)\n        while (!operation_indices_stack.empty()) {\n            int op_val = operation_indices_stack.top();\n            operation_indices_stack.pop();\n            std::cout << \"op(\" << op_val << ',';\n        }\n        std::cout << 'p'; // 'p' represents the final expression or null\n\n        // Close all the 'op(' parentheses\n        for (int i = 0; i < num_operations; ++i) {\n            std::cout << ')';\n        }\n\n        // Print the final result\n        if (is_null_result) {\n            std::cout << \"=null\\n\";\n        } else {\n            std::cout << '=' << current_expression << '\\n';\n        }\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ผ้าม่าน (Filter)**\n\nหอประชุมแห่งหนึ่งมีหน้าต่างขนาดใหญ่รูปสี่เหลี่ยมผืนผ้า ขนาดกว้าง W เมตร สูง H เมตร นักศึกษาได้ซื้อผ้าม่านกรองแสงมา n ผืนเพื่อบังแดด ผ้าม่านแต่ละผืนมีความสามารถในการตัดแสงแดดได้ 50% และหากผ้าม่านซ้อนกันตั้งแต่สองชั้นขึ้นไปจะสามารถบังแดดได้ 100%\n\n**คำสั่ง**\n\nจงเขียนโปรแกรมเพื่อรับข้อมูลขนาดของหน้าต่างและการแขวนผ้าม่าน จากนั้นคำนวณหาพื้นที่ของหน้าต่างที่ไม่โดนม่านบัง (แสงผ่านได้ 100%) และพื้นที่ที่แสงสามารถส่องผ่านได้ 50% (โดนม่าน 1 ชั้น)\n\n**ข้อมูลนำเข้า**\n\nบรรทัดแรกมีจำนวนเต็มสามจำนวน W, H, และ n ($1\\le W\\le3000$, $1\\le H\\le10$, $1\\le n\\le100$)\nn บรรทัดต่อมาจะเป็นข้อมูลผ้าม่าน โดยแต่ละบรรทัดประกอบด้วย จำนวนเต็มสองจำนวน x และ a ($0\\le x\\le W$, $1\\le a\\le1000$) โดย x แทนตำแหน่งนับจากขอบหน้าต่างด้านซ้ายที่เริ่มแขวนผ้าม่าน และ a แทนความกว้างของผ้าม่าน\n\n**ข้อมูลส่งออก**\n\nมีบรรทัดเดียว ประกอบด้วยจำนวนเต็มสองค่า ตัวแรกเป็นพื้นที่ของหน้าต่างที่แสงส่องผ่านได้ 100% ตัวที่สองเป็นพื้นที่ของหน้าต่างที่แสงส่องผ่านได้ 50%\n\n**ตัวอย่าง 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 3 3 | 6 12 |\n| 1 2 | |\n| 5 3 | |\n| 2 2 | |\n\n**ตัวอย่าง 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 3 2 | 3 15 |\n| 0 3 | |\n| 2 4 | |",
        "metadata": {
            "problem_id": "toi3_filter",
            "problem_name": "toi3_filter",
            "source": "TOI",
            "tags": [
                "array",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tint x,w,h,n,a;\n\tcin>>w>>h>>n;\n\tint ar[w];\n\tmemset(ar,0,sizeof(ar));\n\twhile(n--){\n\t\tcin>>x>>a;\n\t\tfor(int i=x;i<x+a and i<w;i++){\n\t\t\tar[i]++;\n\t\t}\n\t}\n\tint half=0,no=0;\n\tfor(int i=0;i<w;i++){\n\t\tif(ar[i]==1){\n\t\t\thalf++;\n\t\t}\n\t\tif(ar[i]==0){\n\t\t\tno++;\n\t\t}\n\t}\n\tcout<<no*h<<' '<<half*h;\n\treturn 0;\n}"
        }
    },
    {
        "page_content": "**กระเบื้อง (Tiling)**\n\nห้องที่มหาวิทยาลัยขอนแก่นได้มีการปูพื้นกระเบื้องใหม่ ห้องมีหลายขนาดโดยทุกห้องจะเป็นสี่เหลี่ยมจัตุรัสที่มีขนาด n x n ($2\\le n\\le17$) ซึ่งทุกห้องจะมีมุมห้องด้านบนขวาที่จะไม่ปูกระเบื้อง\n\nกระเบื้องที่สั่งซื้อมาจะถูกนำมาติดกันเป็น \"ผืน\" โดยหนึ่งผืนจะมีลักษณะเป็นการนำกระเบื้องสามแผ่นมาวางติดกันเป็นรูปตัว L ซึ่งมีได้สี่แบบ ช่างปูกระเบื้องจะไม่หมุนกระเบื้อง ทำให้ลักษณะของผืนกระเบื้องจะมีลักษณะคงที่\n\nกระเบื้องทุกแผ่นจะมีหมายเลขเป็นจำนวนเต็มกำกับ (1-9) กระเบื้องที่มีหมายเลขเดียวกันและอยู่ติดกันจะถือว่าอยู่บน \"ผืน\" เดียวกัน\n\n**คำสั่ง**\n\nจงเขียนโปรแกรมเพื่อนับจำนวนผืนกระเบื้องที่มีลักษณะถูกต้อง (เป็นรูปตัว L ที่เกิดจากกระเบื้อง 3 แผ่น)\n\n**ข้อมูลนำเข้า**\n\nบรรทัดแรกเป็นเลขจำนวนเต็มบวก n ซึ่งบอกขนาดของห้อง ต่อจากนั้น n บรรทัด แสดงรายละเอียดการปูกระเบื้องขนาด n x n โดยแต่ละบรรทัดประกอบด้วยจำนวนเต็ม n ค่าคั่นด้วยช่องว่าง ซึ่งจำนวนเต็ม k ($1\\le k\\le9$) แต่ละตัวคือหมายเลขของกระเบื้อง ทั้งนี้จำนวนเต็ม 0 แทนมุมห้องที่ไม่ได้ปูกระเบื้อง\n\n**ข้อมูลส่งออก**\n\nมีจำนวนเต็มค่าเดียว ซึ่งแทนจำนวนผืนกระเบื้องที่ถูกต้อง\n\n**ตัวอย่าง 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 1 |\n| 1 1 0 | |\n| 1 2 2 | |\n| 3 2 2 | |\n\n**ตัวอย่าง 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 5 |\n| 2 2 9 0 | |\n| 2 3 9 9 | |\n| 1 3 3 2 | |\n| 1 1 2 2 | |",
        "metadata": {
            "problem_id": "toi3_tile",
            "problem_name": "toi3_tile",
            "source": "TOI",
            "tags": [
                "array",
                "string",
                "implementation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple> // For std::tuple, though not directly used in the refactor below.\n\n// Using standard namespace, but it's generally good practice to qualify names (e.g., std::cout)\n// in larger projects to avoid name collisions. For competitive programming, 'using namespace std;' is common.\nusing namespace std;\n\n// Type aliases for better readability\nusing LongLong = long long;\nusing PairInt = pair<int, int>;\n\n// Global grid (adjacency matrix for a 2D space)\n// It's declared globally because it's modified by the `bfs` function.\n// Using a global variable for the grid is common in competitive programming\n// for simplicity, but passing it by reference would be a more encapsulated design.\nvector<vector<int>> grid_data;\n\n// Directions for moving in a 2D grid (right, left, down, up)\n// These arrays are constant and define the possible moves from a cell to its neighbors.\nconst int DR[] = {1, -1, 0, 0}; // Change in row (for right, left, no change for up/down)\nconst int DC[] = {0, 0, 1, -1}; // Change in column (no change for right/left, for down, up)\n\n/*\n    Overall Idea:\n\n    This program identifies and counts specific \"L-shaped\" formations of identical numbers\n    within a square grid. It uses a Breadth-First Search (BFS) algorithm to traverse\n    connected components of the same number.\n\n    The BFS function `find_and_mark_l_shape` takes a starting cell (row, column) and the grid size.\n    It explores all adjacent cells with the same number, effectively finding a connected component.\n    During the traversal, it also counts the number of cells in the component and tracks\n    the directions in which the component extends (up, down, left, right from the initial cell's perspective).\n    Cells visited during the BFS are marked as '0' to prevent re-visiting and re-counting.\n\n    After the BFS completes for a component, it checks if:\n    1. The component consists of exactly 3 cells.\n    2. The component forms an 'L' shape. An 'L' shape in this context is defined as having\n       at most one extension in the vertical directions (up or down) and at most one extension\n       in the horizontal directions (left or right). This effectively means it extends in\n       one vertical direction and one horizontal direction from a central point.\n\n    The main function iterates through each cell of the grid. If a cell contains a non-zero number\n    (meaning it hasn't been visited as part of a previous component), it initiates a BFS.\n    If the BFS identifies an 'L-shaped' component, a counter is incremented.\n    Finally, the total count of 'L-shaped' formations is printed.\n*/\n\n// Function to perform BFS and check for L-shape\n// Parameters:\n// - start_r: Starting row for BFS\n// - start_c: Starting column for BFS\n// - n: Size of the square grid (n x n)\n// Returns true if an L-shaped component of size 3 is found, false otherwise.\nbool find_and_mark_l_shape(int start_r, int start_c, int n) {\n    int target_value = grid_data[start_r][start_c]; // The value of the current connected component\n    queue<PairInt> q;\n    q.push({start_r, start_c});\n    grid_data[start_r][start_c] = 0; // Mark as visited by setting to 0\n\n    int component_size = 0;\n    // Track extensions in each direction relative to any cell in the component, not just the start.\n    // This naming (up, down, left, right) refers to the *connections* made in those directions,\n    // not necessarily the extent of the component itself.\n    // Let's refine these to be more descriptive of connections in 4 cardinal directions.\n    int connections_right = 0;\n    int connections_left = 0;\n    int connections_down = 0;\n    int connections_up = 0;\n\n    while (!q.empty()) {\n        PairInt current_cell = q.front();\n        q.pop();\n        int r = current_cell.first;\n        int c = current_cell.second;\n        component_size++;\n\n        // Explore neighbors\n        for (int i = 0; i < 4; ++i) { // Iterate through the 4 directions\n            int next_r = r + DR[i];\n            int next_c = c + DC[i];\n\n            // Check if the neighbor is within grid boundaries and has the target value (and not visited)\n            if (next_r >= 0 && next_r < n && next_c >= 0 && next_c < n && grid_data[next_r][next_c] == target_value) {\n                // Mark as visited before adding to queue to prevent cycles and redundant processing\n                grid_data[next_r][next_c] = 0;\n                q.push({next_r, next_c});\n\n                // Count connections made in each direction\n                if (i == 0) connections_right++; // Moving right (DR[0]=1)\n                else if (i == 1) connections_left++; // Moving left (DR[1]=-1)\n                else if (i == 2) connections_down++; // Moving down (DC[2]=1)\n                else if (i == 3) connections_up++; // Moving up (DC[3]=-1)\n            }\n        }\n    }\n\n    // An L-shape of 3 cells will have a total of 2 unique connections from the \"corner\" cell\n    // to its two \"arms\". The sum of connection counts for horizontal and vertical movements\n    // from all cells in the component should reflect this.\n    // The condition (up + d <= 1) && (l+r <= 1) seems to be checking if the component\n    // has at most one \"vertical\" connection and at most one \"horizontal\" connection\n    // across all its cells. This is a characteristic of a 3-cell L-shape.\n    // For a 3-cell L-shape, 'up+d' should be 1 (one vertical arm) and 'l+r' should be 1 (one horizontal arm).\n    // The original code implies that if it's <= 1 for both, it's an L-shape.\n    // A straight line of 3 cells (e.g., xxx or x x x) would also satisfy up+d <= 1 and l+r <= 1,\n    // as it would only have horizontal or vertical connections, but not both at the same time.\n    // However, the component_size == 3 ensures it's not just a single cell or two cells.\n    // A straight line of 3 cells would have (up+d == 0 and l+r == 2) OR (up+d == 2 and l+r == 0).\n    // So (up+d <= 1 && l+r <= 1) *combined with component_size == 3* correctly identifies L-shapes.\n    return (component_size == 3) && (connections_up + connections_down <= 1) && (connections_left + connections_right <= 1);\n}\n\nint main() {\n    // Optimize C++ standard streams for competitive programming\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int n;\n    cin >> n; // Read grid size\n\n    // Resize the global grid_data to n x n\n    // No need for n+2 padding unless boundary conditions require it (which they don't here with proper checks)\n    grid_data.resize(n, vector<int>(n));\n\n    // Read grid values\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            cin >> grid_data[i][j];\n        }\n    }\n\n    int l_shape_count = 0; // Counter for L-shaped formations\n\n    // Iterate through each cell of the grid\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            // If the cell contains a non-zero value, it's part of an unvisited component\n            if (grid_data[i][j] != 0) {\n                if (find_and_mark_l_shape(i, j, n)) {\n                    l_shape_count++;\n                }\n            }\n        }\n    }\n\n    cout << l_shape_count << endl; // Print the total count\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ขุมทรัพย์ผจญภัย (Treasure)**\n\nในการเดินทางผจญภัยเพื่อค้นหาขุมทรัพย์ จะมีการใช้แผนที่ซึ่งบอกทิศทางและระยะทาง โดยการเดินทางเริ่มต้นที่พิกัด (0, 0) ทิศทางจะใช้สัญลักษณ์ N, NE, E, SE, S, SW, W, NW\n\n**คำสั่ง**\n\nจงเขียนโปรแกรมเพื่อคำนวณหาพิกัดของขุมทรัพย์ (x, y) และหาระยะห่างระหว่างจุดเริ่มต้น (0,0) ไปยังพิกัดของขุมทรัพย์\n\n**ข้อมูลนำเข้า**\n\nข้อมูลนำเข้ามี 1 บรรทัด ประกอบด้วยระยะทางและทิศทางการเดินทางหลายชุด แต่ละชุดคั่นด้วยช่องว่าง ในแต่ละชุดประกอบด้วยจำนวนเต็มบวก k ($1\\le k\\le999$) บอกระยะทาง และตัวอักษรหนึ่งหรือสองตัวเพื่อบอกทิศทาง ข้อมูลชุดสุดท้ายจะมีเฉพาะตัวอักขระ * เพื่อบอกการสิ้นสุดของข้อมูล\n\n**ผลลัพธ์**\n\n* **บรรทัดแรก** แสดงพิกัดของขุมทรัพย์ เป็นลำดับตัวเลขของแกน x และแกน y ทศนิยม 3 ตำแหน่ง คั่นด้วยช่องว่าง\n* **บรรทัดที่สอง** บอกระยะห่างจากจุดเริ่มต้น (0,0) ไปยังพิกัดของขุมทรัพย์ เป็นตัวเลขทศนิยม 3 ตำแหน่ง\n\n**ตัวอย่าง 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3N 1E 1N 3E 2S 1W * | 3.000 2.000 |\n| | 3.606 |\n\n**ตัวอย่าง 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6NW * | -4.243 4.243 |\n| | 6.000 |",
        "metadata": {
            "problem_id": "toi3_treasure",
            "problem_name": "toi3_treasure",
            "source": "TOI",
            "tags": [
                "math",
                "string",
                "parsing"
            ],
            "solution_code": "#include <iostream>   // For input/output operations (cin, cout)\n#include <string>     // For string manipulation\n#include <cmath>      // For sqrt (square root) function\n#include <iomanip>    // For setprecision and fixed manipulators (for printing double with specific precision)\n\n/*\n    Overall Idea:\n\n    This program simulates movement on a 2D plane, starting from the origin (0,0).\n    It continuously reads movement commands, each consisting of a numerical value\n    and a cardinal or intercardinal direction (e.g., \"10N\", \"5SE\").\n\n    For each command, it updates the current position by adding or subtracting\n    the value to either the North-South (y-axis) or East-West (x-axis) coordinate.\n    Diagonal movements (NE, NW, SE, SW) distribute the value equally across\n    both axes, scaled by 1/sqrt(2) to maintain the given distance along the diagonal.\n\n    The program continues processing commands until it encounters a single asterisk \"*\"\n    as input. At that point, it calculates and prints:\n    1. The final East-West and North-South coordinates.\n    2. The total Euclidean distance (straight-line distance) from the origin\n       to the final position.\n    All numerical outputs are formatted to three decimal places.\n*/\nint main() {\n    // Optimize C++ standard streams for competitive programming.\n    // This unties cin/cout and disables synchronization with C's stdio.\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    double east_west_coordinate = 0.0; // Represents movement along the X-axis\n    double north_south_coordinate = 0.0; // Represents movement along the Y-axis\n\n    std::string command_input;\n    // Continuously read commands until the termination signal is received.\n    while (std::cin >> command_input) {\n        // Check for the termination command.\n        if (command_input == \"*\") {\n            // Set output precision to three decimal places and use fixed-point notation.\n            std::cout << std::fixed << std::setprecision(3);\n\n            // Print the final East-West and North-South coordinates.\n            std::cout << east_west_coordinate << \" \" << north_south_coordinate << std::endl;\n\n            // Calculate and print the Euclidean distance from the origin.\n            double distance_from_origin = std::sqrt(east_west_coordinate * east_west_coordinate + north_south_coordinate * north_south_coordinate);\n            std::cout << distance_from_origin << std::endl;\n\n            return 0; // Terminate the program.\n        }\n\n        // --- Parse the command input ---\n        // Find the split point between the numeric value and the direction string.\n        size_t i = 0;\n        while (i < command_input.length() && std::isdigit(command_input[i])) {\n            i++;\n        }\n\n        // Extract the numerical value (distance).\n        int value = std::stoi(command_input.substr(0, i));\n        // Extract the direction string.\n        std::string direction = command_input.substr(i);\n\n        // --- Apply the movement based on direction ---\n        // Use a constant for 1/sqrt(2) to improve readability and avoid redundant calculations.\n        const double diagonal_factor = 1.0 / std::sqrt(2.0);\n\n        if (direction == \"N\") {\n            north_south_coordinate += value;\n        } else if (direction == \"S\") {\n            north_south_coordinate -= value;\n        } else if (direction == \"E\") {\n            east_west_coordinate += value;\n        } else if (direction == \"W\") {\n            east_west_coordinate -= value;\n        } else if (direction == \"NE\") {\n            east_west_coordinate += value * diagonal_factor;\n            north_south_coordinate += value * diagonal_factor;\n        } else if (direction == \"NW\") {\n            east_west_coordinate -= value * diagonal_factor;\n            north_south_coordinate += value * diagonal_factor;\n        } else if (direction == \"SE\") {\n            east_west_coordinate += value * diagonal_factor;\n            north_south_coordinate -= value * diagonal_factor;\n        } else if (direction == \"SW\") {\n            east_west_coordinate -= value * diagonal_factor;\n            north_south_coordinate -= value * diagonal_factor;\n        }\n        // No 'else' needed here, as invalid directions are simply ignored.\n    }\n\n    return 0; // Should not be reached in typical execution if '*' is always provided.\n}"
        }
    },
    {
        "page_content": "**กุญแจคุโรมาตี้ (Cromartie Key)**\n\nกุญแจคุโรมาตี้ประกอบด้วย แม่กุญแจ จำนวน 2 แถว และลูกกุญแจ จำนวน 1 แถว สร้างจากตัวอักษรภาษาอังกฤษพิมพ์ใหญ่ ('A'-'Z') โดยที่แม่กุญแจมีความยาว L ตัวอักษรและลูกกุญแจมีความยาว K ตัวอักษร\n\nลูกกุญแจ จะเลื่อนเข้าไประหว่างแม่กุญแจ จากซ้ายไปขวา ครั้งละ 1 ตำแหน่ง ในขณะที่ลูกกุญแจเลื่อนเข้าไปแต่ละครั้ง ณ ตำแหน่งแนวตั้งที่ทับกัน จะมีตัวอักษรอยู่ 3 ตัว ได้แก่ ตัวอักษรของลูกกุญแจ (x), ของแม่กุญแจแถวบน (a), และแถวล่าง (b) เราจะนำตัวอักษรทั้งสามตัวนี้มาเรียงกันตามลำดับจาก A ไปหา Z แล้วแทนค่า x ในลูกกุญแจด้วยตัวอักษรกึ่งกลาง แต่จะไม่เปลี่ยนแปลงตัวอักษรของแม่กุญแจ\n\nการเลื่อนลูกกุญแจจะสิ้นสุดลงเมื่อตัวอักษรด้านซ้ายสุดของลูกกุญแจ ผ่านตัวอักษรตำแหน่งขวาสุดของแม่กุญแจไปแล้ว\n\nจงเขียนโปรแกรมจำลองการทำงานของกุญแจคุโรมาตี้ และแสดงผลลัพธ์สุดท้ายของตัวอักษรที่อยู่ในลูกกุญแจ\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** เป็นค่าความยาวของแม่กุญแจ L ($1\\\\le L\\\\le127$) และค่าความยาวของลูกกุญแจ K ($1\\\\le K\\\\le127$) คั่นด้วยช่องว่าง\n  * **บรรทัดที่สองและสาม** เป็นตัวอักษรของแม่กุญแจ แถวบน และล่าง ตามลำดับ\n  * **บรรทัดที่สี่** เป็นตัวอักษรของลูกกุญแจ\n\n**ข้อมูลส่งออก**\n\nตัวอักษรของลูกกุญแจหลังจากสิ้นสุดกระบวนการ\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 | ตัวอย่างที่ 4 |\n| :--- | :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 4 3 | 1 4 | 3 1 | 2 2 |\n| BOAT | A | ANT | AS |\n| HALF | Z | FAN | IT |\n| KEY | MAKE | J | AS |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| HFH | MAKE | N | SS |",
        "metadata": {
            "problem_id": "toi4_key",
            "problem_name": "toi4_key",
            "source": "TOI",
            "tags": [
                "string",
                "implementation",
                "simulation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int length, keyLength;\n    std::cin >> length >> keyLength;\n\n    std::string line1, line2, keyString;\n    std::cin >> line1 >> line2 >> keyString;\n\n    std::vector<int> maxValues(length);\n    std::vector<int> minValues(length);\n\n    for (int i = 0; i < length; ++i) {\n        int char1 = line1[i] - 'A';\n        int char2 = line2[i] - 'A';\n        maxValues[i] = std::max(char1, char2);\n        minValues[i] = std::min(char1, char2);\n    }\n\n    for (int i = 0; i < keyLength; ++i) {\n        int currentNum = keyString[i] - 'A';\n        for (int j = 0; j < length; ++j) {\n            currentNum = std::min(maxValues[j], currentNum);\n            currentNum = std::max(minValues[j], currentNum);\n        }\n        std::cout << static_cast<char>('A' + currentNum);\n    }\n\n    std::cout << std::endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ขนส่งสินค้า (Logistics)**\n\nโรงงานคุโรมาตี้ ('X') ต้องการขนส่งสินค้าไปยังลูกค้า ('Y') ผ่านจุดถ่ายสินค้า M จุด ('a'...'z') ค่าใช้จ่ายสุทธิ (Cost) ในการขนส่งสินค้าระหว่างสถานี จะมีค่าเท่ากับ **มัธยฐาน (Median)** ของค่าใช้จ่ายของรถทุกคันที่ประจำอยู่บนเส้นทางนั้น\n\n**หมายเหตุ มัธยฐาน (Median):** เป็นค่ากลางของข้อมูลที่เรียงลำดับแล้ว ถ้าจำนวนข้อมูล (n) เป็นเลขคี่ มัธยฐานคือข้อมูลลำดับที่ (n+1)/2 ถ้า n เป็นเลขคู่ มัธยฐานคือค่าเฉลี่ยของข้อมูลลำดับที่ n/2 และ (n/2)+1\n\nจงเขียนโปรแกรมเพื่อคำนวณค่าใช้จ่ายในการขนส่งสินค้าสุทธิที่เกิดขึ้น\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** แสดงจำนวน N ซึ่งแทนจำนวนรถทั้งหมด ($2\\\\le N\\\\le270$)\n  * **N บรรทัดถัดมา** แต่ละบรรทัดแสดงข้อมูลของรถแต่ละคัน โดยระบุ ชื่อสถานีต้นทางและปลายทาง ตามด้วยค่าใช้จ่าย C ($1\\\\le C\\\\le20$) คั่นด้วยช่องว่าง\n\n**ข้อมูลส่งออก**\n\n  * ถ้าไม่สามารถส่งสินค้าจาก X ไป Y ได้ให้แสดงข้อความ `broken`\n  * มิฉะนั้น ให้แสดงเส้นทางและค่าใช้จ่ายของแต่ละช่วงการเดินทาง (ทศนิยมหนึ่งตำแหน่ง) โดยเริ่มจาก X และบรรทัดสุดท้ายแสดงค่าใช้จ่ายสุทธิรวม (ทศนิยมหนึ่งตำแหน่ง)\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 |\n| :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 6 | 3 | 5 |\n| X a 1 | X a 2 | q Y 3 |\n| a b 4 | c b 3 | X a 1 |\n| b a 1 | b Y 3 | a b 2 |\n| b Y 3 | | t b 4 |\n| Y b 6 | | q t 5 |\n| b Y 2 | | |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| X a 1.0 | broken | X a 1.0 |\n| a b 2.5 | | a b 2.0 |\n| b Y 3.0 | | b t 4.0 |\n| 6.5 | | t q 5.0 |\n| | | q Y 3.0 |\n| | | 15.0 |",
        "metadata": {
            "problem_id": "toi4_logistics",
            "problem_name": "toi4_logistics",
            "source": "TOI",
            "tags": [
                "graph",
                "dijkstra",
                "sorting",
                "median"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define fr(i, a, b, c) for (int i = a; i < b; i += c)\n#define fre(i, a, b, c) for (int i = a; i >= b; i -= c)\n#define MAXN 1e9 + 5\n\nusing pii = pair<int, int>;\nusing tiii = tuple<int, int, int>;\n\nmap<char, map<char, vector<int>>> adjacency_list;\nmap<char, bool> visited_nodes;\nvector<tuple<char, char, float>> results;\n\nvoid calculate_median_and_traverse(char start_node) {\n    queue<char> nodes_queue;\n    nodes_queue.push(start_node);\n    float total_median_sum = 0.0;\n\n    while (!nodes_queue.empty()) {\n        char current_node = nodes_queue.front();\n        nodes_queue.pop();\n\n        visited_nodes[current_node] = true;\n\n        for (auto const& [neighbor_node, distances] : adjacency_list[current_node]) {\n            if (!visited_nodes[neighbor_node]) {\n                vector<int> sorted_distances = distances;\n                sort(sorted_distances.begin(), sorted_distances.end());\n\n                float median_value;\n                if (sorted_distances.size() % 2 == 0) {\n                    median_value = (float)(sorted_distances[sorted_distances.size() / 2 - 1] + sorted_distances[sorted_distances.size() / 2]) / 2.0;\n                } else {\n                    median_value = sorted_distances[sorted_distances.size() / 2];\n                }\n                total_median_sum += median_value;\n                results.push_back(make_tuple(current_node, neighbor_node, median_value));\n                nodes_queue.push(neighbor_node);\n            }\n        }\n    }\n\n    if (!visited_nodes['Y']) {\n        cout << \"broken\" << endl;\n        return;\n    }\n\n    for (const auto& result_entry : results) {\n        cout << get<0>(result_entry) << \" \" << get<1>(result_entry) << \" \" << setprecision(1) << fixed << get<2>(result_entry) << endl;\n    }\n    cout << setprecision(1) << fixed << total_median_sum << endl;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    int num_edges;\n    cin >> num_edges;\n\n    fr(i, 0, num_edges, 1) {\n        char node_u, node_v;\n        cin >> node_u >> node_v;\n        int distance_val;\n        cin >> distance_val;\n        adjacency_list[node_u][node_v].push_back(distance_val);\n        adjacency_list[node_v][node_u].push_back(distance_val);\n    }\n\n    calculate_median_and_traverse('X');\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**เทือกเขาคุโรมาตี้ (Cromartie Mountain)**\n\nนักสำรวจได้สำรวจเทือกเขาซึ่งประกอบด้วยภูเขารูปสามเหลี่ยมหน้าจั่วจำนวน N ลูก ($1\\\\le N\\\\le21$) โดยบันทึกตำแหน่งเริ่มต้น S ($1\\\\le S\\\\le60$) และความสูง H ($1\\\\le H\\\\le10$) ของแต่ละลูก ภูเขาแต่ละลูกประกอบด้วยสัญลักษณ์ เนินเขา (`/` หรือ `\\`) และพื้นที่ป่าไม้ ('X')\n\nจงเขียนโปรแกรมวาดรูปเทือกเขาคุโรมาตี้ โดยมีเงื่อนไขการซ้อนทับดังนี้:\n\n  * ตำแหน่งที่ เนินเขา (`\\` และ `/`) ของภูเขาสองลูกเหลื่อมกันให้แทนด้วย `v`\n  * ตำแหน่งที่ เนินเขา ของภูเขาลูกหนึ่งเหลื่อมกับพื้นที่ป่าไม้ของอีกลูกหนึ่ง ให้ถือว่าเป็นพื้นที่ป่าไม้ (`X`)\n  * พื้นที่ว่างให้แสดงด้วยเครื่องหมายจุด (`.`)\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** จำนวนภูเขา N\n  * **N บรรทัดถัดมา** แสดงตำแหน่งเริ่มต้น S และความสูง H ของแต่ละลูก คั่นด้วยช่องว่าง\n\n**ข้อมูลส่งออก**\n\nแสดงรูปของเทือกเขา โดยความสูงของรูปเท่ากับความสูงของยอดเขาที่สูงที่สุด และความกว้างพอดีกับขอบซ้ายและขวาสุดของเทือกเขา\n\n**ตัวอย่างที่ 1**\n\n\\<pre\\>\n\\<b\\>ข้อมูลนำเข้า\\</b\\>\n3\n5 6\n2 4\n16 3\n\n\\<b\\>ข้อมูลส่งออก\\</b\\>\n........../..\n......./XX..\n.....././XXXX.\n.../XXvXXXXXX.../..\n../XXXXXXXXXXX./XX.\n./XXXXXXXXXXXXXvXXXX  \n\\</pre\\>\n\n**ตัวอย่างที่ 2**\n\n\\<pre\\>\n\\<b\\>ข้อมูลนำเข้า\\</b\\>\n5\n1 4\n6 7\n12 6\n21 5\n41 3\n\n\\<b\\>ข้อมูลส่งออก\\</b\\>\n...../....\n..../XX../..\n.../XXXX/XX...../..\n../../XXXXXXXXXX.../XX.\n./XX./XXXXXXXXXXXX./XXXX.\n/XXXXvXXXXXXXXXXXXXXvXXXXXX  \n/XXXXXXXXXXXXXXXXXXXXXXXXXXXX  \n\\</pre\\>",
        "metadata": {
            "problem_id": "toi4_mountain",
            "problem_name": "toi4_mountain",
            "source": "TOI",
            "tags": [
                "string",
                "implementation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n    std::cout.tie(NULL);\n\n    int num_triangles;\n    std::cin >> num_triangles;\n\n    std::vector<std::vector<char>> grid(15, std::vector<char>(99, '\\0'));\n    int max_height = -1;\n    int max_width = -1;\n\n    for (int t = 0; t < num_triangles; ++t) {\n        int start_column, height;\n        std::cin >> start_column >> height;\n\n        max_height = std::max(max_height, height);\n        max_width = std::max(max_width, start_column + 2 * height - 1);\n\n        for (int i = 1; i <= height; ++i) {\n            for (int j = start_column + i - 1; j < start_column + 2 * height - i + 1; ++j) {\n                if (j == start_column + i - 1) {\n                    if (grid[i][j] == 'X') {\n                        continue;\n                    }\n                    if (grid[i][j] == '\\\\') {\n                        grid[i][j] = 'v';\n                    } else {\n                        grid[i][j] = '/';\n                    }\n                } else if (j == start_column + 2 * height - i) {\n                    if (grid[i][j] == 'X') {\n                        continue;\n                    }\n                    if (grid[i][j] == '/') {\n                        grid[i][j] = 'v';\n                    } else {\n                        grid[i][j] = '\\\\';\n                    }\n                } else {\n                    grid[i][j] = 'X';\n                }\n            }\n        }\n    }\n\n    for (int i = max_height; i > 0; --i) {\n        for (int j = 1; j <= max_width; ++j) {\n            if (grid[i][j]) {\n                std::cout << grid[i][j];\n            } else {\n                std::cout << '.';\n            }\n        }\n        std::cout << '\\n';\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**อาคารเรียนคุโรมาตี้ (Cromartie School)**\n\nโรงเรียนมีที่ดินเป็นรูปสี่เหลี่ยมผืนผ้า กว้าง W เมตร และยาว L เมตร (ไม่เกินด้านละ 64 เมตร) พื้นที่แต่ละตารางเมตรเป็นหนึ่งในสามรูปแบบ: ที่ดินว่าง ('S'), ส่วนของแอ่งน้ำ ('P'), หรือที่ดินที่มีต้นไม้ ('T')\n\nผู้อำนวยการต้องการสร้างอาคารเรียนรูปสี่เหลี่ยมจัตุรัสที่มีพื้นที่มากที่สุด โดยต้องตั้งอยู่บนที่ดินว่างเท่านั้น แอ่งน้ำสามารถถมเป็นที่ดินว่างได้แต่ต้องถมทั้งแอ่ง แต่ที่ดินที่มีต้นไม้ไม่สามารถเปลี่ยนแปลงได้\n\nหากมีบริเวณที่สร้างอาคารขนาดใหญ่ที่สุดได้หลายแห่ง ให้เลือกบริเวณที่ต้องถมแอ่งน้ำเป็นจำนวนน้อยที่สุด\n\nจงเขียนโปรแกรมคำนวณพื้นที่ที่มากที่สุดสำหรับสร้างอาคารเรียน และระบุจำนวนแอ่งน้ำที่ต้องถม\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** มีจำนวนเต็มบวกสองจำนวน คือ W และ L คั่นด้วยช่องว่าง\n  * **L บรรทัดถัดมา** ระบุข้อมูลของที่ดิน ในแต่ละบรรทัดเป็นตัวอักษรติดกัน W ตัว\n\n**ข้อมูลส่งออก**\n\nมี 1 บรรทัด ประกอบด้วยจำนวนเต็มสองจำนวน a และ b คั่นด้วยช่องว่าง โดย a คือพื้นที่ที่มากที่สุด และ b คือจำนวนแอ่งน้ำที่ต้องถม (ถ้าสร้างอาคารไม่ได้เลย ให้ a และ b เป็น 0)\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 | ตัวอย่างที่ 4 |\n| :--- | :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 8 6 | 6 5 | 2 2 | 11 5 |\n| SSSSSSSS | TSSSSS | TT | SSSSSTSSSSS |\n| SSSSSSSS | TTSSSS | TT | SSPSSTSSPSS |\n| SPPSSSSS | SSSPSS | | SPPPSTSSSSS |\n| SSSPSSSS | SSPPPS | | SSPSSTSSPSS |\n| SSSSSTTS | TSSPST | | SSSSSTSSSSS |\n| PSSSSTSS | | | |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| 25 2 | 16 1 | 0 0 | 25 1 |",
        "metadata": {
            "problem_id": "toi4_school",
            "problem_name": "toi4_school",
            "source": "TOI",
            "tags": [
                "array",
                "string",
                "brute-force",
                "greedy",
                "stack",
                "queue",
                "simulation",
                "implementation",
                "geometry"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int MAX_DIM = 65;\nint grid_width, grid_height;\nint tree_count_prefix_sum[MAX_DIM][MAX_DIM];\nstring grid_data[MAX_DIM];\nbool possible_area_found = false;\nint min_pond_count = INT_MAX;\n\npair<int, int> directions[4] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nint count_connected_ponds(int end_y, int end_x, int square_size) {\n    int temp_grid[MAX_DIM][MAX_DIM];\n    int current_pond_count = 0;\n    queue<pair<int, int>> q;\n\n    for (int i = 1; i <= grid_height; ++i) {\n        for (int j = 1; j <= grid_width; ++j) {\n            temp_grid[i][j] = (grid_data[i][j] == 'P' ? 1 : 0);\n        }\n    }\n\n    for (int i = end_y - square_size + 1; i <= end_y; ++i) {\n        for (int j = end_x - square_size + 1; j <= end_x; ++j) {\n            if (temp_grid[i][j] == 1) {\n                current_pond_count++;\n                q.push({i, j});\n                while (!q.empty()) {\n                    auto [current_y, current_x] = q.front();\n                    q.pop();\n                    temp_grid[current_y][current_x] = 0;\n\n                    for (int d = 0; d < 4; ++d) {\n                        int neighbor_y = current_y + directions[d].first;\n                        int neighbor_x = current_x + directions[d].second;\n\n                        if (neighbor_y >= 1 && neighbor_y <= grid_height &&\n                            neighbor_x >= 1 && neighbor_x <= grid_width &&\n                            temp_grid[neighbor_y][neighbor_x] == 1) {\n                            q.push({neighbor_y, neighbor_x});\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return current_pond_count;\n}\n\nint main() {\n    cin.tie(NULL)->sync_with_stdio(false);\n\n    cin >> grid_width >> grid_height;\n\n    for (int i = 1; i <= grid_height; ++i) {\n        cin >> grid_data[i];\n        grid_data[i] = \" \" + grid_data[i];\n        for (int j = 1; j <= grid_width; ++j) {\n            tree_count_prefix_sum[i][j] = tree_count_prefix_sum[i][j - 1] + tree_count_prefix_sum[i - 1][j] - tree_count_prefix_sum[i - 1][j - 1];\n            if (grid_data[i][j] == 'T') {\n                tree_count_prefix_sum[i][j]++;\n            }\n        }\n    }\n\n    for (int sz = min(grid_width, grid_height); sz >= 1; --sz) {\n        for (int i = sz; i <= grid_height; ++i) {\n            for (int j = sz; j <= grid_width; ++j) {\n                if ((tree_count_prefix_sum[i][j] - tree_count_prefix_sum[i][j - sz] - tree_count_prefix_sum[i - sz][j] + tree_count_prefix_sum[i - sz][j - sz]) == 0) {\n                    possible_area_found = true;\n                    min_pond_count = min(min_pond_count, count_connected_ponds(i, j, sz));\n                }\n            }\n        }\n        if (possible_area_found) {\n            cout << sz * sz << ' ' << min_pond_count;\n            return 0;\n        }\n    }\n\n    cout << 0 << ' ' << 0;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**จอมกดส่งข้อความ (SMS Thumb)**\n\nกำหนดปุ่มกดโทรศัพท์มือถือและการวนของตัวอักษรเมื่อกดปุ่มซ้ำๆ ปุ่ม 1 ใช้สำหรับลบ (DEL) การเลื่อนนิ้วไปยังปุ่มใหม่ (หรือปุ่มเดิม) จะนับการกดเริ่มจากตัวอักษรแรกของปุ่มนั้นเสมอ\n\nจงเขียนโปรแกรมหาข้อความที่พิมพ์จากข้อมูลการสังเกตการณ์\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** จำนวนครั้งที่เลือกปุ่มกด N ($1\\\\le N\\\\le80$)\n  * **บรรทัดที่สอง** ปุ่มแรกที่กด S ($1\\\\le S\\\\le9$) และจำนวนครั้งที่กด M ($1\\\\le M\\\\le4096$)\n  * **N - 1 บรรทัดถัดมา** แต่ละบรรทัดประกอบด้วยตัวเลข 3 จำนวน: ทิศทางแนวนอน H, ทิศทางแนวตั้ง V, และจำนวนครั้งที่กด M\n      * H: -2 ถึง 2 (ลบคือซ้าย, บวกคือขวา)\n      * V: -2 ถึง 2 (ลบคือบน, บวกคือล่าง)\n\n**ข้อมูลส่งออก**\n\nแสดงข้อความที่พิมพ์ในบรรทัดเดียว ถ้าไม่ได้พิมพ์อะไรเลยให้แสดงคำว่า `null`\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 |\n| :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 4 | 2 | 5 |\n| 5 3 | 9 6 | 3 3 |\n| 1 0 3 | -2 -2 5 | 0 0 2 |\n| -1 1 3 | | -2 0 1 |\n| 1 -2 2 | | 2 1 3 |\n| | | 0 1 2 |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| LOVE | null | FOX |",
        "metadata": {
            "problem_id": "toi4_sms",
            "problem_name": "toi4_sms",
            "source": "TOI",
            "tags": [
                "string",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\t   \n    int n,st,num; cin >> n >> st >> num;\t   \n    const string sms[] = { \"exoworldgd\", \"-\", \"ABC\", \"DEF\", \"GHI\", \"JKL\", \"MNO\", \"PQRS\", \"TUV\", \"WXYZ\" };\t   \n    string ans; num--;\t   \n    if (sms[st] != \"-\") ans.push_back(sms[st][num % sms[st].size()]);\t   \n    n--;\t   \n    while (n--) {\t        \n        int u, v, m; cin >> u >> v >> m, m--;\t       \n        st += 3*v+u;\t       \n        if (sms[st] != \"-\") ans.push_back(sms[st][m % sms[st].size()]);\t       \n        else for (int i = 0; i <= m; i++) if (!ans.empty()) ans.pop_back();\t  \n    }\t   \n    if (ans.empty()) cout << \"null\";\t   \n    else cout << ans;\n}"
        }
    },
    {
        "page_content": "**ไต่อุณหภูมิ (Temperature is Rising)**\n\nเทือกเขาคุโรมาตี้มีพื้นที่เป็นรูปสี่เหลี่ยมจัตุรัสขนาด $M\\\\times M$ และมีอุณหภูมิแตกต่างกันในแต่ละตารางเมตร นักเดินทางหญิงเริ่มเดินทางจากตำแหน่ง (X, Y) โดยเธอสามารถเลือกเดินทางไปในทิศเหนือ, ตะวันออก, ใต้, และตะวันตก ครั้งละ 1 เมตร แต่ตำแหน่งที่เธอจะเดินไปนั้นจะต้องมีอุณหภูมิสูงกว่าตำแหน่งปัจจุบัน และไม่ใช่เขตหวงห้าม (แทนด้วยตัวเลข 100)\n\nจงเขียนโปรแกรมหาอุณหภูมิสูงสุดที่เป็นไปได้ ที่เธอสามารถเดินทางไปถึง\n\n**ข้อมูลนำเข้า**\n\n  * **บรรทัดแรก** ขนาดของเทือกเขา M ($1\\\\le M\\\\le20$)\n  * **บรรทัดที่สอง** พิกัดเริ่มต้น (X, Y) ($1\\\\le X, Y\\\\le M$) โดย (1, 1) คือมุมซ้ายบน\n  * **M บรรทัดถัดมา** แสดงอุณหภูมิ $T(-5\\\\le T\\\\le37)$ หรือ 100 ถ้าเป็นเขตหวงห้าม\n\n**ข้อมูลส่งออก**\n\nแสดงอุณหภูมิสูงสุดที่เป็นไปได้ ที่นักเดินทางสามารถไปถึง\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 |\n| :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 4 | 1 | 5 |\n| 2 1 | 1 1 | 4 2 |\n| 100 1 3 8 | 9 | 0 1 100 100 0 |\n| 0 2 1 4 | | 100 2 3 1 1 |\n| 2 3 5 100 | | 100 100 4 5 100 |\n| 0 8 8 100 | | 8 7 100 6 100 |\n| | | 7 100 100 100 9 |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| 8 | 9 | 6 |",
        "metadata": {
            "problem_id": "toi4_temp",
            "problem_name": "toi4_temp",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs"
            ],
            "solution_code": "#include <bits/stdc++.h>\n#define endll \"\\n\"\n#define sp \" \"\ntypedef long long ll;\nusing namespace std;\n\nconst int N=21;\nint n,x,y,ans=-6;\nint A[N][N];\nbool visited[N][N];\nint di[]={1,0,-1,0};\nint dj[]={0,1,0,-1};\n\nbool is_Valid(int i,int j){\n    if(i<0||j<0||i>=n||j>=n)return false;\n    return !visited[i][j];\n}\n\nvoid trvsal(int i,int j){\n    queue<pair<int,int>> q;\n    q.push({i,j});\n    visited[i][j]=true;\n\n    while(!q.empty()){\n        i=q.front().first;\n        j=q.front().second;\n        q.pop();\n        ans=max(ans,A[i][j]);\n        for(int k=0;k<4;k++){\n            if(is_Valid(i+di[k],j+dj[k])&&A[i][j]<A[i+di[k]][j+dj[k]]){\n                q.push({i+di[k],j+dj[k]});\n                visited[i+di[k]][j+dj[k]]=true;\n            }\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> n >> x >> y;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            cin >> A[i][j];\n            if(A[i][j]==100)A[i][j]=-6;\n        }\n    }\n    trvsal(y-1,x-1);\n    cout << ans;\n\n    return 0;\n }"
        }
    },
    {
        "page_content": "**กระโดดข้ามเส้น (Jump)**\n\nการแข่งขันกระโดดข้ามเส้นจะแข่งขันบนลู่วิ่งที่มีเส้นบอกระยะจำนวน N เส้นขีดคั่นไว้ที่ระยะต่าง ๆ ผู้เข้าแข่งขันจะต้องยืนที่เส้นบอกระยะเส้นใดเส้นหนึ่ง แล้วกระโดดไปให้ข้ามเส้นบอกระยะเป็นจำนวนมากที่สุดเท่าที่จะทำได้\n\nถ้าผู้เข้าแข่งขันเริ่มกระโดดที่เส้นบอกระยะที่ `a` และเมื่อกระโดดไปทางขวาแล้ว เส้นบอกระยะที่มีหมายเลขมากที่สุดที่เท้าของเขาข้ามหรือสัมผัสคือเส้นบอกระยะที่ `b` จะถือว่าเขาสามารถกระโดดข้ามเส้นบอกระยะได้เป็นจำนวน `b-a` เส้น\n\nถ้าผู้เข้าแข่งขันคนหนึ่งสามารถกระโดดได้ระยะมากที่สุด K หน่วย จงคำนวณว่าเขาสามารถกระโดดข้ามเส้นบอกระยะได้มากที่สุดกี่เส้น โดยสมมติว่าเขาเลือกเส้นบอกระยะที่เริ่มกระโดดที่ดีที่สุดแล้ว\n\n**ข้อมูลนำเข้า**\n\n* **บรรทัดแรก** ระบุจำนวนเต็ม 2 จำนวนคือ N และ K ($1 \\le N \\le 30,000$; $1 \\le K \\le 30,000$) โดยที่ N แทนจำนวนเส้นบอกระยะ และ K แทนระยะทางมากที่สุดที่กระโดดได้\n* **N บรรทัดถัดมา** ระบุตำแหน่งของเส้นบอกระยะ โดยแต่ละบรรทัดคือจำนวนเต็ม $X_i$ ($0 \\le X_i \\le 60,000$) แทนระยะห่างของเส้นบอกระยะเส้นที่ i จากเส้นเริ่มต้น (ข้อมูลตำแหน่งจะเรียงจากน้อยไปมาก)\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัดระบุจำนวนเต็มหนึ่งจำนวน แทนจำนวนเส้นบอกระยะที่มากที่สุดที่ผู้เข้าแข่งขันกระโดดข้ามได้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 11 6 | 4 |\n| 3 | |\n| 6 | |\n| 7 | |\n| 9 | |\n| 10 | |\n| 11 | |\n| 13 | |\n| 16 | |\n| 18 | |\n| 19 | |\n| 20 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 30000 | 1 |\n| 2000 | |\n| 35000 | |\n| 55000 | |",
        "metadata": {
            "problem_id": "toi5_jump",
            "problem_name": "toi5_jump",
            "source": "TOI",
            "tags": [
                "search",
                "binary-search"
            ],
            "solution_code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nconst int N=3*1e4;\nint A[N];\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    int n,k;\n    cin >> n >> k;\n    for(int i=0;i<n;i++)cin >> A[i];\n\n    int mx=-1;\n    for(int i=0;i<n;i++){\n        int x=A[i]+k;\n        int pos=upper_bound(A+i-1,A+n,x)-A-1;\n        mx=max(mx,pos-i);\n    }\n    cout << mx;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ราคาที่ดินสุดหรรษา (Happy Land)**\n\nโรนัลโด้ต้องการซื้อที่ดินรูปสี่เหลี่ยมขนาด $M \\times N$ ตารางกิโลเมตร ซึ่งแบ่งขายเป็นแปลงย่อยขนาด $1 \\times 1$ ตารางกิโลเมตร ที่ดินแต่ละแปลงมีราคาขายตั้งต้น แต่ราคาของที่ดินแต่ละแปลงที่ยังไม่ได้ขาย จะสูงขึ้น 10% ของราคาที่ดินแปลงที่ติดกัน (รวมแนวทแยง) ที่ถูกขายออกไปแล้ว\n\n**งานของคุณ**\n\nเขียนโปรแกรมเพื่อช่วยโรนัลโด้คำนวณจำนวนเงินที่น้อยที่สุดที่โรนัลโด้จะสามารถใช้ซื้อที่ดินได้ครบทุกแปลง โดยเลือก ลำดับการซื้อที่เหมาะสม\n\n**ข้อมูลนำเข้า**\n\n* **บรรทัดแรก** ระบุจำนวนเต็มบวกสองจำนวน M และ N ($1\\le M\\le3$ และ $1\\le N\\le3$)\n* **M บรรทัดถัดไป** ระบุมูลค่าเริ่มต้นของแปลงที่ดิน โดยในแต่ละบรรทัดมี N จำนวน แต่ละจำนวนคั่นด้วยช่องว่าง\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด แสดงจำนวนเงินที่น้อยที่สุดที่ใช้ซื้อที่ดินได้ทั้งหมด โดยแสดงเป็นทศนิยม 2 ตำแหน่ง\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 |\n| :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 1 2 | 2 2 | 3 3 |\n| 500 750 | 500 750 | 500000 750000 1000000 |\n| | 1000 800 | 500000 1200000 1000000 |\n| | | 1000000 800000 750000 |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| 1300.00 | 3455.00 | 9086500.00 |",
        "metadata": {
            "problem_id": "toi5_land",
            "problem_name": "toi5_land",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "recursion",
                "backtracking"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nvector<int> permutation_vector;\ndouble current_grid[5][5];\ndouble initial_grid_values[5][5];\ndouble minimum_total_cost = numeric_limits<double>::max();\n\nint main() {\n    cin.tie(0)->sync_with_stdio(0);\n\n    int rows, cols;\n    cin >> rows >> cols;\n\n    for (int i = 1; i <= rows; ++i) {\n        for (int j = 1; j <= cols; ++j) {\n            cin >> initial_grid_values[i][j];\n        }\n    }\n\n    for (int i = 1; i <= rows * cols; ++i) {\n        permutation_vector.push_back(i);\n    }\n\n    do {\n        memcpy(current_grid, initial_grid_values, sizeof(initial_grid_values));\n        double current_total_cost = 0;\n\n        for (int cell_index : permutation_vector) {\n            int r = (cell_index - 1) / cols + 1;\n            int c = (cell_index - 1) % cols + 1;\n\n            current_total_cost += current_grid[r][c];\n\n            if (current_total_cost >= minimum_total_cost) {\n                break;\n            }\n\n            double cost_increase_for_neighbors = current_grid[r][c] / 10.0;\n\n            for (int neighbor_r = r - 1; neighbor_r <= r + 1; ++neighbor_r) {\n                for (int neighbor_c = c - 1; neighbor_c <= c + 1; ++neighbor_c) {\n                    if (neighbor_r == r && neighbor_c == c) {\n                        continue;\n                    }\n                    if (neighbor_r < 1 || neighbor_r > rows || neighbor_c < 1 || neighbor_c > cols || current_grid[neighbor_r][neighbor_c] == -1) {\n                        continue;\n                    }\n                    current_grid[neighbor_r][neighbor_c] += cost_increase_for_neighbors;\n                }\n            }\n            current_grid[r][c] = -1; // Mark as visited/processed\n        }\n        minimum_total_cost = min(minimum_total_cost, current_total_cost);\n    } while (next_permutation(permutation_vector.begin(), permutation_vector.end()));\n\n    cout << fixed << setprecision(2) << minimum_total_cost << endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ถอดรหัสแห่งความรัก (Love Key Decoder)**\n\nโรมิโอส่งข้อความ (A-Z) ไปให้จูเลียตโดยเข้ารหัสแบบพิเศษ โรมิโอจะนำข้อความมาแปลงทีละตัวอักษรเป็นเลขฐานสองของรหัส ASCII (8 บิต) จากนั้นนำตัวเลขฐานสองที่ได้มาเข้ารหัสอีกครั้งด้วยเครื่องจักรเข้ารหัสซึ่งมี 4 สถานะ (S1, S2, S3, S4) และเริ่มต้นที่สถานะ S1\n\nเครื่องจักรจะอ่านข้อมูลเข้า (p) ครั้งละ 1 บิต และเปลี่ยนสถานะไปตามเส้นเชื่อมพร้อมกับบันทึกข้อมูลออก (q) ขนาด 2 บิต ตามเงื่อนไข `p/q` ที่ระบุบนเส้นเชื่อม เมื่อเข้ารหัสครบทุกบิตแล้ว หากสถานะสุดท้ายไม่ใช่ S1 เครื่องจักรจะต้องทำงานเพิ่มเติม (โดยไม่มีข้อมูลเข้า) เพื่อกลับไปยังสถานะ S1 โดยเลือกเส้นทางที่เปลี่ยนสถานะน้อยที่สุด\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อช่วยจูเลียตถอดรหัสข้อความจากข้อมูลที่ได้รับ\n\n**ข้อมูลนำเข้า**\n\n* **บรรทัดแรก** ระบุจำนวนเต็ม N ($1\\le N\\le30$) แทนจำนวนบรรทัดของข้อมูลที่เข้ารหัสแล้ว\n* **N บรรทัดถัดมา** แสดงข้อมูลที่เข้ารหัสแล้วครั้งละ 16 บิต (อาจน้อยกว่าสำหรับบรรทัดสุดท้าย)\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัดแสดงข้อความที่ถอดรหัสแล้ว\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 |\n| :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 3 | 4 |\n| 0011100010000110 | 0011101100000011 |\n| 0100100010001000 | 1000101100001110 |\n| 1011 | 1111101100001101 |\n| | 0100101100111011 |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| WU | ABCD |",
        "metadata": {
            "problem_id": "toi5_lkd",
            "problem_name": "toi5_lkd",
            "source": "TOI",
            "tags": [
                "bit-manipulation",
                "string",
                "parsing"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n;cin>>n;\n    int now=1;\n    while(n--){\n        vector<int> v;\n        string s;cin>>s;\n        if(s.size()!=16)break;\n        for(int i=0;i<16;i+=2){\n            int a=s[i]-'0',b=s[i+1]-'0';\n            if(now==1){\n                v.push_back(b);\n                now+=b;\n            }\n            else if(now==2){\n                v.push_back(b);\n                now+=1+b;\n            }\n            else if(now==3){\n                v.push_back(1-b);\n                now-=(1+b);\n            }\n            else{\n                v.push_back(1-b);\n                now-=b;\n            }\n        }\n        int ans=0;\n        for(auto x:v)ans=ans*2+x;\n        cout<<(char)ans;\n    }\n    return 0;\n}"
        }
    },
    {
        "page_content": "**วงล้อแปลงตัวเลข (Number Substitution Wheels)**\n\nในการเข้ารหัสตัวเลขชุดหนึ่ง ต้องใช้วงล้อแปลงตัวเลข 3 วง และกุญแจไขรหัส 3 หลัก แต่ละวงล้อมีสมาชิกเป็นตัวเลข 1-9 ในลำดับที่แตกต่างกัน กุญแจไขรหัสจะใช้กำหนดตำแหน่งเริ่มต้นของแต่ละวงล้อ\n\n**การเข้ารหัสตัวเลขแต่ละตัว:**\n1.  ตัวเลข Input เป็นดัชนีชี้ไปยังค่าใน **วงล้อที่ 1**\n2.  ค่าที่ได้จากขั้นตอนที่ 1 เป็นดัชนีชี้ไปยังค่าใน **วงล้อที่ 2**\n3.  ค่าที่ได้จากขั้นตอนที่ 2 เป็นดัชนีชี้ไปยังค่าใน **วงล้อที่ 3** ซึ่งค่านี้คือตัวเลข Output\n\n**การเลื่อนวงล้อ:**\nหลังจากการเข้ารหัสแต่ละครั้ง วงล้อจะเลื่อนตำแหน่งดังนี้:\n* **วงล้อที่ 1:** เลื่อนขึ้น เท่ากับค่าตัวแรกของกุญแจไขรหัส\n* **วงล้อที่ 2:** เลื่อนลง 1 ตำแหน่งเสมอ\n* **วงล้อที่ 3:** เลื่อนขึ้น เท่ากับค่าตัวสุดท้ายของกุญแจไขรหัส\n\n**งานของท่าน**\n\nเขียนโปรแกรมเพื่ออ่านกุญแจไขรหัสและตัวเลขที่ต้องการเข้ารหัส และคำนวณหาผลลัพธ์จากการเข้ารหัส\n\n**ข้อมูลนำเข้า**\n\n* **บรรทัดที่ 1:** กุญแจไขรหัส 3 หลัก\n* **บรรทัดที่ 2:** ตัวเลขที่ต้องการเข้ารหัส (ความยาว 2 ถึง 256 หลัก)\n\n**ข้อมูลส่งออก**\n\nมีบรรทัดเดียวแสดงผลการเข้ารหัส\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 |\n| :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 486 | 486 | 382 |\n| 59 | 26 | 33687493 |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| 26 | 83 | 48636775 |",
        "metadata": {
            "problem_id": "toi5_nsw",
            "problem_name": "toi5_nsw",
            "source": "TOI",
            "tags": [
                "string",
                "parsing",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint k1,k2,k3,n;\nstring key,str;\n\nint n2en(int i,int k) {\n    int ans = (i-1+k)%9;\n    if (ans == 0) ans = 9;\n    return ans;\n}\n\nint main() {\n    cin.tie(nullptr)->sync_with_stdio(false);\n    cin >> key >> str;\n    k1 = key[0]-'0';\n    k2 = key[1]-'0';\n    k3 = key[2]-'0';\n    for (auto c : str) {\n        n = c-'0';\n        int d = n2en(n2en(n2en(n,k1),k2),k3);\n        k1 = n2en(k1+1,key[0]-'0');\n        k3 = n2en(k3+1,key[2]-'0');\n        if (k2-1 == 0) k2 = 9;\n        else k2--;\n        \n        cout << d;\n    }\n    \n    return 0;\n}  "
        }
    },
    {
        "page_content": "**จุดคุ้มทุน (Return On Investment)**\n\nอาจารย์เสนต้องการพิมพ์หนังสือขายและต้องการหาจุดคุ้มทุน โดยมีเงื่อนไขการพิมพ์และราคาขายดังนี้\n* **ค่าใช้จ่ายรวม** = ต้นทุนคงที่ + ต้นทุนผันแปร\n* **เงื่อนไขการพิมพ์:**\n    * พิมพ์ขั้นต่ำ 1,000 เล่ม และไม่เกิน 15,000 เล่ม\n    * จำนวนการพิมพ์ต้องหารด้วย 500 ลงตัว\n    * ต้นทุนการพิมพ์ต่อเล่มคือ 100 บาทสำหรับ 1,000 เล่มแรก และลดลง 1% (1 บาท) ทุกๆ 500 เล่มที่พิมพ์เพิ่ม (เช่น 1,500 เล่มต้นทุนเล่มละ 99 บาท)\n* **เงื่อนไขการขาย:**\n    * ราคาขายเป็นจำนวนเต็มตั้งแต่ 74 ถึง 144 บาท\n    * จำนวนหนังสือที่ขายได้คำนวณจากสูตรที่กำหนด ซึ่งขึ้นอยู่กับราคาขาย\n* **จุดคุ้มทุน:** คือราคาขายที่น้อยที่สุดที่ทำให้มีกำไรมากกว่า 0 บาท\n\n**งานของคุณ**\n\nจงเขียนโปรแกรมเพื่อคำนวณหาจุดคุ้มทุนที่มีกำไรน้อยที่สุด โดยรายงานว่าต้องพิมพ์หนังสือกี่เล่ม, ขายราคาเท่าไร, และมีกำไรเท่าใด\n\n**ข้อมูลนำเข้า**\n\nมี 1 บรรทัดเป็นจำนวนเต็มบวก C แทนต้นทุนคงที่ ($10,000 \\le C \\le 100,000$)\n\n**ข้อมูลส่งออก**\n\nมี 3 บรรทัด:\n1.  จำนวนหนังสือที่ต้องพิมพ์\n2.  ราคาขาย\n3.  กำไรของจุดคุ้มทุนน้อยที่สุด (ทศนิยมสองตำแหน่ง)\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 | ตัวอย่างที่ 3 |\n| :--- | :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 30000 | 55000 | 70000 |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| 3500 | 3000 | 7500 |\n| 105 | 128 | 97 |\n| 61.22 | 103.75 | 241.13 |",
        "metadata": {
            "problem_id": "toi5_roi",
            "problem_name": "toi5_roi",
            "source": "TOI",
            "tags": [
                "implementation",
                "math"
            ],
            "solution_code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    int price;\n    cin >> price;\n\n    int min_num = INT_MAX, min_price = INT_MAX;\n    double min_profit = INT_MAX;\n    for(int p = 74 ; p <= 144 ; p++){\n        for (int n = 1000 ; n <= 15000 ; n+=500){\n            double a = ((100-(0.8569 * exp(0.09*(p-100))))*n)/100.0;\n            double pro = (a*p)-price-(n*(100-(n/500-2)));\n            if (a>=0 && pro<min_profit && pro>0){\n                min_num = n;\n                min_price = p;\n                min_profit = pro;\n            }\n        }\n    }\n\n    printf(\"%d\\n%d\\n%.2lf\", min_num, min_price, min_profit);\n}"
        }
    },
    {
        "page_content": "**จับคู่ชักเย่อ (Tug-of-war)**\n\nในการแข่งขันชักเย่อระหว่างสองทีม ทีมละ N คน ผู้เข้าแข่งขันทุกคนจะยืนอยู่บนเส้นจำนวน ณ ตำแหน่งที่แตกต่างกัน ผู้จัดการแข่งขันต้องจับคู่ผู้เข้าแข่งขันจากสองทีมแบบหนึ่งต่อหนึ่ง เพื่อให้มีคู่แข่งขันทั้งหมด N คู่\n\nความยาวเชือกที่ใช้สำหรับแต่ละคู่จะเท่ากับระยะห่าง (ค่าสัมบูรณ์ของผลต่าง) ระหว่างตำแหน่งของผู้เข้าแข่งขันสองคนในคู่นั้น\n\n**งานของคุณ**\n\nเขียนโปรแกรมที่อ่านตำแหน่งของผู้เข้าแข่งขันจากทั้งสองทีม จากนั้นคำนวณหาความยาวรวมของเชือก \"น้อยที่สุด\" ที่ใช้ในการแข่งขันครั้งนี้\n\n**ข้อมูลนำเข้า**\n\n* **บรรทัดแรก** ระบุจำนวนเต็ม N ($1\\le N\\le2,000$) ซึ่งเป็นจำนวนสมาชิกในแต่ละทีม\n* **N บรรทัดถัดมา** ระบุตำแหน่งของผู้เข้าแข่งขันจากทีมที่หนึ่ง\n* **อีก N บรรทัดถัดมา** จะระบุตำแหน่งของผู้เข้าแข่งขันจากทีมที่สอง\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด แทนความยาวของเชือกรวมที่น้อยที่สุดที่ใช้ในการแข่งขันนี้\n\n**ตัวอย่าง**\n\n| ตัวอย่างที่ 1 | ตัวอย่างที่ 2 |\n| :--- | :--- |\n| **ข้อมูลนำเข้า** | **ข้อมูลนำเข้า** |\n| 3 | 2 |\n| -5 | 80 |\n| -10 | -100 |\n| -7 | |\n| 8 | -70 |\n| 6 | 90 |\n| 10 | |\n| **ข้อมูลส่งออก** | **ข้อมูลส่งออก** |\n| 46 | 40 |",
        "metadata": {
            "problem_id": "toi5_tug",
            "problem_name": "toi5_tug",
            "source": "TOI",
            "tags": [
                "sorting",
                "array"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(void) {\n    int n,ans =0;\n\tcin >> n;\n    int a[n],b[n];\n    for (auto& i : a) cin >> i;\n    for (auto& i : b) cin >> i;\n    sort(a,a+n); sort(b,b+n);\n    for (int i=0 ;i< n ; i++) ans += abs(a[i]-b[i]);\n    cout << ans;\n}"
        }
    },
    {
        "page_content": "**ดอมมิโนฉงน (dominoes)**\n\nตัวดอมมิโนคือสี่เหลี่ยมมุมฉากขนาด 2 สดมภ์ (columns) และ 1 แถว (row) เราสามารถนำตัวดอมมิโนมาวางลงในกรอบสี่เหลี่ยมมุมฉากขนาด 2 สดมภ์และ n แถวให้เต็มได้หลายวิธี\n\n**งานของคุณ**\n\nให้เขียนโปรแกรมแสดงรูปแบบของการวางตัวดอมมิโนให้เต็มกรอบสี่เหลี่ยมมุมฉากขนาด 2 สดมภ์และ n แถวที่เป็นไปได้ทั้งหมด\n\n**ข้อมูลนำเข้า**\n\nมีหนึ่งบรรทัด เป็นจำนวนเต็มบวก n แทนจำนวนแถว โดยที่ $1 \\\\le n \\\\le 13$\n\n**ข้อมูลส่งออก**\n\nใช้ `--` แทนดอมมิโนแนวนอน และใช้ `|` แทนดอมมิโนแนวตั้ง ให้แสดงรูปแบบทั้งหมดที่เป็นไปได้ โดยเมื่อจบแต่ละรูปแบบให้ขึ้นบรรทัดใหม่ด้วยตัวอักษร `E`\n\n**ตัวอย่างที่ 1**\n\n\\<pre\\>\n\\<b\\>ข้อมูลนำเข้า\\</b\\>\n2\n\n## \\<b\\>ข้อมูลส่งออก\\</b\\>\n\n\\--\nE\n||\nE\n\\</pre\\>\n\n**ตัวอย่างที่ 2**\n\n\\<pre\\>\n\\<b\\>ข้อมูลนำเข้า\\</b\\>\n3\n\n## \\<b\\>ข้อมูลส่งออก\\</b\\>\n\n## || E |-- |-- E ||\n\nE\n\\</pre\\>",
        "metadata": {
            "problem_id": "toi6_domino",
            "problem_name": "toi6_domino",
            "source": "TOI",
            "tags": [
                "backtracking",
                "recursion",
                "string"
            ],
            "solution_code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\nint n;\nvector<int> mark;\n\nvoid solve(int i){\n    if(i==n){\n        for(auto j:mark){\n            if(j==1)cout << \"--\" << \"\\n\";\n            else cout << \"||\" << \"\\n\";\n        }\n        cout << \"E\" << \"\\n\";\n    }else if(i<n){\n        mark.push_back(1);\n        solve(i+1);\n        mark.pop_back();\n        mark.push_back(2);\n        solve(i+2);\n        mark.pop_back();\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> n;\n    solve(0);\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ปะวะหล่ำ (Gem)**\n\nปะวะหล่ำเป็นเครื่องประดับข้อมือ มีตำแหน่งสำหรับวางอัญมณี n ตำแหน่ง และมีอัญมณีทั้งหมด m ชนิด ในการเลือกใส่อัญมณีในแต่ละตำแหน่ง จะต้องเลือกจาก \"คู่ของอัญมณีที่กำหนดให้\" สำหรับตำแหน่งนั้นๆ เท่านั้น\n\nนอกจากนี้ อัญมณีแต่ละชนิดยังมี \"คู่อัญมณีต้องห้าม\" ซึ่งหมายความว่าถ้าเลือกอัญมณีชนิดหนึ่งมาใช้แล้ว จะไม่สามารถเลือกอัญมณีที่เป็นคู่ต้องห้ามของมันมาใช้ในตำแหน่งอื่นได้เลย\n\n**งานของคุณ**\n\nให้เขียนโปรแกรมเพื่อตรวจสอบปะวะหล่ำทั้งหมด 5 เส้น ว่าแต่ละเส้นสามารถประดับอัญมณีได้โดยไม่มีคู่อัญมณีต้องห้ามหรือไม่\n\n**ข้อมูลนำเข้า**\n\nมีข้อมูลของปะวะหล่ำทั้งหมด 5 เส้น โดยแต่ละเส้นมีข้อมูล 4 บรรทัดดังนี้:\n\n1.  **บรรทัดแรก** เป็นจำนวนเต็มบวก n แทนจำนวนตำแหน่ง ($1\\\\le n \\\\le 100,000$)\n2.  **บรรทัดที่สอง** เป็นจำนวนคู่บวก m แทนจำนวนชนิดของอัญมณี ($2\\\\le m \\\\le 200,000$)\n3.  **บรรทัดที่สาม** เป็นตัวเลข $2n$ ตัว ระบุคู่ชนิดของอัญมณีที่สามารถเลือกได้ในแต่ละตำแหน่ง\n4.  **บรรทัดที่สี่** เป็นตัวเลข m ตัว ระบุคู่อัญมณีต้องห้ามทั้งหมด m/2 คู่\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด เป็นตัวอักษร 5 ตัวเรียงติดกัน โดยแต่ละตัวใช้ `Y` เมื่อสามารถประดับอัญมณีได้ และ `N` เมื่อไม่สามารถประดับได้\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | YYYYN |\n| 6 | |\n| 2 3 6 5 3 4 1 2 | |\n| 1 3 2 5 4 6 | |\n| 3 | |\n| 4 | |\n| 1 2 2 3 4 3 | |\n| 1 3 2 4 | |\n| 4 | |\n| 8 | |\n| 1 2 3 4 5 6 7 8 | |\n| 1 3 2 4 5 7 6 8 | |\n| 3 | |\n| 4 | |\n| 1 2 2 3 3 4 | |\n| 2 3 1 4 | |\n| 5 | |\n| 4 | |\n| 1 2 2 3 4 3 1 3 4 2 | |\n| 1 4 2 3 | |",
        "metadata": {
            "problem_id": "toi6_gem",
            "problem_name": "toi6_gem",
            "source": "TOI",
            "tags": [
                "backtracking",
                "recursion",
                "simulation",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nvoid solve_test_case() {\n    int num_edges, num_nodes;\n    cin >> num_edges >> num_nodes;\n\n    vector<int> adj[num_nodes + 5], reverse_adj[num_nodes + 5];\n    vector<pair<int, int>> edges(num_edges);\n    \n    int negation_map[num_nodes + 5];\n    int visited_scc[num_nodes + 5];\n    int scc_id = 0;\n    \n    memset(visited_scc, 0, sizeof(visited_scc));\n\n    for (auto &[u, v] : edges) {\n        cin >> u >> v;\n    }\n\n    for (int i = 0; i < num_nodes / 2; i++) {\n        int u, v;\n        cin >> u >> v;\n        negation_map[u] = v;\n        negation_map[v] = u;\n    }\n\n    for (auto &[u, v] : edges) {\n        adj[negation_map[u]].emplace_back(v);\n        adj[negation_map[v]].emplace_back(u);\n        reverse_adj[u].emplace_back(negation_map[v]);\n        reverse_adj[v].emplace_back(negation_map[u]);\n    }\n\n    vector<int> node_order_dfs1;\n    function<void(int)> dfs_pass1 = [&](int u) {\n        visited_scc[u] = 1;\n        for (int v : adj[u]) {\n            if (!visited_scc[v]) {\n                dfs_pass1(v);\n            }\n        }\n        node_order_dfs1.emplace_back(u);\n    };\n    \n    function<void(int)> dfs_pass2 = [&](int u) {\n        visited_scc[u] = scc_id;\n        for (int v : reverse_adj[u]) {\n            if (!visited_scc[v]) {\n                dfs_pass2(v);\n            }\n        }\n    };\n\n    for (int i = 1; i <= num_nodes; i++) {\n        if (!visited_scc[i]) {\n            dfs_pass1(i);\n        }\n    }\n    \n    reverse(node_order_dfs1.begin(), node_order_dfs1.end());\n    memset(visited_scc, 0, sizeof(visited_scc));\n\n    for (int node : node_order_dfs1) {\n        if (!visited_scc[node]) {\n            ++scc_id;\n            dfs_pass2(node);\n        }\n    }\n\n    for (int i = 1; i <= num_nodes; i += 2) {\n        if (visited_scc[i] == visited_scc[negation_map[i]]) {\n            cout << 'N';\n            return;\n        }\n    }\n    cout << 'Y';\n}\n\nint main() {\n    ios::sync_with_stdio(0), cin.tie(0);\n    for (int i = 0; i < 5; i++) {\n        solve_test_case();\n    }\n    cout << '\\n';\n    return 0;\n}"
        }
    },
    {
        "page_content": "**โรงแรมในฝัน (Hotel)**\n\nโรงแรมแคนทารีฮิลล์มีห้องพัก 4 ประเภท โดยมีรายละเอียดดังนี้\n\n| ประเภทของห้อง | จำนวนคนที่พัก (มากที่สุดต่อห้อง) | ราคาต่อห้อง (บาท) |\n| :--- | :--- | :--- |\n| ห้องเดี่ยว | 1 | 500 |\n| ห้องคู่ | 2 | 800 |\n| ห้องกลาง | 5 | 1,500 |\n| ห้องพักรวม | 15 | 3,000 |\n\n**งานของคุณ**\n\nให้เขียนโปรแกรมในการคำนวณหาห้องพักให้กับคนที่ต้องการเข้าพักจำนวน n คน โดยให้มีราคารวมของห้องพักต่ำที่สุด\n\n**ข้อมูลนำเข้า**\n\nมีหนึ่งบรรทัด เป็นจำนวนเต็มบวก n ($1\\\\le n\\\\le1,000,000$)\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด เป็นจำนวนเต็มบวกที่เป็นราคารวมของห้องพักต่ำที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 21 | 5000 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 24 | 6000 |",
        "metadata": {
            "problem_id": "toi6_hotel",
            "problem_name": "toi6_hotel",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "greedy",
                "math"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nsigned main(void) {\n    int n,sum=0;\n    cin >> n;\n    while (n >0) {\n    \tif (n >= 10) sum+=3000,n-=15;\n    \telse if (n>=4) sum+=1500,n-=5;\n    \telse if (n >= 2) sum+=800,n-=2;\n    \telse sum+=500,n--;\n    }\n    cout << sum;\n}"
        }
    },
    {
        "page_content": "**คุกหฤโหด (Jail)**\n\nพระราชา Josephus มีวิธีในการเลือกนักโทษที่จะส่งไปสังเวยปีศาจ โดยมีนักโทษทั้งหมด n คน มีเลขประจำตัว 1, 2, ..., n นั่งล้อมกันเป็นวงกลม พระราชาจะเริ่มนับจากคนที่มีเลขประจำตัว 1 ไปเรื่อยๆ เมื่อนับถึง m นักโทษคนนั้นจะถูกส่งไปสังเวย และจะเริ่มต้นนับ 1 ถึง m ใหม่ที่คนถัดจากคนที่ถูกกำจัดไป ทำเช่นนี้ไปเรื่อย ๆ จนกระทั่งนักโทษหมด\n\n**งานของคุณ**\n\nให้เขียนโปรแกรม ในการคำนวณลำดับของนักโทษที่จะถูกส่งไปสังเวยปีศาจ\n\n**ข้อมูลนำเข้า**\n\nเป็นตัวเลขจำนวนเต็มบวกสองจำนวนที่แสดงค่าของ n และ m ตามลำดับ คั่นโดยช่องว่าง ($5\\\\le n\\\\le1,000,000$ และ $2\\\\le m\\\\le5$)\n\n**ข้อมูลส่งออก**\n\nมีอยู่เพียงบรรทัดเดียวประกอบด้วยเลขประจำตัวของนักโทษที่ถูกส่งไปสังเวยจากลำดับแรกถึงลำดับสุดท้าย โดยตัวเลขแต่ละตัวจะถูกคั่นโดยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 4 | 4 8 5 2 1 3 7 6 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 4 | 4 3 5 2 1 |",
        "metadata": {
            "problem_id": "toi6_jail",
            "problem_name": "toi6_jail",
            "source": "TOI",
            "tags": [
                "queue"
            ],
            "solution_code": "#include <iostream>\n#include <queue>\n#include <numeric>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int num_elements, steps_to_remove;\n    std::cin >> num_elements >> steps_to_remove;\n\n    std::queue<int> elements_queue;\n    for (int i = 1; i <= num_elements; ++i) {\n        elements_queue.push(i);\n    }\n\n    while (!elements_queue.empty()) {\n        // Move the first (steps_to_remove - 1) elements to the back of the queue\n        for (int i = 1; i < steps_to_remove; ++i) {\n            elements_queue.push(elements_queue.front());\n            elements_queue.pop();\n        }\n        // Print and remove the element at the front\n        std::cout << elements_queue.front() << ' ';\n        elements_queue.pop();\n    }\n    std::cout << std::endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**การต่อโทรศัพท์ (Schedules)**\n\nบริษัทโทรศัพท์แห่งหนึ่งมีช่องสัญญาณที่สามารถจัดการการสื่อสารพร้อมกันได้ไม่เกิน k ช่องสัญญาณ เมื่อมีคำขอใช้ช่องสัญญาณเข้ามาในขณะที่ช่องสัญญาณเต็ม คำขอนั้นจะถูกปฏิเสธ กำหนดให้มีชุดคำขอใช้ช่องสัญญาณทั้งหมด n คำขอ ได้แก่ $(s\\_1, f\\_1), (s\\_2, f\\_2), ..., (s\\_n, f\\_n)$ โดยที่ $s\\_i$ และ $f\\_i$ คือเวลาเริ่มต้นและสิ้นสุดของคำขอที่ i\n\n**งานของคุณ**\n\nให้เขียนโปรแกรมเพื่อตรวจสอบว่า คำขอที่ระบุจะถูกตอบรับหรือปฏิเสธ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดแรก** เป็นตัวเลขจำนวนเต็มบวกสามจำนวน ได้แก่ n, k และ m ตามลำดับ คั่นด้วยช่องว่าง ($1\\\\le n\\\\le500,000$, $1\\\\le k\\\\le n$ และ $1\\\\le m\\\\le n$)\n2.  **บรรทัดที่สอง** เป็นเลขจำนวนเต็มบวก $2n$ ตัว ที่แสดงเวลาเริ่มต้นและสิ้นสุดของแต่ละคำขอ ($s\\_1, f\\_1, s\\_2, f\\_2, ..., s\\_n, f\\_n$)\n3.  **บรรทัดที่สาม** เป็นตัวเลขจำนวนเต็มบวก m ตัว ที่แสดงถึงหมายเลขคำขอที่ต้องการตรวจสอบ\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด เป็นตัวอักษร m ตัว คั่นด้วยช่องว่าง โดยใช้ `Y` หมายถึงคำขอถูกตอบรับ และ `N` หมายถึงคำขอถูกปฏิเสธ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 1 4 | Y N Y N |\n| 3 7 2 4 1 3 7 8 8 10 9 15 | |\n| 3 5 4 1 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 2 4 | Y Y Y N |\n| 3 7 2 4 1 3 7 8 8 10 9 15 | |\n| 3 5 4 1 | |",
        "metadata": {
            "problem_id": "toi6_schedule",
            "problem_name": "toi6_schedule",
            "source": "TOI",
            "tags": [
                "array",
                "sorting",
                "greedy"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int num_intervals, max_concurrent_intervals, num_queries;\n    std::cin >> num_intervals >> max_concurrent_intervals >> num_queries;\n\n    std::vector<std::pair<std::pair<int, bool>, int>> events;\n    for (int i = 1; i <= num_intervals; ++i) {\n        int start_time, end_time;\n        std::cin >> start_time >> end_time;\n        events.push_back({{start_time, true}, i});  // true indicates start event\n        events.push_back({{end_time + 1, false}, i}); // false indicates end event\n    }\n\n    std::sort(events.begin(), events.end());\n\n    std::vector<bool> is_accepted(num_intervals + 1, false);\n    int current_concurrent_intervals = 0;\n\n    for (const auto& event : events) {\n        int time = event.first.first;\n        bool is_start_event = event.first.second;\n        int interval_id = event.second;\n\n        if (is_start_event) {\n            if (current_concurrent_intervals < max_concurrent_intervals) {\n                is_accepted[interval_id] = true;\n                current_concurrent_intervals++;\n            }\n        } else { // It's an end event\n            if (is_accepted[interval_id]) {\n                current_concurrent_intervals--;\n            }\n        }\n    }\n\n    for (int i = 0; i < num_queries; ++i) {\n        int query_id;\n        std::cin >> query_id;\n        if (is_accepted[query_id]) {\n            std::cout << \"Y \";\n        } else {\n            std::cout << \"N \";\n        }\n    }\n    std::cout << std::endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**คู่ต้นไม้ (Trees)**\n\nกราฟต้นไม้ T ประกอบด้วยเซตของจุดต่อ (vertices) $V = {v\\_1, v\\_2, ..., v\\_n}$ และเซตของเส้นเชื่อม (edges) $E = {e\\_1, e\\_2, ..., e\\_{n-1}}$ ที่เชื่อมระหว่างจุดต่อโดยไม่เกิดวัฏจักร\n\n**งานของคุณ**\n\nให้เขียนโปรแกรมเพื่อตรวจสอบคู่ของกราฟต้นไม้ ($T\\_1$ และ $T\\_2$) ทั้งหมด 5 คู่ ว่าแต่ละคู่เป็นกราฟต้นไม้เดียวกันหรือไม่ (มีเซตของเส้นเชื่อมเหมือนกัน)\n\n**ข้อมูลนำเข้า**\n\nมีข้อมูลของกราฟต้นไม้ทั้งหมด 5 คู่ โดยแต่ละคู่มีข้อมูล 3 บรรทัดดังนี้:\n\n1.  **บรรทัดแรก** เป็นจำนวนเต็มบวก n แทนจำนวนจุดต่อของกราฟต้นไม้ ($2\\\\le n\\\\le100,000$)\n2.  **บรรทัดที่สอง** แสดงสมาชิกของเซตของเส้นเชื่อม $E\\_1$ ของกราฟต้นไม้ $T\\_1$ เป็นจำนวน $2(n-1)$ ตัว\n3.  **บรรทัดที่สาม** แสดงสมาชิกของเซตของเส้นเชื่อม $E\\_2$ ของกราฟต้นไม้ $T\\_2$ เป็นจำนวน $2(n-1)$ ตัว\n    (ตัวเลขแต่ละคู่ถัดกันไปจะหมายถึงเส้นเชื่อมหนึ่งเส้น เช่น `1 2 2 3` หมายถึงเส้นเชื่อม {1, 2} และ {2, 3})\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด เป็นตัวอักษร 5 ตัวเรียงติดกัน โดยแต่ละตัวแสดงคำตอบของคู่กราฟต้นไม้แต่ละคู่ ใช้ `Y` เมื่อเป็นกราฟต้นไม้เดียวกัน และ `N` เมื่อไม่เป็น\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 9 | YYYYN |\n| 2 4 9 4 6 4 1 4 1 5 3 5 7 5 7 8 | |\n| 1 4 4 9 1 5 6 4 3 5 7 5 7 8 2 4 | |\n| 9 | |\n| 2 4 9 4 6 4 1 4 1 5 3 5 7 5 7 8 | |\n| 1 4 9 4 1 5 2 4 6 4 3 5 7 5 7 8 | |\n| 9 | |\n| 2 4 6 4 1 4 1 5 9 4 3 5 7 5 7 8 | |\n| 1 4 9 4 1 5 2 4 6 4 3 5 7 5 7 8 | |\n| 9 | |\n| 9 4 3 5 7 5 7 8 2 4 6 4 1 4 1 5 | |\n| 1 4 9 4 1 5 2 4 6 4 3 5 7 5 7 8 | |\n| 4 | |\n| 1 2 2 3 3 4 | |\n| 1 2 1 3 1 4 | |",
        "metadata": {
            "problem_id": "toi6_tree",
            "problem_name": "toi6_tree",
            "source": "TOI",
            "tags": [
                "graph",
                "tree",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<pair<int,int>> v1,v2;\n\nvoid solve(){\n    v1.clear();v2.clear();\n    int n;cin>>n;\n    for(int i=0;i<n-1;i++){\n        int a,b;cin>>a>>b;\n        if(a>b)swap(a,b);\n        v1.push_back({a,b});\n    }\n    for(int i=0;i<n-1;i++){\n        int a,b;cin>>a>>b;\n        if(a>b)swap(a,b);\n        v2.push_back({a,b});\n    }\n    sort(v1.begin(),v1.end());\n    sort(v2.begin(),v2.end());\n    if(v1==v2)cout<<'Y';\n    else cout<<'N';\n}\n\nint main(){\n    cin.tie(0)->sync_with_stdio(0);\n    for(int i=0;i<5;i++){\n        solve();\n    }\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ระเบิดมหาประลัย (Bomb)**\n\nทหารนาวิกโยธินจะต้องผ่านเหมืองระเบิดซึ่งมีระเบิดอยู่ n ตำแหน่ง โดยระเบิดจริงจะอยู่ในตำแหน่งที่เรียกว่า \"ตำแหน่งมหันตภัย\" ซึ่งมีเงื่อนไขดังนี้:\n1.  ตำแหน่ง $p_1=(x_1, y_1)$ **บดบัง** ตำแหน่ง $p_2=(x_2, y_2)$ ก็ต่อเมื่อ $x_1 > x_2$ และ $y_1 > y_2$\n2.  **ตำแหน่งมหันตภัย** คือ ตำแหน่งที่ไม่มีตำแหน่งอื่น ๆ บดบัง\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพในการระบุตำแหน่งมหันตภัยที่มีระเบิดจริงทั้งหมด\n\n**ข้อมูลนำเข้า**\n\n1.  บรรทัดแรกเป็นค่าของตัวแปร n โดยที่ $1 \\le n \\le 1,000,000$\n2.  บรรทัดที่สองถึง n+1 ระบุตำแหน่งของระเบิดทั้งหมด แต่ละบรรทัดระบุค่าของตำแหน่งเป็นจำนวนเต็มบวกสองตัว x และ y โดยมีช่องว่างคั่น ($1 \\le x, y \\le 10,000,000$)\n\n**ข้อมูลส่งออก**\n\nระบุตำแหน่งมหันตภัยทั้งหมด โดยให้แต่ละบรรทัดระบุค่าของตำแหน่งเป็น x และ y คั่นด้วยช่องว่าง (ลำดับในการแสดงผลไม่มีผลต่อความถูกต้อง)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 9 1 |\n| 9 1 | 8 2 |\n| 8 2 | 7 3 |\n| 7 3 | 6 4 |\n| 6 4 | 5 5 |\n| 5 5 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 | 3 7 |\n| 1 2 | 6 6 |\n| 2 4 | 7 3 |\n| 4 1 | |\n| 7 3 | |\n| 5 5 | |\n| 6 6 | |\n| 3 7 | |",
        "metadata": {
            "problem_id": "toi7_bomb",
            "problem_name": "toi7_bomb",
            "source": "TOI",
            "tags": [
                "array",
                "sorting"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n\n    int num_points;\n    std::cin >> num_points;\n\n    std::vector<std::pair<int, int>> points(num_points);\n    for (std::pair<int, int>& point : points) {\n        std::cin >> point.first >> point.second;\n    }\n\n    std::sort(points.begin(), points.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n        if (a.first == b.first) {\n            return a.second < b.second;\n        }\n        return a.first > b.first;\n    });\n\n    int max_y_coordinate_so_far = INT_MIN;\n    for (int i = 0; i < num_points; ++i) {\n        if (points[i].second >= max_y_coordinate_so_far) {\n            max_y_coordinate_so_far = points[i].second;\n            std::cout << points[i].first << ' ' << points[i].second << '\\n';\n        }\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ขับรถหลบสิ่งกีดขวาง (Car)**\n\nในการแสดงขับรถผาดโผนบนถนนที่มี m เลน (หมายเลข 1 ถึง m จากซ้ายไปขวา) นักแสดงต้องบังคับรถให้ปลอดภัยตลอดระยะเวลา t หน่วย โดยเริ่มต้นที่เลน n\n\nในแต่ละหน่วยเวลา อาจมีสิ่งกีดขวาง (1) หรือไม่มี (0) ในแต่ละเลน นักแสดงมีทางเลือกในการบังคับรถ 3 แบบเพื่อไปยังเวลาถัดไป:\n* **1** หมายถึง เปลี่ยนเลนไปทางซ้าย 1 เลน\n* **2** หมายถึง เปลี่ยนเลนไปทางขวา 1 เลน\n* **3** หมายถึง ขับอยู่ในเลนเดิม\n\nจงเขียนโปรแกรมเพื่อบังคับให้รถแล่นไปตามเส้นทางนี้โดยปลอดภัย (ชุดข้อมูลทดสอบจะมีคำตอบที่ถูกต้องเพียง 1 คำตอบเสมอ)\n\n**ข้อมูลนำเข้า**\n\n1.  บรรทัดแรกระบุจำนวนเลน m ($2 \\le m \\le 40$)\n2.  บรรทัดที่สองระบุหมายเลขเลนเริ่มต้น n ($1 \\le n \\le m$)\n3.  บรรทัดที่สามระบุระยะเวลา t ($1 \\le t \\le 100$)\n4.  t บรรทัดถัดมา แสดงสถานะของถนน ณ เวลา 1, 2, ..., t โดยแต่ละบรรทัดมี m ตัวเลข (0 คือไม่มีสิ่งกีดขวาง, 1 คือมีสิ่งกีดขวาง)\n\n**ข้อมูลส่งออก**\n\nมี t บรรทัด แต่ละบรรทัดมีตัวเลข 1, 2, หรือ 3 เพื่อแสดงถึงทางเลือกในการบังคับรถในแต่ละช่วงเวลา\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 | 1 |\n| 5 | 1 |\n| 5 | 1 |\n| 0000000 | 1 |\n| 0000000 | 2 |\n| 0000000 | |\n| 0110000 | |\n| 1011111 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 2 |\n| 2 | 2 |\n| 3 | 3 |\n| 00010 | |\n| 01100 | |\n| 11101 | |",
        "metadata": {
            "problem_id": "toi7_car",
            "problem_name": "toi7_car",
            "source": "TOI",
            "tags": [
                "backtracking",
                "recursion",
                "array"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nstd::vector<std::vector<int>> grid;\nint num_rows, num_cols, start_col_idx;\nstd::vector<int> path_directions;\n\nvoid find_path(int current_row, int current_col, int step_count) {\n    if (current_row == num_rows - 1) {\n        for (int i = 0; i < num_rows; ++i) {\n            std::cout << path_directions[i] << \"\\n\";\n        }\n        return;\n    }\n\n    // Try moving Left\n    if (current_row + 1 < num_rows && current_col - 1 >= 0 && grid[current_row + 1][current_col - 1] == 0) {\n        path_directions[step_count] = 1; // Represents \"Left\"\n        find_path(current_row + 1, current_col - 1, step_count + 1);\n    }\n\n    // Try moving Straight\n    if (current_row + 1 < num_rows && grid[current_row + 1][current_col] == 0) {\n        path_directions[step_count] = 3; // Represents \"Straight\"\n        find_path(current_row + 1, current_col, step_count + 1);\n    }\n\n    // Try moving Right\n    if (current_row + 1 < num_rows && current_col + 1 < num_cols && grid[current_row + 1][current_col + 1] == 0) {\n        path_directions[step_count] = 2; // Represents \"Right\"\n        find_path(current_row + 1, current_col + 1, step_count + 1);\n    }\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    std::cin >> num_cols >> start_col_idx >> num_rows;\n\n    grid.resize(num_rows, std::vector<int>(num_cols));\n    for (int i = 0; i < num_rows; ++i) {\n        for (int j = 0; j < num_cols; ++j) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    path_directions.resize(num_rows);\n    find_path(-1, start_col_idx - 1, 0);\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**อาหารโอชา (Food)**\n\nในพระราชวังแห่งหนึ่ง พ่อครัวสามารถทำอาหารได้ n ชนิดที่แตกต่างกัน ในการถวายอาหารแก่เจ้าชาย พ่อครัวจะถวายอาหารหนึ่งชนิดต่อหนึ่งชั่วโมงจนครบ n ชนิด แต่มีกลุ่มของอาหารต้องห้าม m ชนิดที่จะถวายเป็นลำดับแรกไม่ได้\n\nให้เขียนโปรแกรมแสดงลำดับทั้งหมดที่เป็นไปได้ของการถวายอาหาร n ชนิด\n\n**ข้อมูลนำเข้า**\n\n1.  บรรทัดแรกเป็นจำนวนชนิดอาหาร n ($2 \\le n \\le 8$)\n2.  บรรทัดที่สองเป็นจำนวนชนิดอาหารต้องห้าม m ($2 \\le m < n$)\n3.  บรรทัดที่สามแสดงชนิดของอาหารต้องห้าม m ชนิด เป็นตัวเลขจำนวนเต็มบวกคั่นด้วยช่องว่าง\n\n**ข้อมูลส่งออก**\n\nแสดงลำดับที่เป็นไปได้ทั้งหมด โดยใช้หนึ่งบรรทัดในการแสดงลำดับของอาหารหนึ่งลำดับ ตัวเลขในลำดับคั่นด้วยช่องว่าง (ลำดับในการแสดงผลไม่มีผลต่อความถูกต้อง)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 4 1 2 3 |\n| 3 | 4 1 3 2 |\n| 1 2 3 | 4 2 1 3 |\n| | 4 2 3 1 |\n| | 4 3 1 2 |\n| | 4 3 2 1 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 1 2 3 4 |\n| 2 | 1 2 4 3 |\n| 3 2 | 1 3 2 4 |\n| | 1 3 4 2 |\n| | 1 4 2 3 |\n| | 1 4 3 2 |\n| | 4 1 2 3 |\n| | 4 1 3 2 |\n| | 4 2 1 3 |\n| | 4 2 3 1 |\n| | 4 3 1 2 |\n| | 4 3 2 1 |",
        "metadata": {
            "problem_id": "toi7_food",
            "problem_name": "toi7_food",
            "source": "TOI",
            "tags": [
                "backtracking",
                "recursion",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint total_elements;\nint num_excluded_first_elements;\nint excluded_first_elements[10];\nbool element_used[10];\nvector<int> current_permutation;\n\nvoid generate_permutations() {\n    if (current_permutation.size() == total_elements) {\n        for (int i = 0; i < total_elements; ++i) {\n            cout << current_permutation[i] << \" \";\n        }\n        cout << \"\\n\";\n        return;\n    }\n\n    for (int i = 1; i <= total_elements; ++i) {\n        bool is_excluded_as_first = false;\n        if (current_permutation.empty()) {\n            for (int j = 0; j < num_excluded_first_elements; ++j) {\n                if (i == excluded_first_elements[j]) {\n                    is_excluded_as_first = true;\n                    break;\n                }\n            }\n        }\n\n        if (is_excluded_as_first) {\n            continue;\n        }\n\n        if (element_used[i]) {\n            continue;\n        }\n\n        element_used[i] = true;\n        current_permutation.push_back(i);\n\n        generate_permutations();\n\n        element_used[i] = false;\n        current_permutation.pop_back();\n    }\n}\n\nint main() {\n    cin >> total_elements >> num_excluded_first_elements;\n    for (int i = 0; i < num_excluded_first_elements; ++i) {\n        cin >> excluded_first_elements[i];\n    }\n    generate_permutations();\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**คู่ตัวเลขเด่น (Pair)**\n\nให้ชุดของคู่อันดับจำนวนเต็มบวกมา n ชุด คือ $(a_1, b_1), (a_2, b_2), ..., (a_n, b_n)$ โดยที่ $a_i$ ทุกตัวไม่ซ้ำกัน และ $b_j$ ทุกตัวไม่ซ้ำกัน เราเรียกคู่อันดับ 2 คู่ $(a_i, b_i)$ และ $(a_j, b_j)$ ว่า **คู่ตัวเลขเด่น** ก็ต่อเมื่อ $a_i > a_j$ และ $b_i < b_j$\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพในการหาค่าผลรวมของ $a_i + a_j$ ทั้งหมดของทุกคู่ที่เป็นคู่ตัวเลขเด่น\n\n**ข้อมูลนำเข้า**\n\n1.  บรรทัดที่หนึ่งเป็นค่าของ n ($2 \\le n \\le 100,000$)\n2.  บรรทัดที่สองเป็นค่าของคู่ตัวเลข $a_i$ และ $b_i$ จำนวน n คู่ โดยเรียงจากคู่ที่หนึ่งถึงคู่ที่ n (มีตัวเลขทั้งหมด 2n ตัว คั่นด้วยช่องว่าง)\n\n**ข้อมูลส่งออก**\n\nเป็นตัวเลขจำนวนเต็มบวกหนึ่งค่า ซึ่งแสดงถึงผลรวมของ $a_i + a_j$ ทั้งหมดของคู่ตัวเลขเด่น\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 | 78 |\n| 2 1 7 6 9 3 18 4 3 5 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | 39 |\n| 1 4 3 2 2 3 7 1 | |",
        "metadata": {
            "problem_id": "toi7_pair",
            "problem_name": "toi7_pair",
            "source": "TOI",
            "tags": [
                "implementation",
                "sorting",
                "array"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <numeric>\n\nlong long mergeAndCount(std::vector<int>& arr, std::vector<int>& temp, std::vector<long long>& prefixSum, int left, int right) {\n    if (left >= right) {\n        return 0;\n    }\n\n    int mid = left + (right - left) / 2;\n    long long inversions = 0;\n\n    inversions += mergeAndCount(arr, temp, prefixSum, left, mid);\n    inversions += mergeAndCount(arr, temp, prefixSum, mid + 1, right);\n\n    for (int i = left; i <= right; ++i) {\n        prefixSum[i + 1] = prefixSum[i] + arr[i];\n    }\n\n    int k = 0;\n    int leftPtr = left;\n    int rightPtr = mid + 1;\n\n    while (leftPtr <= mid && rightPtr <= right) {\n        if (arr[leftPtr] > arr[rightPtr]) {\n            inversions += prefixSum[mid + 1] - prefixSum[leftPtr] + (long long)(mid - leftPtr + 1) * arr[rightPtr];\n            temp[k++] = arr[rightPtr++];\n        } else {\n            temp[k++] = arr[leftPtr++];\n        }\n    }\n\n    while (leftPtr <= mid) {\n        temp[k++] = arr[leftPtr++];\n    }\n\n    while (rightPtr <= right) {\n        temp[k++] = arr[rightPtr++];\n    }\n\n    for (int i = left; i <= right; ++i) {\n        arr[i] = temp[i - left];\n    }\n\n    return inversions;\n}\n\nint main() {\n    std::ios_base::sync_with_stdio(false);\n    std::cin.tie(NULL);\n\n    int n;\n    std::cin >> n;\n\n    std::vector<int> a(n);\n    std::vector<int> b_temp(n);\n    std::vector<long long> prefixSum(n + 1, 0);\n\n    for (int i = 0; i < n; ++i) {\n        int val, idx;\n        std::cin >> val >> idx;\n        a[idx - 1] = val;\n    }\n\n    std::cout << mergeAndCount(a, b_temp, prefixSum, 0, n - 1) << std::endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ท่อระบายน้ำ (Sewer)**\n\nเมืองแห่งหนึ่งมีพื้นที่เป็นรูปสี่เหลี่ยมขนาด a แถวคูณ b คอลัมน์ แต่ละเขตจะมีท่อระบายน้ำเชื่อมต่อกับเขตเพื่อนบ้านหรือไม่ก็ได้ น้ำจะเริ่มปล่อยจากเขต (1, 1) และสามารถไหลได้ 4 ทิศทาง (เหนือ, ใต้, ตะวันออก, ตะวันตก) โดยใช้เวลา 1 หน่วยในการเดินทางจากเขตหนึ่งไปอีกเขตหนึ่ง และน้ำไม่สามารถไหลย้อนกลับได้\n\nรูปแบบท่อระบายน้ำในแต่ละเขตจะถูกกำหนดโดยพิจารณาการเชื่อมต่อไปยังทิศตะวันออกและทิศใต้เท่านั้น:\n* **R**: เชื่อมกับเขตทิศตะวันออก\n* **D**: เชื่อมกับเขตทิศใต้\n* **B**: เชื่อมกับทั้งเขตทิศตะวันออกและทิศใต้\n* **N**: ไม่เชื่อมกับทั้งสองทิศ\n\nจงเขียนโปรแกรมเพื่อคำนวณหาระยะเวลาที่น้อยที่สุดที่น้ำทิ้งอย่างน้อย 2 สายจะมาบรรจบกัน พร้อมทั้งบอกพิกัดของเขตนั้น (รับประกันว่ามีเขตที่น้ำสองสายมาบรรจบกันเร็วที่สุดเพียงเขตเดียวเสมอ)\n\n**ข้อมูลนำเข้า**\n\n1.  บรรทัดแรกเป็นค่าของตัวแปร a และ b ($2 \\le a, b \\le 100$)\n2.  บรรทัดที่สองถึง a+1 แต่ละบรรทัดมีตัวอักษร b ตัว คั่นด้วยช่องว่าง ระบุสถานะของท่อระบายน้ำ\n\n**ข้อมูลส่งออก**\n\n1.  บรรทัดแรกเป็นจำนวนเต็ม แสดงถึงช่วงเวลาที่น้ำทิ้งมาบรรจบกัน\n2.  บรรทัดที่สองเป็นจำนวนเต็ม 2 ตัว คั่นด้วยช่องว่าง ซึ่งเป็นพิกัด (แถว, คอลัมน์) ที่น้ำทิ้งมาบรรจบกัน\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 4 | 5 |\n| B R D N | 3 3 |\n| D R B D | |\n| R R R D | |\n| N N N N | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 4 | 5 |\n| B B B D | 2 4 |\n| D N R B | |\n| R R R N | |",
        "metadata": {
            "problem_id": "toi7_sewer",
            "problem_name": "toi7_sewer",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=110;\nconst int di[]={0,0,-1,1};\nconst int dj[]={-1,1,0,0};\nstruct Non{int x,y,depth;};\nchar A[N][N];\nint dis[N][N];\nqueue<Non> q;\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    int n,m;\n    cin >> n >> m;\n    for(int i=0;i<n;i++)for(int j=0;j<m;j++)cin >> A[i][j],dis[i][j]=1e9;\n\n    q.push({0,0,dis[0][0]=1});\n    while(!q.empty()){\n        auto [i,j,d]=q.front();\n        q.pop();\n\n        for(int k=0;k<4;k++){\n            int ik=i+di[k];\n            int jk=j+dj[k];\n            if(ik<0||jk<0||ik>=n||jk>=m)continue;\n            if(di[k]==1&&(A[i][j]!='D'&&A[i][j]!='B'))continue;\n            if(di[k]==-1&&(A[ik][jk]!='D'&&A[ik][jk]!='B'))continue;\n            if(dj[k]==1&&(A[i][j]!='R'&&A[i][j]!='B'))continue;\n            if(dj[k]==-1&&(A[ik][jk]!='R'&&A[ik][jk]!='B'))continue;\n            if(dis[ik][jk]<d+1)continue;\n            if(dis[ik][jk]==d+1){\n                cout << d+1 << \"\\n\" << ik+1 << ' ' << jk+1;\n                return 0;\n            }\n            dis[ik][jk]=d+1;\n            q.push({ik,jk,d+1});\n        }\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**สถานีอวกาศ (Space)**\n\nวิศวกรต้องการสร้างอาณานิคมที่ประกอบด้วยสถานีอวกาศทั้งหมด $2^d$ สถานี โดยมีเลขประจำสถานี d หลักที่ประกอบด้วยเลขศูนย์และเลขหนึ่งเท่านั้น สถานีสองแห่งใด ๆ จะมีเส้นทางเชื่อมต่อกันก็ต่อเมื่อ เลขประจำสถานีของทั้งสองสถานีแตกต่างกันอยู่หนึ่งหลักพอดี\n\nจงเขียนโปรแกรมในการสร้างเส้นทางเชื่อมเหล่านี้ โดยพิมพ์เส้นทางเชื่อมแต่ละเส้นทางเพียงครั้งเดียว\n\n**ข้อมูลนำเข้า**\n\nมีอยู่หนึ่งบรรทัดเป็นตัวเลขจำนวนเต็มบวกที่แสดงค่าของ d โดยที่ $2 \\le d \\le 14$\n\n**ข้อมูลส่งออก**\n\nมี $d \\times 2^{d-1}$ บรรทัด ที่แสดงเส้นทางเชื่อมทั้งหมด โดยแต่ละบรรทัดแสดงเลขประจำสถานีสองสถานีที่มีเส้นทางเชื่อมกัน คั่นด้วยช่องว่าง\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 | 00 01 |\n| | 00 10 |\n| | 01 11 |\n| | 10 11 |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | 000 001 |\n| | 000 010 |\n| | 000 100 |\n| | 001 011 |\n| | 001 101 |\n| | 010 011 |\n| | 010 110 |\n| | 100 101 |\n| | 100 110 |\n| | 011 111 |\n| | 101 111 |\n| | 110 111 |",
        "metadata": {
            "problem_id": "toi7_space",
            "problem_name": "toi7_space",
            "source": "TOI",
            "tags": [
                "bit-manipulation",
                "recursion",
                "brute-force",
                "string",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\nint n;\nvoid search(string s){\n    if(s.size()==n){\n        for(int i=n-1;i>-1;i--){\n            if(s[i]=='1')continue;\n            cout << s << ' ';\n            s[i]='1';\n            cout << s << \"\\n\";\n            s[i]='0';\n        }\n    }else{\n        search(s+'0');\n        search(s+'1');\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> n;\n    search(\"\");\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ส่งกระแสไฟฟ้า (electricity)**\n\nในการส่งกระแสไฟฟ้าจากต้นทาง (แปลงที่ 1) ไปถึงปลายทาง (แปลงที่ N) เมื่อไฟฟ้าเดินทางผ่านสายไฟ แรงดันไฟฟ้าจะลดลง ทำให้ต้องมีการตั้งสถานีเปลี่ยนแรงดันไฟฟ้า โดยมีเงื่อนไขว่าสถานีสองแห่งที่ส่งไฟฟ้าถึงกันโดยตรงต้องมีระยะห่างกันไม่เกิน k แปลง หากต้องการสร้างสถานีในที่ดินแปลงใด ก็จะต้องซื้อที่ดินแปลงนั้น\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพในการหาค่าใช้จ่ายรวมที่น้อยที่สุดในการซื้อที่ดินเพื่อตั้งสถานีทั้งหมด โดยกำหนดให้ต้องตั้งสถานีในแปลงหมายเลข 1 และหมายเลข N เสมอ\n\n**ข้อมูลเข้า**\n\n1.  **บรรทัดแรก** ระบุจำนวนแปลงที่ดิน N ($2\\le N\\le500,000$)\n2.  **บรรทัดที่สอง** ระบุค่า k แทนระยะห่างที่มากที่สุดระหว่างสถานีสองแห่ง ($1\\le k<N$ และ $k\\le20,000$)\n3.  **บรรทัดที่สาม** ประกอบด้วยเลขจำนวนเต็ม N จำนวน คั่นด้วยช่องว่าง แทนราคาที่ดินของแต่ละแปลง $P_1, P_2, ..., P_N$ ($1\\le P_i\\le2,000$)\n\n**ข้อมูลส่งออก**\n\nจำนวนเต็มที่แสดงค่าใช้จ่ายที่น้อยที่สุดในการซื้อที่ดินเพื่อตั้งสถานีเปลี่ยนแรงดันไฟฟ้า\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 7 | 7 |\n| 3 | |\n| 1 4 2 6 2 4 2 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 10 | 7 |\n| 4 | |\n| 2 1 4 3 2 1 5 1 2 3 | |",
        "metadata": {
            "problem_id": "toi8_electricity",
            "problem_name": "toi8_electricity",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "array"
            ],
            "solution_code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\nconst int N = 5e5 + 10;\nll n,k;\nll p[N],dp[N];\ndeque<int> dq;\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> n >> k;\n    for(int i=1;i<n+1;i++)cin >> p[i];\n\n    dq.push_back(1);\n    dp[1] = p[1];\n    for(int i=2;i<n+1;i++){\n        while(!dq.empty()&&i-dq.front()>k)dq.pop_front();\n        dp[i] = p[i] + dp[dq.front()];\n        while(!dq.empty()&&dp[i]<=dp[dq.back()])dq.pop_back();\n        dq.push_back(i);\n    }\n\n    cout << dp[n];\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**นักสู้ตัวเลข (fighter)**\n\nนักสู้ฝ่ายเลขคู่กับฝ่ายเลขคี่ทำการประลองกันแบบตัวต่อตัว โดยเริ่มต้นมี \"พลังงาน\" ฝ่ายละ P หน่วย การโจมตีถูกกำหนดโดยเลขที่เป็นข้อมูลเข้า หากเป็นเลขคู่ ฝ่ายเลขคู่โจมตี, หากเป็นเลขคี่ ฝ่ายเลขคี่โจมตี\n* การโจมตีแต่ละครั้งจะทำให้อีกฝ่ายเสียพลังงาน 1 หน่วย\n* หากฝ่ายใดโจมตีติดต่อกันเป็นครั้งที่สามหรือมากกว่า จะถือเป็นท่าชุดโจมตี ซึ่งจะทำให้อีกฝ่ายเสียพลังงานครั้งละ 3 หน่วย\n* การประลองจะจบลงทันทีเมื่อพลังงานของฝ่ายใดฝ่ายหนึ่งเหลือศูนย์หรือติดลบ\n\nจงเขียนโปรแกรมคำนวณหาผู้ชนะและตัวเลขที่ทำให้การประลองจบลง\n\n**ข้อมูลเข้า**\n\n1.  **บรรทัดแรก** คือจำนวนเต็ม P ระบุพลังงานเริ่มต้น ($1\\le P\\le500,000$)\n2.  **บรรทัดที่สอง** เป็นจำนวนเต็มทั้งหมด 2P จำนวน แต่ละตัวคั่นด้วยช่องว่าง\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดแรก** ระบุผู้ชนะ (0 เมื่อฝ่ายเลขคู่ชนะ, 1 หากฝ่ายเลขคี่ชนะ)\n2.  **บรรทัดที่สอง** ระบุตัวเลขแรกที่ทำให้ฝ่ายที่แพ้มีพลังงานเหลือศูนย์หรือติดลบ\n\n**ตัวอย่าง**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 | 1 |\n| 7 5 2 4 8 1 3 11 9 12 13 14 | 9 |\n| 8 | 0 |\n| 1 2 3 4 5 6 7 9 8 10 2 4 6 8 10 12 | 4 |\n| 10 | 1 |\n| 1 2 3 4 5 6 7 8 9 10 11 13 15 16 17 18 19 20 21 22 | 15 |",
        "metadata": {
            "problem_id": "toi8_fighter",
            "problem_name": "toi8_fighter",
            "source": "TOI",
            "tags": [
                "simulation",
                "implementation"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n\nint main() {\n    std::cin.tie(nullptr)->sync_with_stdio(false);\n\n    int initialLife;\n    std::cin >> initialLife;\n\n    int player1Life = initialLife; // Player 1 (loses life for odd numbers)\n    int player2Life = initialLife; // Player 2 (loses life for even numbers)\n\n    int consecutiveOdds = 0;\n    int consecutiveEvens = 0;\n\n    int totalNumbers = 2 * initialLife;\n    std::vector<int> numbers(totalNumbers);\n\n    for (int i = 0; i < totalNumbers; ++i) {\n        std::cin >> numbers[i];\n    }\n\n    for (int i = 0; i < totalNumbers; ++i) {\n        int currentNumber = numbers[i];\n\n        if (currentNumber % 2 == 1) { // Odd number\n            consecutiveOdds++;\n            consecutiveEvens = 0; // Reset consecutive evens\n\n            if (consecutiveOdds >= 3) {\n                player1Life -= 3;\n            } else {\n                player1Life--;\n            }\n        } else { // Even number\n            consecutiveEvens++;\n            consecutiveOdds = 0; // Reset consecutive odds\n\n            if (consecutiveEvens >= 3) {\n                player2Life -= 3;\n            } else {\n                player2Life--;\n            }\n        }\n\n        if (player1Life <= 0) {\n            std::cout << 1 << \"\\n\" << currentNumber << std::endl;\n            return 0;\n        } else if (player2Life <= 0) {\n            std::cout << 0 << \"\\n\" << currentNumber << std::endl;\n            return 0;\n        }\n    }\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**หาทำเลตั้งศูนย์บริการลูกค้า (location)**\n\nร้านคอมพิวเตอร์ต้องการเปิดศูนย์บริการลูกค้าในเมืองใหม่ซึ่งมีผังเมืองเป็นพื้นที่สี่เหลี่ยมย่อย $M \\times N$ พื้นที่ และทราบจำนวนประชากรในแต่ละพื้นที่แล้ว ร้านจะเปิดศูนย์บริการเพียงร้านเดียวซึ่งจะครอบคลุมพื้นที่บริการขนาด $K \\times K$\n\nจงเขียนโปรแกรมที่มีประสิทธิภาพในการหาจำนวนประชากรรวมในทำเลพื้นที่บริการที่ดีที่สุด (มีประชากรรวมกันมากที่สุด)\n\n**ข้อมูลเข้า**\n\n1.  **บรรทัดแรก** เป็นเลขจำนวนเต็มบวกสองตัว M (แถว) และ N (หลัก) ($2\\le M, N\\le1,000$)\n2.  **บรรทัดที่สอง** ระบุขนาดพื้นที่บริการ K ($0<K<M$ และ $0<K<N$)\n3.  **บรรทัดที่สามถึง M+2** ระบุจำนวนประชากรในแต่ละพื้นที่ย่อย (ไม่เกิน 2,000 คนต่อพื้นที่)\n\n**ข้อมูลส่งออก**\n\nจำนวนประชากรภายในพื้นที่บริการที่ดีที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 10 | 31 |\n| 2 | |\n| 5 9 2 9 1 2 8 9 1 6 | |\n| 9 1 3 9 8 4 2 1 5 7 | |\n| 2 7 9 3 8 5 2 7 6 8 | |\n| 1 6 2 1 7 7 1 9 4 1 | |\n| 8 5 2 3 9 8 5 6 3 3 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 4 | 55 |\n| 3 | |\n| 8 7 5 1 | |\n| 3 0 5 2 | |\n| 3 3 2 9 | |\n| 7 9 9 8 | |\n| 3 4 5 9 | |\n| 6 8 5 2 | |",
        "metadata": {
            "problem_id": "toi8_location",
            "problem_name": "toi8_location",
            "source": "TOI",
            "tags": [
                "array",
                "prefix-sum"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1010;\nint a[N][N], qs[N][N];\n\nint main(){\n  cin.tie(nullptr)->sync_with_stdio(0);\n  int n,m,k,ans=0; cin>>n>>m>>k;\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=m;j++) cin>>a[i][j], qs[i][j] = a[i][j]+qs[i-1][j]+qs[i][j-1]-qs[i-1][j-1];\n  for(int i=k;i<=n;i++){\n    for(int j=k;j<=m;j++){\n      ans = max(ans,qs[i][j]-qs[i-k][j]-qs[i][j-k]+qs[i-k][j-k]);\n    }\n  }\n  cout<<ans;\n  return 0;\n}"
        }
    },
    {
        "page_content": "**ฝ่าเขาวงกต (maze)**\n\nนักล่าขุมทรัพย์ตกลงไปในเขาวงกตขนาด M แถว N หลัก ซึ่งประกอบด้วยทางเดิน (เลข 1) และกำแพง (เลข 0) เขาจำเป็นต้องใช้ระเบิดที่มีเพียงลูกเดียวเพื่อทำลายกำแพงหนึ่งช่องเพื่อสร้างทางเดินไปยังทางออก\n\nจงเขียนโปรแกรมหาจำนวนช่องของกำแพงที่สามารถทำการระเบิดเพื่อสร้างทางไปสู่ทางออกได้ และหาระยะทางเดินที่สั้นที่สุดจากจุดเริ่มต้นไปจนถึงทางออก (ระยะทางนับรวมช่องเริ่มต้น, สิ้นสุด, และช่องกำแพงที่ถูกระเบิด)\n\n**ข้อมูลเข้า**\n\n1.  **บรรทัดแรก** ระบุค่า M และ N (จำนวนแถวและหลัก, $1\\le M, N\\le150$)\n2.  **บรรทัดที่สอง** ระบุแถว ($r_s$) และหลัก ($c_s$) ของจุดเริ่มต้น\n3.  **บรรทัดที่สาม** ระบุแถว ($r_e$) และหลัก ($c_e$) ของทางออก\n4.  **M บรรทัดถัดมา** เป็นแผนที่เขาวงกต\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดแรก** ระบุจำนวนช่องกำแพงที่สามารถวางระเบิดแล้วไปถึงทางออกได้\n2.  **บรรทัดที่สอง** ระบุระยะทางที่น้อยที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 8 | 4 |\n| 4 5 | 6 |\n| 2 8 | |\n| 0 0 1 1 0 0 0 0 | |\n| 0 1 1 1 0 1 1 1 | |\n| 0 1 1 1 1 0 0 1 | |\n| 1 1 0 0 1 0 0 1 | |\n| 0 0 1 1 0 1 1 1 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 8 | 4 |\n| 1 4 | 13 |\n| 2 7 | |\n| 0 0 1 1 0 0 0 0 | |\n| 0 1 1 1 0 0 1 1 | |\n| 0 1 1 1 1 0 0 1 | |\n| 1 1 0 0 1 0 0 1 | |\n| 0 0 1 1 0 1 1 1 | |\n| 1 0 1 0 1 1 1 1 | |",
        "metadata": {
            "problem_id": "toi8_maze",
            "problem_name": "toi8_maze",
            "source": "TOI",
            "tags": [
                "bfs",
                "graph"
            ],
            "solution_code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <algorithm>\n\nconst int MAX_GRID_SIZE = 160;\nconst int ROW_DIRECTIONS[] = {0, 0, -1, 1}; // Corresponds to Left, Right, Up, Down\nconst int COL_DIRECTIONS[] = {-1, 1, 0, 0}; // Corresponds to Left, Right, Up, Down\n\nint numRows, numCols, minTotalDistance = 1e9, intersectionCount = 0;\n\nint sourceCoords[2]; // {row, col}\nint destCoords[2];   // {row, col}\n\nint distances[2][MAX_GRID_SIZE][MAX_GRID_SIZE]; // [0] for source, [1] for destination\n\nint grid[MAX_GRID_SIZE][MAX_GRID_SIZE];\n\nstd::queue<std::tuple<int, int, int>> bfsQueue;\n\nvoid runBFS(int startRow, int startCol, int bfsIndex) {\n    bfsQueue.push({startRow, startCol, distances[bfsIndex][startRow][startCol] = 1});\n\n    while (!bfsQueue.empty()) {\n        auto [currentRow, currentCol, currentDistance] = bfsQueue.front();\n        bfsQueue.pop();\n\n        for (int k = 0; k < 4; ++k) {\n            int nextRow = currentRow + ROW_DIRECTIONS[k];\n            int nextCol = currentCol + COL_DIRECTIONS[k];\n\n            if (nextRow < 1 || nextRow > numRows || nextCol < 1 || nextCol > numCols || distances[bfsIndex][nextRow][nextCol] != 0) {\n                continue;\n            }\n\n            distances[bfsIndex][nextRow][nextCol] = currentDistance + 1;\n\n            if (grid[nextRow][nextCol] != 0) {\n                bfsQueue.push({nextRow, nextCol, currentDistance + 1});\n            }\n        }\n    }\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n\n    std::cin >> numRows >> numCols >> sourceCoords[0] >> sourceCoords[1] >> destCoords[0] >> destCoords[1];\n\n    for (int i = 1; i <= numRows; ++i) {\n        for (int j = 1; j <= numCols; ++j) {\n            std::cin >> grid[i][j];\n        }\n    }\n\n    runBFS(sourceCoords[0], sourceCoords[1], 0);\n\n    runBFS(destCoords[0], destCoords[1], 1);\n\n    for (int i = 1; i <= numRows; ++i) {\n        for (int j = 1; j <= numCols; ++j) {\n            if (grid[i][j] == 0 && distances[0][i][j] != 0 && distances[1][i][j] != 0) {\n                intersectionCount++;\n                minTotalDistance = std::min(minTotalDistance, distances[0][i][j] + distances[1][i][j] - 1);\n            }\n        }\n    }\n\n    std::cout << intersectionCount << \"\\n\" << minTotalDistance << std::endl;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**จัดลำดับการทดลอง (schedule)**\n\nนายเมธาต้องการทำการทดลองทางวิทยาศาสตร์สองงาน โดยแต่ละงานประกอบด้วย N ขั้นตอน ซึ่งขั้นตอนในงานเดียวกันไม่สามารถสลับลำดับได้ แต่สามารถสลับลำดับขั้นตอนระหว่างสองงานได้\n\nห้องปฏิบัติการมีเครื่องมือเพียงชุดเดียวที่สามารถทำงานได้เพียง M นาทีในแต่ละวัน และการทดลองแต่ละขั้นตอนต้องดำเนินการอย่างต่อเนื่องให้สำเร็จภายในวันเดียว\n\nจงเขียนโปรแกรมจัดลำดับขั้นตอนการทดลองที่ทำให้การทดลองทั้งสองงานเสร็จด้วยเวลาที่น้อยที่สุด (พิจารณาจากจำนวนวันเป็นอันดับแรก ตามด้วยเวลาน้อยที่สุดในวันสุดท้าย)\n\n**ข้อมูลเข้า**\n\n1.  **บรรทัดแรก** เป็นเลขจำนวนเต็ม M (เวลาที่ใช้เครื่องมือได้ต่อวัน, $1\\le M\\le600$)\n2.  **บรรทัดที่สอง** เป็นจำนวนเต็ม N (จำนวนขั้นตอนในแต่ละงาน, $2\\le N\\le1000$)\n3.  **บรรทัดที่สาม** เป็นเวลาที่ใช้ในแต่ละขั้นตอนของงานแรก\n4.  **บรรทัดที่สี่** เป็นเวลาที่ใช้ในแต่ละขั้นตอนของงานที่สอง\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดแรก** ระบุจำนวนวันที่ต้องใช้ในการทดลอง\n2.  **บรรทัดที่สอง** ระบุจำนวนนาทีที่ใช้ในวันสุดท้าย\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 | 4 |\n| 4 | 8 |\n| 4 5 6 4 | |\n| 3 3 2 4 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 8 | 6 |\n| 6 | 5 |\n| 3 2 4 5 3 2 | |\n| 2 6 3 2 4 5 | |",
        "metadata": {
            "problem_id": "toi8_schedule",
            "problem_name": "toi8_schedule",
            "source": "TOI",
            "tags": [
                "greedy",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\ntypedef long long ll;\nusing namespace std;\n\nconst int N = 1010;\npair<int,int> dp[N][N];\nint A[N],B[N];\nint n,m;\n\npair<int,int> cal(pair<int,int> a,int b){\n    if(a.second+b>m)return {a.first+1,b};\n    return {a.first,a.second+b};\n}\n\nint main(){\n    ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\n    cin >> m >> n;\n    for(int i=1;i<n+1;i++)cin >> A[i];\n    for(int i=1;i<n+1;i++)cin >> B[i];\n\n    for(int i=0;i<n+1;i++)for(int j=0;j<n+1;j++){\n        if(i==0&&j==0)continue;\n        dp[i][j] = {1e9,1e9};\n        if(i)dp[i][j] = min(dp[i][j],cal(dp[i-1][j],A[i]));\n        if(j)dp[i][j] = min(dp[i][j],cal(dp[i][j-1],B[j]));\n    }\n\n    cout << dp[n][n].first+(dp[n][n].second>0) << \"\\n\" << dp[n][n].second;\n\n    return 0;\n}"
        }
    },
    {
        "page_content": "**ผลการแข่งกีฬา (sport)**\n\nการแข่งขันกีฬาตัดสินผู้ชนะจากฝ่ายที่ชนะ k เซต จากทั้งหมด $2k-1$ เซตก่อน การแข่งขันจะจบลงทันทีที่ตัดสินผู้ชนะได้\n\nกำหนดให้ `W` แทนทีม ก ชนะ และ `L` แทนทีม ก แพ้ จงเขียนโปรแกรมที่แสดงรูปแบบผลการแข่งขันของเซตที่เหลือทั้งหมดที่เป็นไปได้ เมื่อกำหนดค่า k และผลการแข่งขันที่แข่งไปแล้ว\n\n**ข้อมูลเข้า**\n\n1.  **บรรทัดแรก** คือจำนวนเซต k ที่ใช้ตัดสินฝ่ายชนะ ($2\\le k\\le100$)\n2.  **บรรทัดที่สอง** คือจำนวนเต็ม a แทนจำนวนเซตที่ทีม ก ชนะไปแล้ว ($0\\le a<k$)\n3.  **บรรทัดที่สาม** คือจำนวนเต็ม b แทนจำนวนเซตที่ทีม ก แพ้ไปแล้ว ($0\\le b<k$)\n\n**ข้อมูลส่งออก**\n\nแสดงรูปแบบผลการแข่งขันของเซตที่เหลือทั้งหมดที่เป็นไปได้ โดยในแต่ละบรรทัดแสดงหนึ่งรูปแบบ และคั่นผลแต่ละเซตด้วยช่องว่าง (ลำดับการแสดงรูปแบบไม่มีผลต่อความถูกต้อง)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 | W W |\n| 0 | W L |\n| 1 | L |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 2 | W |\n| 1 | L W |\n| 0 | L L |\n\n**ตัวอย่างที่ 3**\n\n| ข้อมูลเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 | W W W |\n| 0 | W W L W |\n| 0 | ... (และรูปแบบอื่นๆ) |",
        "metadata": {
            "problem_id": "toi8_sport",
            "problem_name": "toi8_sport",
            "source": "TOI",
            "tags": [
                "string",
                "recursion",
                "backtracking"
            ],
            "solution_code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint k,a,b;\n\nvoid dfs(int w,int l,string s){\n    if(w==k || l==k){\n        cout<<s<<endl;\n        return;\n    }\n\n    dfs(w+1,l,s+\"W \");\n    dfs(w,l+1,s+\"L \");\n}\n\nint main(){\n    ios::sync_with_stdio(false); cin.tie(0);\n    \n    cin>>k>>a>>b;\n\n    dfs(a,b,\"\");\n}"
        }
    },
    {
        "page_content": "**รวงผึ้ง (Beehive)**\n\nรวงผึ้งประกอบด้วยหลอดรวงลักษณะ 6 เหลี่ยม จำนวน m แถว และ n คอลัมน์ ในแต่ละหลอดรวงจะมีปริมาตรน้ำผึ้งบรรจุอยู่\n\nนักเรียนมีหุ่นยนต์เก็บน้ำผึ้งที่ต้องเลือกเก็บน้ำผึ้งหนึ่งหลอดรวงต่อแถว โดยเริ่มจากแถวบนสุด (แถวที่ 0) ในคอลัมน์ใดก็ได้ และสิ้นสุดที่แถวล่างสุด (แถวที่ m-1) ในการเคลื่อนที่ไปยังแถวถัดไป หุ่นยนต์สามารถเคลื่อนที่ลงไปที่หลอดรวงที่ติดกันทางด้านซ้ายหรือด้านขวาเท่านั้น\n\nจงเขียนโปรแกรมหาปริมาตรน้ำผึ้งที่มากที่สุดที่หุ่นยนต์สามารถเก็บได้ พร้อมทั้งจำนวนวิธีการเก็บน้ำผึ้งให้ได้ปริมาตรมากที่สุด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่หนึ่ง** จำนวนเต็ม 2 จำนวน m และ n แทนจำนวนแถวและคอลัมน์ของรวงผึ้ง ($3 \\le m,n \\le 1,000$)\n2.  **บรรทัดที่สองถึง m+1** แต่ละบรรทัดประกอบด้วยจำนวนเต็ม n จำนวน แทนปริมาตรน้ำผึ้งในแต่ละหลอดรวง\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด เป็นจำนวนเต็มสองจำนวนคั่นด้วยช่องว่าง:\n1.  ปริมาตรน้ำผึ้งที่เก็บได้มากที่สุด\n2.  จำนวนวิธีการทั้งหมดที่สามารถเก็บน้ำผึ้งให้ได้ปริมาตรมากที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 4 | 114 1 |\n| 8 10 25 3 | |\n| 4 12 33 1 | |\n| 4 51 13 4 | |\n| 1 20 11 12 | |\n| 1 5 6 25 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 3 | 61 4 |\n| 10 10 0 | |\n| 0 14 0 | |\n| 17 17 0 | |\n| 20 0 0 | |",
        "metadata": {
            "problem_id": "toi9_beehive",
            "problem_name": "toi9_beehive",
            "source": "TOI",
            "tags": [
                "dynamic-programming",
                "array"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pii pair<int, int>\n\n#define inf 0x3f3f3f3f\n\n\nint n, m, k, s, cur;\n\nbool flag[200001];\n\nvector<pii> edges;\n\npii val[200001];\n\n\nint main() {\n\n  ios_base::sync_with_stdio(0);\n\n  cin.tie(0);\n\n  cin >> k >> n >> m;\n\n  for (int i = 1; i <= n; i++) cin >> val[i].first, val[i].second = i;\n\n  edges.resize(m);\n\n  for (int i = 0; i < m; i++) {\n\n    int u, h; cin >> u >> h;\n\n    edges[i] = {h, u};\n\n  }\n\n  sort(edges.begin(), edges.end());\n\n  cin >> s;\n\n  cur = s;\n\n  if (cur+1 <= n) flag[cur+1] = 1;\n\n  if (cur-1 >= 1) flag[cur-1] = 1;\n\n\n  for (auto [h, u]: edges) {\n\n    if (flag[u] && !flag[u+1]) flag[u+1] = 1, flag[u] = 0;\n\n    else if (flag[u+1] && !flag[u]) flag[u] = 1, flag[u+1] = 0;\n\n    if (cur == u) cur = u+1;\n\n    else if (cur == u+1) cur = u;\n\n    if (cur+1 <= n) flag[cur+1] = 1;\n\n    if (cur-1 >= 1) flag[cur-1] = 1;\n\n  }\n\n\n\n  sort(val+1, val+n+1, greater<pii>());\n\n  for (auto [v, i]: val) {\n\n    if (cur == i) {\n\n      cout << v << \"\\nNO\";\n\n      return 0;\n\n    }\n\n    if (flag[i]) {\n\n      cout << v << \"\\nUSE\";\n\n      return 0;\n\n    }\n\n  }\n\n}"
        }
    },
    {
        "page_content": "**เส้นทางเตือนภัยพิบัติ (Disaster)**\n\nทางการจำเป็นต้องส่งเจ้าหน้าที่เดินทางไปเตือนภัยประชาชนที่อาศัยอยู่ตาม \"ทางเดิน\" n เส้นในพื้นที่ โดยทางเดินคือเส้นทางที่เชื่อมจุดสองจุดเข้าด้วยกัน (เรียกว่า \"จุดปลาย\")\n\nเจ้าหน้าที่ต้องเริ่มต้นเดินทางจากจุดปลายใดก็ได้แล้วเดินทางไปตามทางเดินทุกเส้นให้ครบ โดยไม่เดินซ้ำทางเดินเส้นเดิม (แต่สามารถเดินทางผ่านจุดปลายเดิมได้มากกว่าหนึ่งครั้ง)\n\nจงเขียนโปรแกรมเพื่อหาลำดับการเดินทางของเจ้าหน้าที่ที่เป็นไปตามเงื่อนไขที่กำหนด\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่หนึ่ง** ระบุจำนวนเต็ม n แสดงจำนวนทางเดินทั้งหมด ($n \\le 300$)\n2.  **บรรทัดที่สองถึง n+1** แต่ละบรรทัดเป็นตัวอักษรสองตัวติดกัน (A-Z) ระบุจุดปลายสองจุดของทางเดินแต่ละเส้น\n\n**ข้อมูลส่งออก**\n\nมีหนึ่งบรรทัด ระบุตัวอักษรแทนจุดปลายต่าง ๆ ตามลำดับในการเดินทางของเจ้าหน้าที่ แต่ละจุดปลายคั่นด้วยช่องว่าง (หากมีคำตอบที่เป็นไปได้หลายแบบ สามารถตอบแบบใดก็ได้)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 6 | B C E A B D E |\n| AB | |\n| AE | |\n| BD | |\n| BC | |\n| CE | |\n| DE | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 4 | D A B C D |\n| AB | |\n| DA | |\n| BC | |\n| DC | |",
        "metadata": {
            "problem_id": "toi9_disaster",
            "problem_name": "toi9_disaster",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nclass Solution {\n\npublic:\n\n    unordered_map<char, multiset<char>> graph;\n\n    vector<char> path;\n\n\n    void dfs(char node) {\n\n        while (!graph[node].empty()) {\n\n            char next = *graph[node].begin();\n\n            graph[node].erase(graph[node].begin());\n\n            graph[next].erase(graph[next].find(node));\n\n            dfs(next);\n\n        }\n\n        path.push_back(node);\n\n    }\n\n\n    void solve() {\n\n        int edgeCount;\n\n        cin >> edgeCount;\n\n\n        set<char> allNodes;\n\n        for (int i = 0; i < edgeCount; ++i) {\n\n            string s;\n\n            cin >> s;\n\n            char u = s[0], v = s[1];\n\n            graph[u].insert(v);\n\n            graph[v].insert(u);\n\n            allNodes.insert(u);\n\n            allNodes.insert(v);\n\n        }\n\n\n        // Find start point for Eulerian path\n\n        char start = *allNodes.begin(); // default start\n\n        for (char c : allNodes) {\n\n            if (graph[c].size() % 2 == 1) {\n\n                start = c;\n\n                break;\n\n            }\n\n        }\n\n\n        dfs(start);\n\n        reverse(path.begin(), path.end());\n\n        for (int i = 0; i < path.size(); ++i) {\n\n            cout << path[i];\n\n            if (i + 1 < path.size()) cout << ' ';\n\n        }\n\n        cout << '\\n';\n\n    }\n\n};\n\n\nint main() {\n\n    ios::sync_with_stdio(false);\n\n    cin.tie(nullptr);\n\n    Solution().solve();\n\n}\n\n"
        }
    },
    {
        "page_content": "**รั้วระแนงปลูกดอกไม้ (Fence)**\n\nผู้บริหารต้องการสร้างรั้วระแนงสี่เหลี่ยมจัตุรัสในสวนสาธารณะขนาด $m \\times n$ ตารางหน่วย ซึ่งมีต้นไม้ใหญ่ t ต้นอยู่ภายใน รั้วที่สร้างจะต้องไม่ทับบริเวณที่มีต้นไม้อยู่\n\nจงเขียนโปรแกรมเพื่อหาขนาดของรั้วสี่เหลี่ยมจัตุรัสที่ใหญ่ที่สุดที่สามารถสร้างได้โดยไม่ทับต้นไม้\n\n**ข้อกำหนดเพิ่มเติม**\n\nข้อมูลนำเข้าประกอบด้วยข้อมูลสวนสาธารณะสองแห่ง โปรแกรมจะต้องคำนวณหาขนาดรั้วที่ใหญ่ที่สุดของสวนทั้งสองแห่ง\n\n**ข้อมูลนำเข้า**\n\nข้อมูลของสวนสาธารณะสองแห่ง โดยแต่ละแห่งมีรายละเอียดดังนี้:\n1.  **บรรทัดที่หนึ่ง** มีจำนวนเต็มสองค่า m และ n ระบุขนาดของสวน ($3 \\le m, n \\le 500$)\n2.  **บรรทัดที่สอง** มีจำนวนเต็ม t ระบุจำนวนต้นไม้ ($1 \\le t \\le 100,000$)\n3.  **t บรรทัดถัดมา** แต่ละบรรทัดมีจำนวนเต็มสองจำนวน r และ c ระบุพิกัดของต้นไม้\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดที่หนึ่ง** เป็นความยาวด้านของรั้วที่ใหญ่ที่สุดที่สร้างได้ในสวนสาธารณะแห่งแรก\n2.  **บรรทัดที่สอง** เป็นความยาวด้านของรั้วที่ใหญ่ที่สุดที่สร้างได้ในสวนสาธารณะแห่งที่สอง\n\n**ตัวอย่าง**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 8 | 4 |\n| 6 | 3 |\n| 0 7 | |\n| 1 3 | |\n| 2 0 | |\n| 3 6 | |\n| 4 2 | |\n| 4 5 | |\n| 5 5 | |\n| 8 | |\n| 0 0 | |\n| 0 4 | |\n| 4 0 | |\n| 4 4 | |\n| 0 1 | |\n| 2 0 | |\n| 2 4 | |\n| 4 3 | |",
        "metadata": {
            "problem_id": "toi9_fence",
            "problem_name": "toi9_fence",
            "source": "TOI",
            "tags": [
                "array",
                "implementation",
                "geometry"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pii pair<int, int>\n\n#define inf 0x3f3f3f3f\n\n\nint n, m, k, s, cur;\n\nbool flag[200001];\n\nvector<pii> edges;\n\npii val[200001];\n\n\nint main() {\n\n  ios_base::sync_with_stdio(0);\n\n  cin.tie(0);\n\n  cin >> k >> n >> m;\n\n  for (int i = 1; i <= n; i++) cin >> val[i].first, val[i].second = i;\n\n  edges.resize(m);\n\n  for (int i = 0; i < m; i++) {\n\n    int u, h; cin >> u >> h;\n\n    edges[i] = {h, u};\n\n  }\n\n  sort(edges.begin(), edges.end());\n\n  cin >> s;\n\n  cur = s;\n\n  if (cur+1 <= n) flag[cur+1] = 1;\n\n  if (cur-1 >= 1) flag[cur-1] = 1;\n\n\n  for (auto [h, u]: edges) {\n\n    if (flag[u] && !flag[u+1]) flag[u+1] = 1, flag[u] = 0;\n\n    else if (flag[u+1] && !flag[u]) flag[u] = 1, flag[u+1] = 0;\n\n    if (cur == u) cur = u+1;\n\n    else if (cur == u+1) cur = u;\n\n    if (cur+1 <= n) flag[cur+1] = 1;\n\n    if (cur-1 >= 1) flag[cur-1] = 1;\n\n  }\n\n\n\n  sort(val+1, val+n+1, greater<pii>());\n\n  for (auto [v, i]: val) {\n\n    if (cur == i) {\n\n      cout << v << \"\\nNO\";\n\n      return 0;\n\n    }\n\n    if (flag[i]) {\n\n      cout << v << \"\\nUSE\";\n\n      return 0;\n\n    }\n\n  }\n\n}"
        }
    },
    {
        "page_content": "**แผนผังท่อประปา (Pipe)**\n\nบริษัทวางผังท่อประปาได้ออกแบบการวางท่อในสนามหญ้าขนาด $m \\times n$ ตารางหน่วย โดยแต่ละช่องอาจมีท่อในรูปแบบต่างๆ หรือไม่มีเลย จุดเริ่มต้นและสิ้นสุดของแต่ละท่อจะอยู่ที่ขอบของสนามหญ้าเสมอ\n\nรหัสตัวเลขจะใช้แสดงรูปแบบท่อในแต่ละช่อง:\n* **0**: ไม่มีท่อ\n* **11-14**: ท่อข้อต่องอฉาก\n* **21, 22**: ท่อตรง (เหนือ-ใต้, ออก-ตก)\n* **31**: ท่อตรงสองท่อวางซ้อนกัน (เหนือ-ใต้ และ ออก-ตก) โดยไม่เชื่อมต่อกัน\n\nจงเขียนโปรแกรมเพื่อหาจำนวนท่อทั้งหมดในสนามหญ้า พร้อมทั้งระบุความยาวของแต่ละท่อ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่หนึ่ง** คือ จำนวนเต็ม m และ n ระบุขนาดของสนามหญ้า ($1 \\le m, n \\le 300$)\n2.  **m บรรทัดถัดมา** แต่ละบรรทัดประกอบด้วยจำนวนเต็ม n จำนวน แทนรูปแบบการวางท่อในแต่ละช่อง\n\n**ข้อมูลส่งออก**\n\n1.  **บรรทัดแรก** มีจำนวนเต็ม p แสดงจำนวนท่อทั้งหมด\n2.  **บรรทัดที่สอง** มีจำนวนเต็ม p จำนวน แทนความยาวของท่อแต่ละท่อ (ลำดับไม่สำคัญ)\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 6 | 3 |\n| 0 21 0 0 12 21 | 10 9 10 |\n| 22 14 31 11 0 21 | |\n| 21 0 12 13 0 21 | |\n| 22 14 31 11 14 31 | |\n| 0 21 12 22 11 22 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 3 5 | 1 |\n| 0 21 0 0 0 | 7 |\n| 22 31 13 0 0 | |\n| 0 12 11 0 0 | |",
        "metadata": {
            "problem_id": "toi9_pipe",
            "problem_name": "toi9_pipe",
            "source": "TOI",
            "tags": [
                "graph",
                "dfs",
                "implementation"
            ],
            "solution_code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\n    cin.tie(NULL)->sync_with_stdio(false);\n\n    int n,m,i,j,c=0,I,J;\n\n    char a,b;\n\n    cin >> n >> m;\n\n    vector<pair<char,char>> song[32];\n\n    song[11].push_back({'A','W'});\n\n    song[11].push_back({'W','A'});\n\n    song[12].push_back({'D','W'});\n\n    song[12].push_back({'W','D'});\n\n    song[13].push_back({'A','S'});\n\n    song[13].push_back({'S','A'});\n\n    song[14].push_back({'D','S'});\n\n    song[14].push_back({'S','D'});\n\n    song[21].push_back({'S','W'});\n\n    song[21].push_back({'W','S'});\n\n    song[22].push_back({'D','A'});\n\n    song[22].push_back({'A','D'});\n\n    song[31].push_back({'S','W'});\n\n    song[31].push_back({'W','S'});\n\n    song[31].push_back({'D','A'});\n\n    song[31].push_back({'A','D'});\n\n    vector<int> ans;\n\n    vector<vector<int>> arr(n,vector<int>(m));\n\n    for(i=0;i<n;i++){\n\n        for(j=0;j<m;j++){\n\n            cin >> arr[i][j];\n\n        }\n\n    }\n\n    queue<pair<char,pair<int,int>>> run,em;\n\n    for(i=0;i<m;i++){\n\n        if(arr[0][i]==0){\n\n            continue;\n\n        }\n\n        if(arr[0][i]==11||arr[0][i]==12||arr[0][i]==21||arr[0][i]==31){\n\n            c++;\n\n            int cou=0;\n\n            run.push({'W',{0,i}});\n\n            while(!run.empty()){\n\n                //cout << \"\\n\";\n\n                char p=run.front().first;\n\n                int x=run.front().second.first,y=run.front().second.second;\n\n                cou++;\n\n                run.pop();\n\n                /*for(I=0;I<n;I++){\n\n                    for(J=0;J<m;J++){\n\n                        cout << arr[I][J] << \" \";\n\n                    }cout << \"\\n\";\n\n                }//*/\n\n                if(x<0||y<0||x>=n||y>=m){\n\n                    break;\n\n                }\n\n\n                for(auto [a,b]:song[arr[x][y]]){\n\n                    //cout << a<< \" \" << b  << \"\\n\";\n\n                    if(p==a){\n\n                        if(b=='W'){\n\n                            run.push({'S',{x-1,y}});\n\n                        }\n\n                        else if(b=='A'){\n\n                            run.push({'D',{x,y-1}});\n\n                        }\n\n                        else if(b=='S'){\n\n                            run.push({'W',{x+1,y}});\n\n                        }\n\n                        else{\n\n                            run.push({'A',{x,y+1}});\n\n                        }\n\n\n                    }\n\n                }\n\n                if(arr[x][y]==31){\n\n                        if(p=='W'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else if(p=='A'){\n\n                            arr[x][y]=21;\n\n                        }\n\n                        else if(p=='S'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else{\n\n                           arr[x][y]=21;\n\n                        }\n\n                }\n\n                else{\n\n                    arr[x][y]=0;\n\n                }\n\n            }\n\n            run=em;\n\n            ans.push_back(cou);\n\n        }\n\n    }\n\n    for(i=0;i<m;i++){\n\n        if(arr[n-1][i]==0){\n\n            continue;\n\n        }\n\n        if(arr[n-1][i]==13||arr[n-1][i]==14||arr[n-1][i]==21||arr[n-1][i]==31){\n\n            c++;\n\n            int cou=0;\n\n            run.push({'S',{n-1,i}});\n\n            while(!run.empty()){\n\n                //cout << \"\\n\";\n\n                char p=run.front().first;\n\n                int x=run.front().second.first,y=run.front().second.second;\n\n                cou++;\n\n                run.pop();\n\n                /*for(I=0;I<n;I++){\n\n                    for(J=0;J<m;J++){\n\n                        cout << arr[I][J] << \" \";\n\n                    }cout << \"\\n\";\n\n                }//*/\n\n                if(x<0||y<0||x>=n||y>=m){\n\n                    break;\n\n                }\n\n\n                for(auto [a,b]:song[arr[x][y]]){\n\n                    //cout << a<< \" \" << b  << \"\\n\";\n\n                    if(p==a){\n\n                        if(b=='W'){\n\n                            run.push({'S',{x-1,y}});\n\n                        }\n\n                        else if(b=='A'){\n\n                            run.push({'D',{x,y-1}});\n\n                        }\n\n                        else if(b=='S'){\n\n                            run.push({'W',{x+1,y}});\n\n                        }\n\n                        else{\n\n                            run.push({'A',{x,y+1}});\n\n                        }\n\n\n                    }\n\n                }\n\n                if(arr[x][y]==31){\n\n                        if(p=='W'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else if(p=='A'){\n\n                            arr[x][y]=21;\n\n                        }\n\n                        else if(p=='S'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else{\n\n                           arr[x][y]=21;\n\n                        }\n\n                }\n\n                else{\n\n                    arr[x][y]=0;\n\n                }\n\n            }\n\n            run=em;\n\n            ans.push_back(cou);\n\n        }\n\n    }\n\n    for(i=0;i<n;i++){\n\n        if(arr[i][0]==0){\n\n            continue;\n\n        }\n\n        if(arr[i][0]==11||arr[i][0]==13||arr[i][0]==22||arr[i][0]==31){\n\n            c++;\n\n            int cou=0;\n\n            run.push({'A',{i,0}});\n\n            while(!run.empty()){\n\n                //cout << \"\\n\";\n\n                char p=run.front().first;\n\n                int x=run.front().second.first,y=run.front().second.second;\n\n                cou++;\n\n                run.pop();\n\n                /*for(I=0;I<n;I++){\n\n                    for(J=0;J<m;J++){\n\n                        cout << arr[I][J] << \" \";\n\n                    }cout << \"\\n\";\n\n                }//*/\n\n                if(x<0||y<0||x>=n||y>=m){\n\n                    break;\n\n                }\n\n\n                for(auto [a,b]:song[arr[x][y]]){\n\n                    //cout << a<< \" \" << b  << \"\\n\";\n\n                    if(p==a){\n\n                        if(b=='W'){\n\n                            run.push({'S',{x-1,y}});\n\n                        }\n\n                        else if(b=='A'){\n\n                            run.push({'D',{x,y-1}});\n\n                        }\n\n                        else if(b=='S'){\n\n                            run.push({'W',{x+1,y}});\n\n                        }\n\n                        else{\n\n                            run.push({'A',{x,y+1}});\n\n                        }\n\n\n                    }\n\n                }\n\n                if(arr[x][y]==31){\n\n                        if(p=='W'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else if(p=='A'){\n\n                            arr[x][y]=21;\n\n                        }\n\n                        else if(p=='S'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else{\n\n                           arr[x][y]=21;\n\n                        }\n\n                }\n\n                else{\n\n                    arr[x][y]=0;\n\n                }\n\n            }\n\n            run=em;\n\n            ans.push_back(cou);\n\n        }\n\n    }\n\n    for(i=0;i<n;i++){\n\n        if(arr[i][m-1]==0){\n\n            continue;\n\n        }\n\n        if(arr[i][m-1]==12||arr[i][m-1]==14||arr[i][m-1]==22||arr[i][m-1]==31){\n\n            c++;\n\n            int cou=0;\n\n            run.push({'D',{i,m-1}});\n\n            while(!run.empty()){\n\n                //cout << \"\\n\";\n\n                char p=run.front().first;\n\n                int x=run.front().second.first,y=run.front().second.second;\n\n                cou++;\n\n                run.pop();\n\n                /*for(I=0;I<n;I++){\n\n                    for(J=0;J<m;J++){\n\n                        cout << arr[I][J] << \" \";\n\n                    }cout << \"\\n\";\n\n                }//*/\n\n                if(x<0||y<0||x>=n||y>=m){\n\n                    break;\n\n                }\n\n\n                for(auto [a,b]:song[arr[x][y]]){\n\n                    //cout << a<< \" \" << b  << \"\\n\";\n\n                    if(p==a){\n\n                        if(b=='W'){\n\n                            run.push({'S',{x-1,y}});\n\n                        }\n\n                        else if(b=='A'){\n\n                            run.push({'D',{x,y-1}});\n\n                        }\n\n                        else if(b=='S'){\n\n                            run.push({'W',{x+1,y}});\n\n                        }\n\n                        else{\n\n                            run.push({'A',{x,y+1}});\n\n                        }\n\n\n                    }\n\n                }\n\n                if(arr[x][y]==31){\n\n                        if(p=='W'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else if(p=='A'){\n\n                            arr[x][y]=21;\n\n                        }\n\n                        else if(p=='S'){\n\n                            arr[x][y]=22;\n\n                        }\n\n                        else{\n\n                           arr[x][y]=21;\n\n                        }\n\n                }\n\n                else{\n\n                    arr[x][y]=0;\n\n                }\n\n            }\n\n            run=em;\n\n            ans.push_back(cou);\n\n        }\n\n    }//*/\n\n    cout << c << \"\\n\";\n\n    for(int x:ans){\n\n        cout << x-1 << \" \";\n\n    }\n\n}"
        }
    },
    {
        "page_content": "**ระบบนำทางยานอวกาศ (Spaceship)**\n\nนักเรียนต้องไปซื้อชิ้นส่วนคอมพิวเตอร์ (มอนิเตอร์, คีย์บอร์ด, ตัวเครื่อง) สำหรับประกอบคอมพิวเตอร์ n ชุด จากร้านค้า m ร้านในอาณานิคมอวกาศสามมิติ\n\nนักเรียนต้องออกแบบเส้นทางการเดินทางไปตามร้านค้าต่างๆ เพื่อซื้อของให้ครบตามจำนวน โดยใช้ค่าใช้จ่ายในการเดินทางน้อยที่สุด ค่าใช้จ่ายในการเดินทางระหว่างร้านค้า A($x_1, y_1, z_1$) และ B($x_2, y_2, z_2$) คือ $(x_2-x_1)^2 + (y_2-y_1)^2 + (z_2-z_1)^2$ การเดินทางจะสิ้นสุดเมื่อซื้อของชิ้นสุดท้ายครบ\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่หนึ่ง** จำนวนเต็ม n (จำนวนชุดคอมพิวเตอร์, $1 \\le n \\le 20$)\n2.  **บรรทัดที่สอง** พิกัดเริ่มต้น (x, y, z)\n3.  **บรรทัดที่สาม** จำนวนเต็ม m (จำนวนร้านค้า, $1 \\le m \\le 10$)\n4.  **2m บรรทัดถัดมา** เป็นข้อมูลของร้านค้า m ร้าน โดยแต่ละร้านใช้ 2 บรรทัด:\n    * บรรทัดแรก: พิกัดร้านค้า (x, y, z)\n    * บรรทัดที่สอง: จำนวนสินค้าแต่ละชนิด (มอนิเตอร์, คีย์บอร์ด, ตัวเครื่อง)\n\n**ข้อมูลส่งออก**\n\nค่าใช้จ่ายรวมของการเดินทางที่น้อยที่สุด\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 1 | 100 |\n| 0 0 0 | |\n| 2 | |\n| 10 0 0 | |\n| 2 5 7 | |\n| 0 10 0 | |\n| 0 3 9 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| 5 | 10542 |\n| 0 0 0 | |\n| 5 | |\n| 60 34 56 | |\n| 0 5 7 | |\n| 90 41 92 | |\n| 1 7 8 | |\n| 24 61 81 | |\n| 6 8 8 | |\n| 41 86 70 | |\n| 5 6 7 | |\n| 46 97 85 | |\n| 9 2 4 | |",
        "metadata": {
            "problem_id": "toi9_spaceship",
            "problem_name": "toi9_spaceship",
            "source": "TOI",
            "tags": [
                "geometry",
                "math",
                "brute-force"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pii pair<int, int>\n\n#define inf 0x3f3f3f3f\n\n\nint n, m, k, s, cur;\n\nbool flag[200001];\n\nvector<pii> edges;\n\npii val[200001];\n\n\nint main() {\n\n  ios_base::sync_with_stdio(0);\n\n  cin.tie(0);\n\n  cin >> k >> n >> m;\n\n  for (int i = 1; i <= n; i++) cin >> val[i].first, val[i].second = i;\n\n  edges.resize(m);\n\n  for (int i = 0; i < m; i++) {\n\n    int u, h; cin >> u >> h;\n\n    edges[i] = {h, u};\n\n  }\n\n  sort(edges.begin(), edges.end());\n\n  cin >> s;\n\n  cur = s;\n\n  if (cur+1 <= n) flag[cur+1] = 1;\n\n  if (cur-1 >= 1) flag[cur-1] = 1;\n\n\n  for (auto [h, u]: edges) {\n\n    if (flag[u] && !flag[u+1]) flag[u+1] = 1, flag[u] = 0;\n\n    else if (flag[u+1] && !flag[u]) flag[u] = 1, flag[u+1] = 0;\n\n    if (cur == u) cur = u+1;\n\n    else if (cur == u+1) cur = u;\n\n    if (cur+1 <= n) flag[cur+1] = 1;\n\n    if (cur-1 >= 1) flag[cur-1] = 1;\n\n  }\n\n\n\n  sort(val+1, val+n+1, greater<pii>());\n\n  for (auto [v, i]: val) {\n\n    if (cur == i) {\n\n      cout << v << \"\\nNO\";\n\n      return 0;\n\n    }\n\n    if (flag[i]) {\n\n      cout << v << \"\\nUSE\";\n\n      return 0;\n\n    }\n\n  }\n\n}"
        }
    },
    {
        "page_content": "**นักเวทย์แห่งต๋อย (Wizards of TOI)**\n\nอาณาจักรต๋อยได้รับการคุ้มครองโดย 4 นักเวทย์ (ดิน 'a', น้ำ 'b', ลม 'c', ไฟ 'd') ในอาณาจักรมีแหล่งกำหนดพลังธาตุแต่ละชนิดอยู่ N แหล่ง\n\nเมื่อมีจอมปีศาจปรากฏตัวที่พิกัด $(x_t, y_t)$ นักเวทย์ทั้งสี่ต้องร่ายเวทย์พร้อมกันจากแหล่งพลังของตนเองคนละแห่ง ให้สำเร็จ โดยผลรวมพิกัดของนักเวทย์ทั้งสี่ต้องเท่ากับพิกัดของจอมปีศาจพอดี:\n$x_t = x_a + x_b + x_c + x_d$\n$y_t = y_a + y_b + y_c + y_d$\n\nจงเขียนโปรแกรมเพื่อค้นหาชุดพิกัดที่นักเวทย์แต่ละคนต้องไปร่ายเวทย์ (มีเพียงชุดเดียวที่เป็นไปได้)\n\n**ข้อมูลนำเข้า**\n\n1.  **บรรทัดที่หนึ่ง** พิกัดจอมปีศาจ $x_t, y_t$\n2.  **บรรทัดที่สอง** จำนวนเต็ม N (จำนวนแหล่งพลังงานต่อธาตุ, $2 \\le N \\le 1,500$)\n3.  **บรรทัดที่ 3-6** พิกัดของแหล่งพลังงานธาตุดิน, น้ำ, ลม, และไฟ ตามลำดับ (แต่ละบรรทัดมี 2N จำนวน)\n\n**ข้อมูลส่งออก**\n\nแสดงพิกัดที่ถูกต้องสำหรับนักเวทย์แต่ละคน 4 บรรทัดเรียงตามลำดับ ดิน, น้ำ, ลม, ไฟ\n\n**ตัวอย่างที่ 1**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| -2 2 | -2 10 |\n| 2 | -6 -6 |\n| 1 2 -2 10 | -1 -2 |\n| -6 -6 -1 3 | 7 0 |\n| -1 -2 -6 -5 | |\n| 5 -4 7 0 | |\n\n**ตัวอย่างที่ 2**\n\n| ข้อมูลนำเข้า | ข้อมูลส่งออก |\n| :--- | :--- |\n| -1 3 | 16 3 |\n| 3 | -15 -2 |\n| 1 -10 16 3 -11 -10 | 5 19 |\n| -17 7 -15 -2 -7 9 | -7 -17 |\n| -2 6 -18 -15 5 19 | |\n| 9 -18 -7 -17 19 4 | |",
        "metadata": {
            "problem_id": "toi9_wizards",
            "problem_name": "toi9_wizards",
            "source": "TOI",
            "tags": [
                "array",
                "brute-force",
                "implementation"
            ],
            "solution_code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nint di,dj,n;\n\nvector<pair<int,int>> a,b,c,d;\n\nvector<pair<pair<int,int>,pair<int,int>>> mp;\n\n\nint main(){\n\n    cin>>di>>dj;\n\n    cin>>n;\n\n    for(int j=1;j<=n;j++){\n\n        int A,B;\n\n        cin>>A>>B;\n\n        a.push_back({A,B});\n\n    }\n\n    for(int j=1;j<=n;j++){\n\n        int A,B;\n\n        cin>>A>>B;\n\n        b.push_back({A,B});\n\n    }\n\n    for(int j=1;j<=n;j++){\n\n        int A,B;\n\n        cin>>A>>B;\n\n        c.push_back({A,B});\n\n    }\n\n    for(int j=1;j<=n;j++){\n\n        int A,B;\n\n        cin>>A>>B;\n\n        d.push_back({A,B});\n\n    }\n\n    for(int i=0;i<n;i++){\n\n        for(int j=0;j<n;j++){\n\n            int fx=a[i].first+b[j].first;\n\n            int fy=a[i].second+b[j].second;\n\n            mp.push_back({{fx,fy},{i,j}});\n\n        }\n\n    }\n\n    int len=mp.size()-1;\n\n    sort(mp.begin(),mp.end());\n\n    for(int i=0;i<n;i++){\n\n        for(int j=0;j<n;j++){\n\n            int tx1=c[i].first+d[j].first;\n\n            int ty1=c[i].second+d[j].second;\n\n            int tx=di-tx1;\n\n            int ty=dj-ty1;\n\n            int l=0;\n\n            int r=len;\n\n            while(l<=r){\n\n                int mid=(l+r)/2;\n\n                if(mp[mid].first.first>tx){\n\n                    r=mid-1;\n\n                }\n\n                else if(mp[mid].first.first<tx){\n\n                    l=mid+1;\n\n                }\n\n                else{\n\n                    if(mp[mid].first.second>ty){\n\n                        r=mid-1;\n\n                    }\n\n                    else if(mp[mid].first.second<ty){\n\n                        l=mid+1;\n\n                    }\n\n                    else{\n\n                        int A=mp[mid].second.first;\n\n                        int B=mp[mid].second.second;\n\n                        cout<<a[A].first<<' '<<a[A].second<<'\\n';\n\n                        cout<<b[B].first<<' '<<b[B].second<<'\\n';\n\n                        cout<<c[i].first<<' '<<c[i].second<<'\\n';\n\n                        cout<<d[j].first<<' '<<d[j].second<<'\\n';\n\n                        return 0;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n}"
        }
    }
]