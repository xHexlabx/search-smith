#include <iostream>     // For standard input/output operations (cin, cout)
#include <vector>       // For dynamic arrays (std::vector)
#include <algorithm>    // For sorting (std::sort), min/max (std::min, std::max)
#include <utility>      // For std::pair
#include <limits>       // For std::numeric_limits (to get max values for infinity)
// No need for <cmath> for squared distance, as it uses multiplication.

// Using 'long long' for integer calculations where large values might occur,
// as indicated by the original code's '#define int long long'.
using ll = long long;

// Represents an edge in the graph with a destination node, a type, and a weight.
struct GraphEdge {
    int dest_node_id; // The node this edge leads to.
    int type_s;       // A categorizing integer for the edge (e.g., 1 for 'f' sum, others for 'g' sum).
    ll weight;        // The weight associated with traversing this edge.
};

// Adjacency list to represent the graph. Global for competitive programming convenience.
std::vector<GraphEdge> adj[200010];

// Global variables for problem parameters:
// N_NODES: The total number of nodes in the graph.
// M_EDGES: The total number of edges.
// L_PARAM: An additional parameter whose exact role isn't clear from this snippet,
//          but it's read and used to size an array.
int N_NODES, M_EDGES, L_PARAM;

// Stores the 2D points (accumulated_f_sum, accumulated_g_sum) generated by the DFS.
std::vector<std::pair<ll, ll>> generated_points;

/**
 * @brief Traverses the graph using Depth-First Search to generate 2D points.
 *
 * Overall Idea: This function explores all possible paths from node 1 to node N_NODES.
 * For each path, it accumulates two separate sums based on the 'type_s' of the edges:
 * one sum for edges with `type_s = 1` (accumulated_f_sum) and another for other types
 * (accumulated_g_sum). When a path reaches the target node, the final pair of
 * accumulated sums forms a 2D point, which is then collected.
 *
 * @param current_node The node currently being visited in the DFS.
 * @param accumulated_f_sum The sum of weights for 'type_s=1' edges up to this point.
 * @param accumulated_g_sum The sum of weights for 'type_s!=1' edges up to this point.
 */
void dfs_generate_points(int current_node, ll accumulated_f_sum, ll accumulated_g_sum) {
    if (current_node == N_NODES) {
        generated_points.push_back({accumulated_f_sum, accumulated_g_sum});
        return;
    }
    for (const auto& edge : adj[current_node]) {
        if (edge.type_s == 1) {
            dfs_generate_points(edge.dest_node_id, accumulated_f_sum + edge.weight, accumulated_g_sum);
        } else {
            dfs_generate_points(edge.dest_node_id, accumulated_f_sum, accumulated_g_sum + edge.weight);
        }
    }
}

/**
 * @brief Calculates the squared Euclidean distance between two 2D points.
 *
 * Overall Idea: A straightforward mathematical helper to compute (x1-x2)^2 + (y1-y2)^2.
 * This is used instead of actual Euclidean distance to avoid floating-point issues and
 * precision problems common in competitive programming.
 *
 * @param p1 The first point.
 * @param p2 The second point.
 * @return The squared distance.
 */
ll calculate_squared_distance(std::pair<ll, ll> p1, std::pair<ll, ll> p2) {
    ll dx = p1.first - p2.first;
    ll dy = p1.second - p2.second;
    return dx * dx + dy * dy;
}

/**
 * @brief Finds the minimum squared distance between any two points in a given range
 * using the divide and conquer algorithm for the closest pair problem.
 *
 * Overall Idea: This is a classic divide-and-conquer approach for finding the closest
 * pair of points in a set. It works by:
 * 1.  **Divide:** Recursively finding the closest pair in the left and right halves of the points (sorted by X-coordinate).
 * 2.  **Conquer:** Taking the minimum distance found in the halves (`min_overall_dist`).
 * 3.  **Combine:** Efficiently checking for a closer pair where one point is in the left half and the other is in the right. This involves creating a narrow "strip" of points around the dividing line (within `sqrt(min_overall_dist)` distance) and sorting these strip points by their Y-coordinate for a final, limited comparison step.
 *
 * @param start_idx The starting index of the points sub-array.
 * @param end_idx The ending index of the points sub-array.
 * @return The minimum squared distance found within this range.
 */
ll find_closest_pair_squared_distance(int start_idx, int end_idx) {
    // Base case: If few points, brute force all pairs.
    if (end_idx - start_idx + 1 <= 3) {
        ll min_sq_dist = std::numeric_limits<ll>::max();
        for (int i = start_idx; i <= end_idx; ++i) {
            for (int j = i + 1; j <= end_idx; ++j) {
                min_sq_dist = std::min(min_sq_dist, calculate_squared_distance(generated_points[i], generated_points[j]));
            }
        }
        return min_sq_dist;
    }

    int mid_idx = start_idx + (end_idx - start_idx) / 2;
    std::pair<ll, ll> mid_point_x_val = generated_points[mid_idx]; // X-value of the dividing line

    ll min_dist_left_half = find_closest_pair_squared_distance(start_idx, mid_idx);
    ll min_dist_right_half = find_closest_pair_squared_distance(mid_idx + 1, end_idx);

    ll min_overall_dist = std::min(min_dist_left_half, min_dist_right_half);

    // Filter points to form a "strip" around the mid-line.
    std::vector<std::pair<ll, ll>> strip_points;
    for (int i = start_idx; i <= end_idx; ++i) {
        ll dx_from_mid_line = generated_points[i].first - mid_point_x_val.first;
        if (dx_from_mid_line * dx_from_mid_line < min_overall_dist) {
            strip_points.push_back(generated_points[i]);
        }
    }

    // Sort the strip points by Y-coordinate for efficient checking.
    std::sort(strip_points.begin(), strip_points.end(), [](const std::pair<ll, ll>& a, const std::pair<ll, ll>& b) {
        return a.second < b.second;
    });

    // Check distances only for points within the strip and close in Y-coordinate.
    for (size_t i = 0; i < strip_points.size(); ++i) {
        for (size_t j = i + 1; j < strip_points.size() && (strip_points[j].second - strip_points[i].second) * (strip_points[j].second - strip_points[i].second) < min_overall_dist; ++j) {
            min_overall_dist = std::min(min_overall_dist, calculate_squared_distance(strip_points[i], strip_points[j]));
        }
    }
    return min_overall_dist;
}

int main() {
    // Optimize C++ standard I/O for speed.
    std::cin.tie(nullptr)->sync_with_stdio(false);

    // Read problem parameters: N_NODES (nodes), M_EDGES (edges), L_PARAM (an additional parameter).
    std::cin >> N_NODES >> M_EDGES >> L_PARAM;

    // An array to store L_PARAM related information. Its specific use isn't apparent
    // in this snippet, but it's part of the input.
    std::vector<int> L_SIZE_ARRAY_INFO(L_PARAM + 1);
    for (int i = 1; i <= L_PARAM; ++i) {
        std::cin >> L_SIZE_ARRAY_INFO[i];
    }

    // Read graph edges and build the adjacency list representation.
    for (int i = 1; i <= M_EDGES; ++i) {
        int u, v, s_type;
        ll weight_val;
        std::cin >> u >> v >> s_type >> weight_val;
        adj[u].push_back({v, s_type, weight_val});
    }

    // Phase 1: Generate all relevant 2D points using DFS.
    // Start DFS from node 1 with initial sums of zero.
    dfs_generate_points(1, 0, 0);

    // Phase 2: Find the closest pair among the generated points.
    // First, sort all points by their X-coordinates, which is a prerequisite
    // for the efficient divide-and-conquer closest pair algorithm.
    std::sort(generated_points.begin(), generated_points.end(), [](const std::pair<ll, ll>& a, const std::pair<ll, ll>& b) {
        return a.first < b.first;
    });

    // Then, invoke the divide-and-conquer algorithm to find the minimum squared distance.
    ll minimum_squared_distance = find_closest_pair_squared_distance(0, generated_points.size() - 1);

    // Output the final result.
    std::cout << minimum_squared_distance << '\n';

    return 0;
}